<!DOCTYPE html>
<!--
  Stylotron IDE
  cc0 (public domain) v.010 November 2025, latest version @ github.com/gregsidal
-->

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stylotron IDE</title>
  <meta content="Stylotron IDE" name="description">
  <meta content="" name="author">

<style>
*, *::before, *::after {box-sizing:border-box; /*text-size-adjust:none;*/ outline:none;}
div, textarea {display:inline-block; margin:0; border:0; border-radius:0; padding:0;}
span, button, input, select, label {display:inline-block; border-radius:0; vertical-align:middle;}
label, input[type="checkbox"], button {cursor:pointer;}
mark {display:inline; border-radius:0; color:inherit; background-color:transparent;}
</style>

<style id="IDE_cssscript">/* (pasted from slylotron-samplestyles.css) */

/*
 * CSS Shared by Stylotron Demos and Project Documents
 * cc0 (public domain) v.010 September 2025
 * Stylotron project @ github.com/gregsidal
 *
 * Style blocks prefixed by .UNFOLDED apply only to editable markup
 * Style blocks prefixed by .FOLDED apply only to output html files
 * All other CSS is shared
 *
 * The WYSIWYG editor currently doesn't run in an iframe, so some 
 * styles such as 'position:fixed' used without 'FOLDED' may cover up 
 * the IDE's toolbar or make the IDE unusable in other ways when 
 * toggled to markup view
 *
 * Note that using display:block to produce line feeds is not necessary
 * Line feeds in the plaintext are always line feeds in the markup
 * display:block is not WYSIWYG editable
 *
 * :before and :after are outside editable flow
 */

/* universal defaults */
*, *::before, *::after {box-sizing:border-box; /*text-size-adjust:none;*/ outline:none;}
div, textarea {display:inline-block; margin:0; border:0; border-radius:0; padding:0;}
span, button, input, select, label {display:inline-block; border-radius:0; vertical-align:middle;}
label, input[type="checkbox"], button {cursor:pointer;}
*::spelling-error {text-decoration-line:none;}

.FOLDED div {display:block;}

/* markup defaults */
mark {border-radius:0; color:inherit; background-color:transparent;}
mark.L {border-top-left-radius:0.25em; border-bottom-left-radius:0.25em;}
mark.R {border-top-right-radius:0.25em; border-bottom-right-radius:0.25em;}

/* whole document */
.document {
  padding:0.7em; background-color:white; font-size:0.94em;
}
@media all and (min-width:749px) and (orientation:landscape) {
  .document {font-size:1.02em;}
}

/* paragraphs, section headers */
.paragraph {font-family:serif;}
.paragraph::spelling-error, .paragraph *::spelling-error {text-decoration-line:spelling-error;}
.paragraph.windows {font-family:'agency fb',serif; font-size:1.1em;}
.footnote {font-family:sans-serif; font-size:0.89em;}
.block>.heading, .block>.paragraph>.heading, .heading .footnote {font-family:sans-serif; font-weight:bold; font-size:1.0em;}

/* code blocks with line numbers */
.codeblockcontainer {
  position:relative; background-color:white;
}
.codeblock {
  font-family:monospace; background-color:white;
}
.codeblock.multiline {
  margin-left:1.7em;
}
.FOLDED .codeblock {
  white-space:pre; overflow-x:auto; padding-bottom:0.2em;
}
.codeblock.multiline .line.L {counter-increment:line;}
.codeblock.multiline .line.L:before {
  content:counter(line);
  position:absolute; left:0; margin-top:0.35em; width:2.55em; text-align:center;
  font-family:sans-serif; font-size:45%; font-style:italic; color:#777;
}

/* highlights */
.codeblock .line, .codeblock .block {color:#111;}
.comment.html {font-family:'courier new'; font-size:0.87em; color:blue;}
.comment.js {font-family:monospace; font-style:italic; color:#061;}
a {font-family:sans-serif; font-size:95%;}
.paragraph .quoted::spelling-error {text-decoration-line:none;}
.quoted.double, .italic {font-style:italic;}
.codeblock .quoted.double {font-family:'courier new'; font-size:0.87em; color:#000;}
.quoted.single {font-family:monospace; font-size:100%; font-weight:bold; color:#559;}
.tag.html {color:#a55;}
.tag.inline {font-family:monospace; color:#aaa;}
.tag.inline.footref {vertical-align:top; padding-left:0.1em;}
.FOLDED .tag.inline {display:none;}
.codeblock .quoted.single {font-weight:normal; color:#333;}
.codeblock .tag, .codeblock .keyword, .bold {font-weight:bold;}
.codeblock .quoted {color:#000;}
.codeblock .tag, a {color:#559;}
.codeblock .tag.html {color:#a55;}
.codeblock .keyword {color:#a55;}
a:visited {color:#684878;}
.regex, .number {font-family:'courier new'; font-size:0.87em; font-weight:bold; font-style:normal;}
.regex {color:#888;}
.number {color:#72a;}
.numberprefix, .footnotetag, .footnote .number:first-child {font-family:monospace; font-size:0.82em; font-style:normal; vertical-align:middle; color:#999;}
.heading .number, .heading .footnote .number {font-family:sans-serif; font-size:1.4em; font-style:italic; color:#e77; vertical-align:inherit;}
.footnoteref {font-family:sans-serif; font-size:0.8em; color:#e77 !important; vertical-align:top;}
.FOLDED .footnoteref {padding-left:0.3em;}
.regex .regexslashed {color:#d00;}
.regex .regexpattern {/*background-color:#f8f4ec;*/ color:#333;}

/* remove undesirable nested highlights */
.comment *, 
.codeblock .footnote,
.codeblock .footnote .number, .codeblock .footnote .number:first-child,
.codeblock .comment *, 
.comment .regex *, 
.codeblock .comment .regex *, 
.codeblock .comment .quoted,
.quoted *, 
.codeblock .quoted *, 
.tag.inline *,
.tag.inline.footref *,
.tag *, 
.codeblock .tag *, 
.codeblock .tag .quoted,
.regex .regexpattern *, 
.regex .comment, 
.regex .quoted, 
.codeblock .regex .quoted, 
.tag .number {
  font-family:inherit; font-size:inherit; font-style:inherit; font-weight:inherit; color:inherit; vertical-align:inherit;
}
.codeblock .quoted, .codeblock .tag .quoted {font-style:italic;}
.codeblock .regex .quoted {font-style:inherit;}

/* logo */
.heading .logoleft, .heading .logoright {font-weight:normal;}
.heading .logoright, .paragraph .logoright {
  position:relative; border:0.5px solid black;
  font-family:'courier new'; letter-spacing:0.04em;
  background-color:rgba(80,80,220,0.25); color:black;
}
.heading .logoleft, .paragraph .logoleft {
  font-family:'agency fb',sans-serif; font-style:italic;
  background-color:rgba(220,160,20,0.35); color:royalblue;
}
.heading .logoright {bottom:6px; font-size:16px;}
.heading .logoleft {font-size:38px;}
.paragraph .logoright {bottom:4px; font-size:10px;}
.paragraph .logoleft {font-size:20px;}
.heading .logoright.L, .paragraph .logoright.L {margin-left:0.13em; padding-left:0.13em; border-right:0;}
.heading .logoright.R, .paragraph .logoright.R {padding-right:0.13em; border-left:0;}
.heading .logoleft .logoright, .paragraph .logoleft .logoright {
  font-style:normal; background-color:rgba(205,200,205,0.72);
}

/* tooltip */
.FOLDED .link.L {
  position:relative; cursor:pointer;
}
.FOLDED .link.lib.L:after {
  position:absolute; left:90%; top:105%; /*margin-left:-50%; right:auto; bottom:auto;*/ z-index:1;
  visibility:hidden; opacity:0; transition: visibility 0.5s ease-in, opacity 0.5s ease-in;
  border-radius:0.3em; padding:0.2em;
  content:attr(tooltip);
  white-space:pre; text-align:center;
  font-family:sans-serif; font-size:60%; background-color:black; color:white;
}
.FOLDED .link.lib.L:hover:after {
  visibility:visible; opacity:1.0;
}

/* input and button */
.inputcontainer, .button {
  font-family:sans-serif; font-size:0.90em;
}
.input, .button {
  padding:0.2em;
}
.inputcontainer * {
  font-family:inherit; font-size:inherit; font-style:inherit; font-weight:inherit; color:inherit; vertical-align:inherit;
}
.input {
  margin-left:0.5em; border:0.5px solid #d8d8d8;
}
.button {
  border:0; border-radius:0.3em; padding:0.15em 0.35em; background-color:black; color:white;
}
.button:hover {
  background-color:#a77; color:black;
}

/* image */
.image {
  position:relative; display:inline-block !important;
  border-radius:0.3em; padding:0.2em;
  font-family:sans-serif; font-size:60%; background-color:black; color:white;
}
.image.sample:before, .FOLDED .img {
  position:relative; display:block;
}
.image.sample:before {
content:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOIAAACxCAYAAADZCmGOAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAACgNJREFUeF7t00GyLKcOBFDv0nvxqjz1fv78L8GG8CWirJfdBUUiqSAHZ0Yp1dD5219//P63iMRSEUUSUBFFElARRRJQEUUSUBFFElARRRJQEUUSUBFFElARRRJQEUUSUBFFElARRRJQEUUSUBFFElARRRJQEUUSUBFFElARO/3/f3+6Q3vInlTEH6gIWaB9ZS/HFxH98bNBe8teji4i+tNnhHaXvRxbRPSHv4PmiDAcVURULgt9J7LaMUVEpbtC34h4OaKIqHhX6BsRT9sXERWvQedFIhxZRHROJNLWRVQJ5S22LCIqYIPOi0TbroiofA067wXtcwp0H/JfWxUR/QkadN4D2kVUTmubIqLHrtBZL2gf+S90byd6fRHR41borBe0j3yG7vA0ry4ietQKnfWAdrlC35wA3QWCvj3Fa4uIHrJCZ1dCO1jou5OhO7pC3+zulUVEj1ehsyuhHSz0nfwL3VeDzu/sdUXM8mhojyv0jWDo/hp0fkevKiJ6qAqdXQnt0KDzcg/dZYPO7+Y1RczwQGiHCp2VZ9D9VujsTl5RxAwPg3ao0FmZd9pdpy9ihgdBO1TorPCcdN+pi2gfIuIx0A4VOitcJ9172iJmeIQMO5wOvUGFzr6ZivgByq/QWVkLvUOFzr5VyiJGX3p0vvwKvUmFzr7RK4qIzqxisxt0Vvzt+jbpihh90dH5cm/HN0pfRHRmFZvtnS/9dnsrFfEiMhux+2SA9oyC9qvQ2exUxB821zMbQftkgnaOkHm3ESriD5vrmW2hXbJC+3vLutcIFfFHVK5l93gT9Hu8ZNtnlIr4Iyr3yu7QoLNR0H4W+s5Dlj2eUBF/ROU2Nr9BZzNAu16hb1bLsscTKuKPqNzKZnvnz0C7N+j8ahl2eEJFLGymV24Vmc2U5Xdk2WOUilhEZDaR2Wz2t0T9ngw7jFIRi4jMyuZ6Zq+S4ffYHaL2GKEiFhGZVVTuSvY3NejsKii/QmezSFXEqMuLyKyiclezvyvit2XYYYSKWERkVlG5Huxvi/h9GXbolaaIkZd2Wq6XDL/P7hC1x520RURnVonKjsr1kuX32T0id/kkRRGjLyoqOyrXS6bfl2kXJGUR0ZmVovKjcr3Y3xf5G7Ps8YmKWETlR+V6sr8x6ndm2OEbFbGIyo/K9Zbhd2bY4RsVsYjKj8r1Zn9nxG+Nzr+jIhZR+VG5Eexv9f69kdk9wotoLyjikqLyV+fa+aPQzBkoo0Jn2SIyR6QrIjqzWtQOq3Lt3Fko46nV8z+JyBwRWkR7OVEXFLXDilw7kwnlPYFmV+gsi3feqFRFRGc8RO3BzrXzVkHZo9DcCp1l8cwapSIWUXuwc+282ZloXoPOj0JzK3SWwSvnCRWxiNqDncue19i5V+j8qBUzEa+cJ1TEImoPdi573pWdbaFvejFnfWNzVmaNUhGLqD3Yuex5lp2PoO/usOb08MwaoSIWUXuwc9nzvrFZDTrbgznrjlfOCBWxiNqDncue18NmzuSy5tzxyhmhIhZRe7Bz2fN6sXJZc+545YxQEYuoPdi57Hm9bO7TbMaMHl45I1TEImoPdi57Xi+b26Cz38x+38srZ4SKWETtwc5lzxths5/kz37fy+aszOqlIhZRe7Bz2fNGzebPfj/CM6uHilhE7cHOZc8bNZs/+/0Iz6weKmIRtQc7lz1v1Gy+/f7JjF5eOb1UxCJqD3Yue94oRj5jRg+bszKrh4pYRO3BzmXPG8XIZ8zo5Zl1R0UsovZg57LnjWLk2xlP5/TwyumhIhYRe9hMRi573ihWPmvOHa+cHipiEbHHikw7s0FnV2Dlsubc8crpoSIW3nvYPFYmmtug82ysTNacO145PVTEwnuPlXl2toW+YWFlsebc8crpoSIW3nt45dmcK3R+FiuDNeeOV04PFbHw3sMzz2Y16OwsVgZrzh2vnB4qYuG9R3TeqkxWhp0zM+sbj4xeKmLhvYd3nhfm72LO+sQjo5eKWHjv4Z3nhfm7mLM+8cjopSIW3nt453lh/i47a3Yesnr+CBWx8N7DO88L+3ex51mr549QEQvvPbzzvLB/l53HmHm1cvYoFbHw3sM7z8uK37ViZrNy9igVsfDewzvPy4rfZWey5lar5j6hIhbee9g8j0wPq36TncuavWLmUypiEbGHzfTKXWnl77GzGfPZ82aoiEXUHjbXQt9ktnp/9nz2vBkqYhG5h81G0HcZrd6bPZ89b0aqIkZdRvQONv8b9H0Wq3dlz2fPmxFaxCrDZWTc4Q6aEW31jnb+bAZz1iwVsciwA2L3stA3kTz2sxkzOaw5DCpikWGHb+x+V+h8FI/dbMZMDmsOg4pYZNihh93zE/StB689WDmsOQzpihhxIdH5I+yu36DvV/HMZ2UxZrCEF7GyF+J9KZHZT9mdM0J7szCyGDNYUhSxspfieTFRuQx29yzQrkyMPMYMljRFrOzFeF1OVO4q6Pd4QjuxMTIZM1hSFbGyl9Ogsywor0Jn3wT9ptXQHiswchkzWNIVsbIX5HFJKLNB5yUW440YM1hSFrGyl9Sgsywor0JnJRbjjRgzWNIWsbIXdYXOM3hmyXOMN2LMYEldxMpe1hU6z+CZJeNY78OYwZK+iI29tAadZfDMkjGsd2HNYXhNERt7easu0CtHxjDfhTWHYYsiVujsLK8c6cd8D+asWa8rYmUvsEFnZ3nlyD32WzBnzXplERt7kasuE+VU6KysseL+2fNmvLqIlb3MVReKcq7QN8Kz4r5XzHzq9UWs7IWuulSUY6HvZBy62yv0zagVM5/aooiVvdSVF4uyLPSd9EH3eYW+eWLV3Ce2LmKFzjKgrE/Q9/IrdHcW+u6plbNHbVPEyl5sg86yoVzhQvc+Y/X8EVsVsbEX7HXJKFfmoHtm8MzqsWURq8iLRtkyBt0rk3feHRXRAdpFMHR/bFG532xbxCrjhUusrP+JrYtYZb148Yf+CxU66+3IIlborOwL/QcadN7b9kWssl6+rIXe/Qp9E+WIIlbZH0K40HtfoW8iHVPE6g0PIvPQO1+hb6IdVcTqDY8iz9n3vULnszi+iNkfSPq9+W2PK2L11seSX9m3vELns1IRX/hop0Lv9g2akdWRRaze/Ggnse/UC83KTEV86cPtyr7LKDTzDVTEDR7xzdA7jEJz3+bYIla7Pmpm6M5HoJk7OLqI1SkP7c3e6ww0fzcqInj4Cp2Ve+guR6G5uzu+iBX6M1To7GnQvbCh3NOoiD/0B/kVuhMGlHU6FfEC/WnkOXTHgqmIBvpDyRh0r/KdimigP5aoXKupiAD6I54K3Y/wqYgiCaiIIgmoiCIJqIgiCaiIIgmoiCIJqIgiCaiIIgmoiCIJqIgiCaiIIgmoiCIJqIgiCaiIIgmoiCIJqIgiCaiIIgmoiCIJqIgiCaiIIuF+//sfG4svporZJ8MAAAAASUVORK5CYII=");
}

</style>

  <style>
/* framing defaults */
.IDE *, .IDE *::before, .IDE *::after, 
.IDE_toolbar, .IDE_toolbar *, .IDE_toolbar *::before, .IDE_toolbar *::after, 
.IDE_body, .IDE_panelcontainer, .IDE_documentcontainer {
  all:revert;
}
.IDE *, .IDE *::before, .IDE *::after, 
.IDE_toolbar, .IDE_toolbar *, .IDE_toolbar *::before, .IDE_toolbar *::after, 
.IDE_body, .IDE_panelcontainer, .IDE_panel, .IDE_documentcontainer {
  box-sizing:border-box; /*text-size-adjust:none;*/ outline:none;
}
div.IDE, .IDE div, .IDE *::before, .IDE *::after, 
div.IDE_toolbar, .IDE_toolbar div, .IDE_toolbar *::before, .IDE_toolbar *::after, 
.IDE_body, .IDE_panelcontainer, IDE_panel {
  display:block; margin:0; border:0; border-radius:0; padding:0;
}

/* control defaults */
.IDE span, .IDE button, .IDE input, .IDE select, .IDE label,
.IDE_toolbar span, .IDE_toolbar button, .IDE_toolbar input, .IDE_toolbar select, .IDE_toolbar label {
  display:inline-block; border-radius:0; vertical-align:middle;
}
.IDE label, .IDE_toolbar label, 
.IDE input[type="checkbox"], .IDE_toolbar input[type="checkbox"],
.IDE button, .IDE_toolbar button {
  cursor:pointer;
}
.IDE input[type="text"] {
  text-overflow:ellipsis;
}
.IDE *::spelling-error, .IDE_toolbar *::spelling-error {text-decoration-line:none;}

/* IDE framing */
.IDE_body {
  /*overflow-x:clip;*/ margin:0; padding:0;
  font-family:sans-serif; font-size:0.98em; color:#222; background-color:#a5a5a5;
}
.IDE_body, .IDE_toolbar, .IDE_panelcontainer {
  position:fixed; left:0; top:0; right:0; bottom:0;
}
.IDE_panelcontainer {
  position:absolute; top:27px; width:53em; max-width:100%; overflow:hidden; margin:0 auto; background-color:#fbfbfb;
  transition:top 0.5s ease-in;
}
.IDE_panelcontainer.openbar {
  top:82px;
}
@media all and (min-width:1300px) {
  .IDE_panelcontainer.openbar {top:58px;}
}
.IDE_panel {
  position:relative; width:100%; height:100%; white-space:pre-wrap; overflow:auto; /*overflow-x:clip;*/
}
@media print {
  body.IDE_body, .IDE_panelcontainer, .IDE_panel {position:static; width:100%; margin:0;}
  .IDE_panel {overflow:revert; /*overflow-x:revert;*/}
}

/* toolbar */
.IDE_toolbar, .IDE_toolbar > div {
  display:block; height:27px; width:100%; border-radius:0; font-size:0; 
}
.IDE_toolbar {
  transition:height 0.5s ease-in;
}
.IDE_toolbar.openbar {
  height:82px;
}
.IDE_toolbar > div {
  display:inline-block; background-color:#c6c6c6;
}
.IDE_toolbar > div > div {
  display:inline-block; background-color:#c6c6c6;
}
.IDE_toolbar > div > div:last-child {
  position:absolute; right:0; margin-right:0; text-align:right; padding-left:2px;
}
@media all and (min-width:1300px) {
  .IDE_toolbar.openbar {height:58px;}
}
@media print {
  .IDE_toolbar, .IDE_toolbar > div, .IDE_toolbar > div > div {display:none;}
  /*.IDE_toolbar, .IDE_toolbar > div, .IDE_toolbar > div > div, .IDE_toolbar .list.bar div {display:none;}*/
}
.IDE_toolbar span {font-size:10px;}
.IDE_toolbar span.warn {font-size:12px;}
.IDE_toolbar label {margin:0; border-radius:3px; padding:1px 9px; font-size:14px;}
.IDE_toolbar label:hover {background-color:rgba(220,160,160,0.5);}
.IDE_toolbar input[type="checkbox"] {margin-left:0; margin-right:4px; width:10px; height:10px;}
.IDE_toolbar button {
  margin:0; border:0; border-radius:0; width:36px; height:100%; background-color:transparent;
}
.IDE_toolbar .list button {
  width:auto; min-width:34px; 
  border:1px solid #999999; border-radius:4px; padding:2px 5px; 
  font-size:12px; letter-spacing:1.3px; background-color:#666; color:#ddd;
}
.IDE_toolbar .list.bar button {font-size:11px; background-color:#777; color:#e8e8e8;}
.IDE_toolbar button:hover {opacity:1.0; background-color:rgba(220,160,160,0.5);}
.IDE_toolbar .list.bar button:hover {background-color:rgba(220,160,160,0.3);}
.IDE_toolbar .list button:disabled:hover {color:#e8e8e8;}
.IDE_toolbar *:disabled, .IDE_toolbar *:disabled:hover {
  cursor:default; opacity:0.35; background-color:transparent !important;
}

/* popups */
.IDE_toolbar .popuppositioner {
  position:relative; height:27px; font-size:0; display:inline-block;
}
.IDE_toolbar .popuppositioner.fixed {position:absolute; left:0;}
.IDE_toolbar .popup {
  position:absolute; left:0; top:calc(100% + 3px); right:auto; bottom:auto;
  white-space:nowrap; text-align:left; font-size:14px; /*background-color:#eee;*/
  transition: visibility 0.5s ease-in, opacity 0.5s ease-in;
}
.IDE_toolbar .popup.right {
  right:0; left:auto;
}
.IDE_toolbar .popup.closed {visibility:hidden; opacity:0.0;}
.IDE_toolbar .popup.open {visibility:visible; opacity:1.0;}
.IDE_toolbar .popup.fullwidth {
  position:fixed; display:inline-block; top:27px; left:auto; right:0; bottom:0;
  overflow:hidden; transition:height 0.5s ease-in, visibility 0.5s ease-in;
}
.IDE_toolbar .popup.fullwidth.closed {height:0; visibility:hidden; opacity:1.0;}
.IDE_toolbar .popup.fullwidth.open {height:55px; visibility:visible; opacity:1.0;}
@media all and (min-width:1300px) {
  .IDE_toolbar .popup.fullwidth.open {height:31px;}
}
@media all and (max-width:829px) {
  .IDE_toolbar .popup.fullwidth {display:block; left:0;}
}
@media print {
  .IDE_toolbar .popuppositioner, .IDE_toolbar .popup.fullwidth {display:none;}
}
.IDE_toolbar .popup .list {
  /*border:1px solid #b8b8b8; border-top:0;*/
  background-color:#444; color:#c0c0c0;
}
.IDE_toolbar .popup .list span {
  min-width:12em; white-space:normal;
}
/*
.IDE_toolbar .popup .list.left {
  border-left:0;
}
.IDE_toolbar .popup .list.right {
  border-right:0;
}
*/
.IDE_toolbar .list.dialog, .IDE_toolbar .list.menu {
  top:12px;
  border:2px solid #999;
  border-radius:10px;
}
.IDE_toolbar .list.dialog:before, .IDE_toolbar .list.menu:before, .IDE_toolbar .list > label:first-child:before {
  content:"";
  position:absolute; top:-1px; left:16.5px;
  height:10px; width:10px;
  background-color:inherit;
  transform:rotate(45deg) translate(-50%);
  border-left:inherit; border-top:inherit;
}
.IDE_toolbar .list > label:first-child:before {
  height:10.5px; width:10.5px;
  border-left:2px solid #999; border-top:2px solid #999;
}
.IDE_toolbar .list.dialog {
  padding:0.7em 0.9em;
}
.IDE_toolbar .popup .list.bar {
  height:55px; border:0; padding:3px 8px; background-color:#808080;
}
.IDE_toolbar .list.bar div {padding:2.6px 0;}
@media all and (min-width:1300px) {
  .IDE_toolbar .popup .list.bar {height:31px;}
  .IDE_toolbar .list.bar div {display:inline-block; padding:2.6px 0;}
  .IDE_toolbar .list.bar div:first-child {padding-right:8px;}
}
.IDE_toolbar .list.dialog div {padding:0.25em 0;}
.IDE_toolbar .list.dialog div.btnbank {padding-top:0.7em;}
.IDE_toolbar .list.dialog label {margin:0; padding:0;}
.IDE_toolbar .list.dialog label:hover {background-color:#444; color:revert;}
.IDE_toolbar .list.dialog label span {padding-bottom:0.1em;}
.IDE_toolbar .list.dialog label input {display:block; padding:0; text-overflow:ellipsis; border-radius:1.6px;}
.IDE_toolbar .list > label {display:block; padding:0.5em 1.5em; border-radius:0;}
.IDE_toolbar .list > label:hover {background-color:rgba(220,180,180,0.85); color:#333;}
.IDE_toolbar .list > label:first-child {border-top-left-radius:8px; border-top-right-radius:8px;}
.IDE_toolbar .list > label:last-child {border-bottom-left-radius:8px; border-bottom-right-radius:8px;}
.IDE_toolbar button.open, .IDE_toolbar label.open, .IDE_toolbar .list > label.open {background-color:#aebeae; color:#444;}

/* controls */
.IDE_toolbar select {border:1px solid #ddd; background-color:#e4e4e4; font-size:11px;}
.IDE_toolbar input[type="text"] {
  outline:none; margin:0; border:1px solid #ddd; width:38em;
  font-family:monospace; font-size:13px; text-overflow:ellipsis; background-color:#ddd;
}
.IDE_toolbar input[type="text"].short {max-width:26em;}
.IDE_toolbar input[type="text"]:focus, input[type="text"]:hover {background-color:#fff;}
.IDE_toolbar input[type="text"]:disabled {background-color:#bbb;}
.IDE_toolbar .list.bar input[type="text"] {background-color:#eee; margin-right:0.3em;}
/*.IDE_toolbar .list.bar input[type="text"]:focus, 
.IDE_toolbar .list.bar input[type="text"]:hover {
  background-color:#fff;
}
.IDE_toolbar .list.bar input[type="text"]:disabled {background-color:rgb(230,230,230);}*/
@media all and (max-width:1299px) {
  .IDE_toolbar input[type="text"] {width:52em;}
}
@media all and (max-width:899px) {
  .IDE_toolbar input[type="text"] {width:42em;}
}
@media all and (max-width:759px) {
  .IDE_toolbar input[type="text"] {width:32em;}
}
@media all and (max-width:599px) {
  .IDE_toolbar input[type="text"] {width:22em;}
}
@media all and (max-width:459px) {
  .IDE_toolbar input[type="text"] {width:17em;}
}
@media all and (max-width:399px) {
  .IDE_toolbar input[type="text"] {width:14em;}
}
@media all and (max-width:359px) {
  .IDE_toolbar input[type="text"] {width:10em;}
}
.IDE_toolbar span.icon {
  background-repeat:no-repeat; background-size:contain; width:18px; height:18px;
}
.IDE_toolbar span.icon.small {
  width:17px; height:17px; opacity:0.9;
}
.IDE_toolbar .view_eyegaze {
content:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIEdlbmVyYXRvcjogU1ZHIFJlcG8gTWl4ZXIgVG9vbHMgLS0+DQo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJDYXBhXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIA0KCSB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA2MDAgNjAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxwYXRoIGZpbGw9IiNFN0JENzkiIGQ9Ik01MDAsNDIzLjEzOUM1MDAsNDY1LjU4Nyw0NjUuNTg3LDUwMCw0MjMuMTM4LDUwMEgxNzYuODYyQzEzNC40MTEsNTAwLDEwMCw0NjUuNTg3LDEwMCw0MjMuMTM5VjE3Ni44NjINCgkJQzEwMCwxMzQuNDEzLDEzNC40MTEsMTAwLDE3Ni44NjIsMTAwaDI0Ni4yNzVDNDY1LjU4NywxMDAsNTAwLDEzNC40MTMsNTAwLDE3Ni44NjJWNDIzLjEzOXoiLz4NCgk8cGF0aCBmaWxsPSIjREVCNDZGIiBkPSJNNTAwLDQyMy4xMzl2LTczLjc3N2wtMTI0LjM0My05Ni4wNzZMMTc5Ljg5LDMwMS4xNTRMNDEwLjg2MSw1MDBoMTIuMjc2DQoJCUM0NjUuNTg3LDUwMCw1MDAsNDY1LjU4Nyw1MDAsNDIzLjEzOXoiLz4NCgk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNNDIzLjM3OCwyOTYuNTI1Yy0wLjU1LTAuNzc3LTU1LjgyNy03Ny42NjYtMTIzLjM4LTc3LjY2NmMtNjcuNTUxLDAtMTIyLjgyOCw3Ni44ODktMTIzLjM4Niw3Ny42NzgNCgkJYy0xLjQ1NiwyLjA3MS0xLjQ1Niw0Ljg1MywwLjAwOCw2LjkzNWMwLjU1LDAuNzc4LDU1LjgyOCw3Ny42NjgsMTIzLjM3OCw3Ny42NjhjNjcuNTUzLDAsMTIyLjgzLTc2Ljg5LDEyMy4zODQtNzcuNjcyDQoJCUM0MjQuODQ4LDMwMS4zOTQsNDI0Ljg0OCwyOTguNjA1LDQyMy4zNzgsMjk2LjUyNXoiLz4NCgk8cGF0aCBmaWxsPSIjOERCM0IzIiBkPSJNMzYwLjA3MiwzMDAuMDAxYzAtMzMuMTc4LTI2Ljg5Ni02MC4wNzQtNjAuMDcyLTYwLjA3NGMtMzMuMTc4LDAtNjAuMDczLDI2Ljg5Ni02MC4wNzMsNjAuMDc0DQoJCWMwLDMzLjE3NSwyNi44OTUsNjAuMDczLDYwLjA3Myw2MC4wNzNDMzMzLjE3NywzNjAuMDc0LDM2MC4wNzIsMzMzLjE3NiwzNjAuMDcyLDMwMC4wMDF6Ii8+DQoJPGNpcmNsZSBmaWxsPSIjMjIzRTUyIiBjeD0iMzAwIiBjeT0iMzAwLjAwMSIgcj0iMjYuMTE3Ii8+DQoJPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iMzMwLjEyNSIgY3k9IjI2NC40MzkiIHI9IjEzLjgyOSIvPg0KPC9nPg0KPC9zdmc+");
}
.IDE_toolbar .view {
content:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pg0KPCEtLSBVcGxvYWRlZCB0bzogU1ZHIFJlcG8sIHd3dy5zdmdyZXBvLmNvbSwgR2VuZXJhdG9yOiBTVkcgUmVwbyBNaXhlciBUb29scyAtLT4NCjxzdmcgaGVpZ2h0PSI4MDBweCIgd2lkdGg9IjgwMHB4IiB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiANCgkgdmlld0JveD0iMCAwIDQ3My42NTQgNDczLjY1NCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Y2lyY2xlIHN0eWxlPSJmaWxsOiNFREM5MkM7IiBjeD0iMjM2LjgyNyIgY3k9IjIzNi44MjciIHI9IjIzNi44MjciLz4NCjxwYXRoIHN0eWxlPSJmaWxsOiM0QjRBNEI7IiBkPSJNNDEzLjMxMywyMjguMzk0Yy04My42MjgtMTAxLjk1Ni0xNzAuNTk2LTk3Ljc3MS0xNzQuODEtOTcuNDkxDQoJYy00LjI0NC0wLjI3Ny05MS4xODItNC40NjEtMTc0LjgxOCw5Ny40OTFjMC44NTYtMC44NTYtNS44NzEsNi44MjUtNS42MDksMTYuNDJsMCwwYzAsMCwwLDAsMCwwLjAzDQoJYy0wLjI2Miw5LjU3LDYuNDY2LDE3LjIzMiw1LjYwOSwxNi4zODNjODMuNjM2LDEwMS45NTYsMTcwLjU3Myw5Ny43NzEsMTc0LjgxOCw5Ny41MDZjNC4yMTQsMC4yNjIsOTEuMTgyLDQuNDQ2LDE3NC44MS05Ny41MDYNCgljLTAuODQ5LDAuODUzLDUuODcxLTYuODEzLDUuNjA5LTE2LjM4M2MwLTAuMDMsMC0wLjAzLDAtMC4wM2wwLDBDNDE5LjE4OCwyMzUuMjE5LDQxMi40NjgsMjI3LjU0Miw0MTMuMzEzLDIyOC4zOTR6Ii8+DQo8cGF0aCBzdHlsZT0iZmlsbDojRkZGRkZGOyIgZD0iTTM5Ni4xMTQsMjMwLjAxNGMtNzUuNDA1LTkxLjkyMi0xNTMuODEyLTg4LjE1My0xNTcuNjEyLTg3Ljg5OQ0KCWMtMy44MjYtMC4yNTEtODIuMjAzLTQuMDI0LTE1Ny42MDgsODcuODk5YzAuNzY3LTAuNzctNS4yOTUsNi4xNTUtNS4wNjMsMTQuODAxbDAsMGMwLDAsMCwwLDAsMC4wMjYNCgljLTAuMjM2LDguNjMxLDUuODMsMTUuNTM4LDUuMDYzLDE0Ljc3MWM3NS40MDUsOTEuOTIyLDE1My43ODIsODguMTQ5LDE1Ny42MDgsODcuOTE0YzMuNzk5LDAuMjM2LDgyLjIwMyw0LjAwOSwxNTcuNjA4LTg3LjkxNA0KCWMtMC43NjcsMC43NjcsNS4yOTUtNi4xNDQsNS4wNTYtMTQuNzcxYzAtMC4wMjYsMC0wLjAyNiwwLTAuMDI2bDAsMEM0MDEuNDEsMjM2LjE2NSwzOTUuMzQ4LDIyOS4yNDMsMzk2LjExNCwyMzAuMDE0eiIvPg0KPGNpcmNsZSBzdHlsZT0iZmlsbDojMUY5MkQwOyIgY3g9IjIzOS45NjgiIGN5PSIyNDUuMzkxIiByPSI4Mi4yNzEiLz4NCjxjaXJjbGUgc3R5bGU9ImZpbGw6IzM2QTVERDsiIGN4PSIyMzkuOTY4IiBjeT0iMjQ1LjM5MSIgcj0iNzQuNzkxIi8+DQo8Y2lyY2xlIHN0eWxlPSJmaWxsOiM0QjRBNEI7IiBjeD0iMjM5Ljk2OCIgY3k9IjI0NS4zOTEiIHI9IjU0LjIyNCIvPg0KPGNpcmNsZSBzdHlsZT0iZmlsbDojRkZGRkZGOyIgY3g9IjI2MS40NzEiIGN5PSIyMjIuMDE5IiByPSIyMi43OTMiLz4NCjwvc3ZnPg==");
}
.IDE_toolbar .savefile {
content:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xMiAxNkwxMiAxMSIgc3Ryb2tlPSIjMzIzMjMyIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPg0KPHBhdGggZD0iTTkuNSAxNEwxMS41IDE2VjE2QzExLjc3NjEgMTYuMjc2MSAxMi4yMjM5IDE2LjI3NjEgMTIuNSAxNlYxNkwxNC41IDE0IiBzdHJva2U9IiMzMjMyMzIiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8cGF0aCBkPSJNMTcuODI4NCA2LjgyODQzQzE4LjQwNjUgNy40MDY0OSAxOC42OTU1IDcuNjk1NTIgMTguODQ3OCA4LjA2MzA2QzE5IDguNDMwNiAxOSA4LjgzOTM1IDE5IDkuNjU2ODVMMTkgMTdDMTkgMTguODg1NiAxOSAxOS44Mjg0IDE4LjQxNDIgMjAuNDE0MkMxNy44Mjg0IDIxIDE2Ljg4NTYgMjEgMTUgMjFIOUM3LjExNDM4IDIxIDYuMTcxNTcgMjEgNS41ODU3OSAyMC40MTQyQzUgMTkuODI4NCA1IDE4Ljg4NTYgNSAxN0w1IDdDNSA1LjExNDM4IDUgNC4xNzE1NyA1LjU4NTc5IDMuNTg1NzlDNi4xNzE1NyAzIDcuMTE0MzggMyA5IDNIMTIuMzQzMUMxMy4xNjA2IDMgMTMuNTY5NCAzIDEzLjkzNjkgMy4xNTIyNEMxNC4zMDQ1IDMuMzA0NDggMTQuNTkzNSAzLjU5MzUxIDE1LjE3MTYgNC4xNzE1N0wxNy44Mjg0IDYuODI4NDNaIiBzdHJva2U9IiMzMjMyMzIiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPg0KPC9zdmc+");
}
.IDE_toolbar .openfile_black, .IDE_toolbar .openfile {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xNy44Mjg0IDYuODI4NDNDMTguNDA2NSA3LjQwNjQ5IDE4LjY5NTUgNy42OTU1MiAxOC44NDc4IDguMDYzMDZDMTkgOC40MzA2IDE5IDguODM5MzUgMTkgOS42NTY4NUwxOSAxN0MxOSAxOC44ODU2IDE5IDE5LjgyODQgMTguNDE0MiAyMC40MTQyQzE3LjgyODQgMjEgMTYuODg1NiAyMSAxNSAyMUg5QzcuMTE0MzggMjEgNi4xNzE1NyAyMSA1LjU4NTc5IDIwLjQxNDJDNSAxOS44Mjg0IDUgMTguODg1NiA1IDE3TDUgN0M1IDUuMTE0MzggNSA0LjE3MTU3IDUuNTg1NzkgMy41ODU3OUM2LjE3MTU3IDMgNy4xMTQzOCAzIDkgM0gxMi4zNDMxQzEzLjE2MDYgMyAxMy41Njk0IDMgMTMuOTM2OSAzLjE1MjI0QzE0LjMwNDUgMy4zMDQ0OCAxNC41OTM1IDMuNTkzNTEgMTUuMTcxNiA0LjE3MTU3TDE3LjgyODQgNi44Mjg0M1oiIHN0cm9rZT0iIzMyMzIzMiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8L3N2Zz4=");
}
.IDE_toolbar .openfile_white {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xNy44Mjg0IDYuODI4NDNDMTguNDA2NSA3LjQwNjQ5IDE4LjY5NTUgNy42OTU1MiAxOC44NDc4IDguMDYzMDZDMTkgOC40MzA2IDE5IDguODM5MzUgMTkgOS42NTY4NUwxOSAxN0MxOSAxOC44ODU2IDE5IDE5LjgyODQgMTguNDE0MiAyMC40MTQyQzE3LjgyODQgMjEgMTYuODg1NiAyMSAxNSAyMUg5QzcuMTE0MzggMjEgNi4xNzE1NyAyMSA1LjU4NTc5IDIwLjQxNDJDNSAxOS44Mjg0IDUgMTguODg1NiA1IDE3TDUgN0M1IDUuMTE0MzggNSA0LjE3MTU3IDUuNTg1NzkgMy41ODU3OUM2LjE3MTU3IDMgNy4xMTQzOCAzIDkgM0gxMi4zNDMxQzEzLjE2MDYgMyAxMy41Njk0IDMgMTMuOTM2OSAzLjE1MjI0QzE0LjMwNDUgMy4zMDQ0OCAxNC41OTM1IDMuNTkzNTEgMTUuMTcxNiA0LjE3MTU3TDE3LjgyODQgNi44Mjg0M1oiIHN0cm9rZT0iI2UyZTJlMiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8L3N2Zz4=");
}
.IDE_toolbar .openfileinsert_black, .IDE_toolbar .openfileinsert {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIG9wYWNpdHk9IjAuMSIgZD0iTTE3LjgyODQgNi44Mjg0M0MxOC40MDY1IDcuNDA2NDkgMTguNjk1NSA3LjY5NTUyIDE4Ljg0NzggOC4wNjMwNkMxOSA4LjQzMDYgMTkgOC44MzkzNSAxOSA5LjY1Njg1TDE5IDE3QzE5IDE4Ljg4NTYgMTkgMTkuODI4NCAxOC40MTQyIDIwLjQxNDJDMTcuODI4NCAyMSAxNi44ODU2IDIxIDE1IDIxSDlDNy4xMTQzOCAyMSA2LjE3MTU3IDIxIDUuNTg1NzkgMjAuNDE0MkM1IDE5LjgyODQgNSAxOC44ODU2IDUgMTdMNSA3QzUgNS4xMTQzOCA1IDQuMTcxNTcgNS41ODU3OSAzLjU4NTc5QzYuMTcxNTcgMyA3LjExNDM4IDMgOSAzSDEyLjM0MzFDMTMuMTYwNiAzIDEzLjU2OTQgMyAxMy45MzY5IDMuMTUyMjRDMTQuMzA0NSAzLjMwNDQ4IDE0LjU5MzUgMy41OTM1MSAxNS4xNzE2IDQuMTcxNTdMMTcuODI4NCA2LjgyODQzWiIgZmlsbD0iIzMyMzIzMiIvPg0KPHBhdGggZD0iTTE3LjgyODQgNi44Mjg0M0MxOC40MDY1IDcuNDA2NDkgMTguNjk1NSA3LjY5NTUyIDE4Ljg0NzggOC4wNjMwNkMxOSA4LjQzMDYgMTkgOC44MzkzNSAxOSA5LjY1Njg1TDE5IDE3QzE5IDE4Ljg4NTYgMTkgMTkuODI4NCAxOC40MTQyIDIwLjQxNDJDMTcuODI4NCAyMSAxNi44ODU2IDIxIDE1IDIxSDlDNy4xMTQzOCAyMSA2LjE3MTU3IDIxIDUuNTg1NzkgMjAuNDE0MkM1IDE5LjgyODQgNSAxOC44ODU2IDUgMTdMNSA3QzUgNS4xMTQzOCA1IDQuMTcxNTcgNS41ODU3OSAzLjU4NTc5QzYuMTcxNTcgMyA3LjExNDM4IDMgOSAzSDEyLjM0MzFDMTMuMTYwNiAzIDEzLjU2OTQgMyAxMy45MzY5IDMuMTUyMjRDMTQuMzA0NSAzLjMwNDQ4IDE0LjU5MzUgMy41OTM1MSAxNS4xNzE2IDQuMTcxNTdMMTcuODI4NCA2LjgyODQzWiIgc3Ryb2tlPSIjMzIzMjMyIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4NCjwvc3ZnPg==");
}
.IDE_toolbar .openfileinsert_white {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIG9wYWNpdHk9IjAuMjUiIGQ9Ik0xNy44Mjg0IDYuODI4NDNDMTguNDA2NSA3LjQwNjQ5IDE4LjY5NTUgNy42OTU1MiAxOC44NDc4IDguMDYzMDZDMTkgOC40MzA2IDE5IDguODM5MzUgMTkgOS42NTY4NUwxOSAxN0MxOSAxOC44ODU2IDE5IDE5LjgyODQgMTguNDE0MiAyMC40MTQyQzE3LjgyODQgMjEgMTYuODg1NiAyMSAxNSAyMUg5QzcuMTE0MzggMjEgNi4xNzE1NyAyMSA1LjU4NTc5IDIwLjQxNDJDNSAxOS44Mjg0IDUgMTguODg1NiA1IDE3TDUgN0M1IDUuMTE0MzggNSA0LjE3MTU3IDUuNTg1NzkgMy41ODU3OUM2LjE3MTU3IDMgNy4xMTQzOCAzIDkgM0gxMi4zNDMxQzEzLjE2MDYgMyAxMy41Njk0IDMgMTMuOTM2OSAzLjE1MjI0QzE0LjMwNDUgMy4zMDQ0OCAxNC41OTM1IDMuNTkzNTEgMTUuMTcxNiA0LjE3MTU3TDE3LjgyODQgNi44Mjg0M1oiIGZpbGw9IiNlMmUyZTIiLz4NCjxwYXRoIGQ9Ik0xNy44Mjg0IDYuODI4NDNDMTguNDA2NSA3LjQwNjQ5IDE4LjY5NTUgNy42OTU1MiAxOC44NDc4IDguMDYzMDZDMTkgOC40MzA2IDE5IDguODM5MzUgMTkgOS42NTY4NUwxOSAxN0MxOSAxOC44ODU2IDE5IDE5LjgyODQgMTguNDE0MiAyMC40MTQyQzE3LjgyODQgMjEgMTYuODg1NiAyMSAxNSAyMUg5QzcuMTE0MzggMjEgNi4xNzE1NyAyMSA1LjU4NTc5IDIwLjQxNDJDNSAxOS44Mjg0IDUgMTguODg1NiA1IDE3TDUgN0M1IDUuMTE0MzggNSA0LjE3MTU3IDUuNTg1NzkgMy41ODU3OUM2LjE3MTU3IDMgNy4xMTQzOCAzIDkgM0gxMi4zNDMxQzEzLjE2MDYgMyAxMy41Njk0IDMgMTMuOTM2OSAzLjE1MjI0QzE0LjMwNDUgMy4zMDQ0OCAxNC41OTM1IDMuNTkzNTEgMTUuMTcxNiA0LjE3MTU3TDE3LjgyODQgNi44Mjg0M1oiIHN0cm9rZT0iI2UyZTJlMiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8L3N2Zz4=");
}
.IDE_toolbar .undo {
position:relative; top:1.5px;
background-image:url("data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNCAxMS4zNjU3NjUyYy40OTkxNzA1Ni0uNjUzODMyMSAxLjE1MDcxMjAxLTEuNDkxNzQ0MTggMS41NzA4MTczOC0xLjk1MjgzNTQ0IDEuOTYzMjE0NDctMi4xNTQ3NDc1OSA0LjE5MDY2MjktMy40MTI5Mjk3NiA2LjkyOTE4MjYyLTMuNDEyOTI5NzYgNi4zODk2NTE5IDAgOS41IDQuNDEyMjIyNCA5LjUgMTBoLTJjMC00LjYwMjgxNC0yLjM5NDgwOTMtOC03LjUtOC0yLjA5MTE1NTYgMC0zLjgzMjI0OTc3Ljk4MzQ2MzIxLTUuNDUwNzg5OTUgMi43NTk5MDk3LS40MjI4MDc0MS40NjQwNTctMS4yMjg3MzAyMSAxLjUyMjUyOTctMS43ODA3Njc5MyAyLjI0MDA5MDNoNS43MzE1NTc4OHYyaC05di05aDJ6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=");
}
.IDE_toolbar .redo {
position:relative; top:1.5px;
background-image:url("data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMjAgMTEuMzY1NzY1MnYtNS4zNjU3NjUyaDJ2OWgtOXYtMmg1LjczMTU1NzljLS41NTIwMzc3LS43MTc1NjA2LTEuMzU3OTYwNS0xLjc3NjAzMzMtMS43ODA3NjgtMi4yNDAwOTAzLTEuNjE4NTQwMS0xLjc3NjQ0NjQ5LTMuMzU5NjM0My0yLjc1OTkwOTctNS40NTA3ODk5LTIuNzU5OTA5Ny01LjEwNTE5MDczIDAtNy41IDMuMzk3MTg2LTcuNSA4aC0yYzAtNS41ODc3Nzc2IDMuMTEwMzQ4MTQtMTAgOS41LTEwIDIuNzM4NTE5NyAwIDQuOTY1OTY4MiAxLjI1ODE4MjE3IDYuOTI5MTgyNiAzLjQxMjkyOTc2LjQyMDEwNTQuNDYxMDkxMjYgMS4wNzE2NDY4IDEuMjk5MDAzMzQgMS41NzA4MTc0IDEuOTUyODM1NDR6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=");
}
.IDE_toolbar .search {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyMCAyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBmaWxsPSJub25lIj4NCiAgPHBhdGggZmlsbD0iIzAwMDAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNCA5YTUgNSAwIDExMTAgMEE1IDUgMCAwMTQgOXptNS03YTcgNyAwIDEwNC4yIDEyLjYuOTk5Ljk5OSAwIDAwLjA5My4xMDdsMyAzYTEgMSAwIDAwMS40MTQtMS40MTRsLTMtM2EuOTk5Ljk5OSAwIDAwLS4xMDctLjA5M0E3IDcgMCAwMDkgMnoiLz4NCjwvc3ZnPg==");
}

/* code/plaintext editor markup defaults */
mark.IDE, .IDE mark {border-radius:0; background-color:transparent;}
mark.IDE.L, .IDE mark.L {border-top-left-radius:0.25em; border-bottom-left-radius:0.25em;}
mark.IDE.R, .IDE mark.R {border-top-right-radius:0.25em; border-bottom-right-radius:0.25em;}

/* code/plaintext editor document framing */
mark.IDE_documentcontainer, mark.IDE_documentbody {
  display:inline-block; margin:0; border-radius:0; word-break:break-word;
}
mark.IDE_documentcontainer {padding:0; background-color:#f2f2f2;}
mark.IDE_documentbody {
  margin-left:1.3em; padding:1em; background-color:white;
}
/* code/plaintext editor code block containers */
.IDE_codeblockcontainer, .IDE_codeblock {border-radius:0;}
.IDE_codeblockcontainer {
  display:inline-block; position:unset; background-color:white;
}
.IDE_codeblock {
  display:inline-block; margin-left:0;
  font-family:monospace; background-color:white; color:#111;
}
/* block (line) counter for code and plaintext editors */
.IDE_block.L {counter-increment:block;}
.IDE_block.L:before {
  content:counter(block); pointer-events:none;
  position:absolute; left:0; margin-top:0.35em; width:2.85em; text-align:center;
  font-family:sans-serif; font-size:45%; color:#777;
}

/* highlights */
.IDE_comment.html {font-family:'courier new'; font-size:0.87em; color:blue;}
.IDE_comment.js {font-family:monospace; font-style:italic; color:#061;}
.IDE a {font-family:sans-serif; font-size:95%;}
.IDE_paragraph .IDE_quoted::spelling-error {text-decoration-line:none;}
.IDE_quoted {font-style:italic;}
.IDE_quoted.double {font-family:'courier new'; font-size:0.87em;}
.IDE_quoted.single {font-family:monospace; font-size:100%; font-weight:bold; color:#559;}
.IDE_codeblock .IDE_quoted.single {font-weight:normal; color:#333;}
.IDE_codeblock .IDE_tag, .IDE_codeblock .IDE_keyword {font-weight:bold;}
.IDE_codeblock .IDE_quoted {color:#000;}
.IDE_codeblock .IDE_tag, .IDE a {color:#559;}
.IDE_codeblock .IDE_tag.html {color:#a55;}
.IDE_codeblock .IDE_keyword {color:#a55;}
.IDE a:visited {color:#684878;}
.IDE_regex, .IDE_number {font-family:'courier new'; font-size:0.87em; font-weight:bold; font-style:normal;}
.IDE_regex {color:#888;}
.IDE_number {color:#72a;}
.IDE_regex .IDE_regexslashed {color:#d00;}
.IDE_regex .IDE_regexpattern {/*background-color:#f8f4ec;*/ color:#333;}

/* remove undesirable nested highlights */
.IDE_heading .IDE_number,
.IDE_comment *, 
.IDE_codeblock .IDE_comment *, 
.IDE_comment .IDE_regex *, 
.IDE_codeblock .IDE_comment .IDE_regex *, 
.IDE_codeblock .IDE_comment .IDE_quoted,
.IDE_quoted *, 
.IDE_codeblock .IDE_quoted *, 
.IDE_tag *, 
.IDE_codeblock .IDE_tag *, 
.IDE_codeblock .IDE_tag .IDE_quoted,
.IDE_regex .IDE_regexpattern *, 
.IDE_regex .IDE_comment, 
.IDE_regex .IDE_quoted, 
.IDE_codeblock .IDE_regex .IDE_quoted, 
.IDE_tag .IDE_number {
  font-family:inherit; font-size:inherit; font-style:inherit; font-weight:inherit; color:inherit;
}
.IDE_codeblock .IDE_quoted, .IDE_codeblock .IDE_tag .IDE_quoted {font-style:italic;}
.IDE_codeblock .IDE_regex .IDE_quoted {font-style:inherit;}

/* search highlights */
.search-match, .IDE .search-match {background-color:#f4ecd8 !important; color:inherit;}
@keyframes replacedflash {
    0% {background-color:rgba(164,200,164,0.6);}
   30% {background-color:transparent;}
   60% {background-color:rgba(164,200,164,0.6);}
   90% {background-color:transparent;}
}
.search-replaced, .IDE .search-replaced {
  background-color:transparent; animation-name:replacedflash; animation-delay:0.0s; animation-duration:0.7s;
}
.search-match .search-current, .IDE .search-match .search-current {
  background-color:rgba(230,190,190,0.99); color:inherit;
}
@keyframes currentflash {
    0% {background-color:rgba(230,190,190,0.99);}
   50% {background-color:transparent;}
  100% {background-color:rgba(230,190,190,0.99);}
}
.search-match .search-current.search-currentflash, .IDE .search-match .search-current.search-currentflash {
  animation-name:currentflash; animation-delay:0.0s; animation-duration:0.7s;
}
@keyframes currentblink {
    0% {background-color:rgba(230,190,190,0.99);}
   25% {background-color:transparent;}
   50% {background-color:rgba(230,190,190,0.99);}
   75% {background-color:transparent;}
  100% {background-color:rgba(230,190,190,0.99);}
}
.search-match .search-current.search-currentblink, .IDE .search-match .search-current.search-currentblink {
  animation-name:currentblink; animation-delay:0.0s; animation-duration:1.0s;
}

/* selection (when not focused) highlight */
.texteditor-selected, .IDE .texteditor-selected {
  background-color:rgba(210,210,225,0.5) !important; color:inherit;
}
mark.texteditor-selected.L, mark.texteditor-selected.R {border-radius:0 !important;}
  </style>

  <!--script type="text/javascript" src="lib/stylotron.js"/script-->
  <script>
/*
 * stylotron.js
 *
 *   SOT.text.map:        low level text parser, builds segmented range maps from a series of overlapping regex matches
 *   SOT.PatternSeries:   abstraction of a pattern series, produces SOT.text.maps and layered html
 *
 *   single step markup:  html = SOT.markup( text, patterndefs )
 *
 * stylotron-demo.html provides tutorial and example of use
 *
 * cc0 (public domain) v.010 September 2025, latest version @ github.com/gregsidal
 */

const SOT = {};

/*
 *  html = SOT.markup( text, patterndefs )
 *    marks up matches of of a pattern series, returns html
 *
 *    patterndefs = {def...}
 *      each def is one of these:
 *        'class': regex or string
 *          matches of each regex (or string) are styled with 'class'
 *        'class': {'regex': .., ..opts..}
 *        'class': {'range': {'start': .., 'end': ..}, ..opts..}
 *      opts can include:
 *        htmltag: ..
 *        htmlattrs: {...}
 *
 *  strings can be full regex's like "/.+/g" (a string without slashes in the right places is a literal)
 *  regex's must include 'g' flag or pattern is ignored ('g' is added to regex strings if needed)
 *
 *  matches that overlap/cover others are segmented and marked up in layers, see SOT.map.markup comments
 *  ranges are overlaid (applied last) by default, use opts={overlayranges:false} to apply ranges in order
 *    (the logic for the default is that ranges are usually types of selections, which are typically overlaid)
 *
 *  'htmlattrs' are added to starting tag: htmltag='a', htmlattrs={href:'A',target='B'} produces "<a href='A' target='B'>"
 *    attr strings can include '$_&' replacement wildcard, where $_& == matched text
 *    attr can also be a regex, in which case attr is whatever the regex extracts from matched text
 */
SOT.markup = function( text, defs, opts, callback ) {
  const patterns = new SOT.PatternSeries();
  patterns.add( defs );
  if (callback)
    patterns.setmarkupcallback( callback );
  return patterns.markup( text, undefined, opts );
}

/*
 *  SOT.PatternSeries
 *    registers regex's and ranges with associated CSS classes; produces SOT.text.maps and layered markup
 *
 *    patterns = new SOT.PatternSeries()
 *
 *    patterns.addregex( regex, cls )
 *      adds a regex (or string), matches will be styled with with CSS class 'cls'
 *      (strings can be literals or regex's including slashes and flags, ie "/.+/g")
 *    patterns.addrange( range, cls )
 *      adds a range
 *    patterns.add( defs )
 *      adds one or more defs, refer to SOT.map.markup comments
 *
 *    map = patterns.buildmap( text, map=[], overlayranges=true )
 *      builds a SOT.text.map of 'text'
 *        ('map' can be fed to SOT.map.markup to produce the HTML)
 *      ranges are applied last by default, use overlayranges=false to apply ranges in order
 *    HTML = patterns.markup( text )
 *      marks up defs, see SOT.map.markup
 *
 *    prevcallback = patterns.setmarkupcallback( callback )
 *      see SOT.map.markup for callback spec
 *      callback replaces any other previously set
 */
SOT.PatternSeries = function() {
  var defs = {};
  this.requiredregexflags = 'g';
  this.get = function( cls ) {
    return defs[cls];
  }
  this.addregexstr = function( regexstr, cls, reqflags=this.requiredregexflags, defin, alertiferror ) {
    var regex;
    try {
      //regex = new RegExp( regexstr, flags );
      regex = SOT.text.regexstr2regex( regexstr, reqflags );
    }
    catch( e ) {
      if (alertiferror)
        alert( e );
      return null;
    }
    if (defin)
      defs[cls] = defin;
    else
      defs[cls] = {};
    defs[cls].regexstr = regexstr, defs[cls].regex = regex;
    return regex;
  }
  this.addregex = function( regex, cls, reqflags ) {
    if (regex)
      if (typeof regex == 'string')
        this.addregexstr( regex, cls, reqflags );
      else
        defs[cls] = {'regex':regex};
  }
  this.addrange = function( range, cls ) {
    if (!defs[cls] || defs[cls].range.start != range.start || defs[cls].range.end != range.end) {
      defs[cls] = {'range': range};
      return true;
    }
  }
  this.add = function( defsin ) {
    for( var cls in defsin )
      if (defsin[cls])
        if (typeof defsin[cls] == 'string' || defsin[cls] instanceof RegExp)
          this.addregex( defsin[cls], cls );
        else
          if (defsin[cls].regex && typeof defsin[cls].regex == 'string')
            this.addregexstr( defsin[cls].regex, cls, this.requiredregexflags, defsin[cls] );
          else
            defs[cls] = defsin[cls];
  }
  this.del = function( cls ) {
    if (defs[cls]) {
      delete defs[cls];
      return true;
    }
  }
  this.delregexs = function() {
    var m = {};
    for( var cls in defs )
      if (!defs[cls].regex)
        m[cls] = defs[cls];
    defs = m;
  }
  this.delranges = function() {
    var m = {};
    for( var cls in defs )
      if (!defs[cls].range)
        m[cls] = defs[cls];
    defs = m;
  }
  this.clear = function() {
    defs = {};
  }
  this.buildmatchesmap = function( text, map=[] ) {
    for( var cls in defs  )
      if (defs[cls].regex)
        map = SOT.text.map.addmatches( text, defs[cls].regex, cls, true, map );
    return map;
  }
  this.buildrangesmap = function( text, map=[] ) {
    for( var cls in defs )
      if (defs[cls].range)
        map = SOT.text.map.addrange( text, defs[cls].range, cls, true, map );
    return map;
  }
  this.buildmap = function( text, map=[], overlayranges=true ) {
    if (overlayranges) {
      map = this.buildmatchesmap( text, map );
      map = this.buildrangesmap( text, map );
    }
    else {
      for( var cls in defs )
        if (defs[cls].regex)
          map = SOT.text.map.addmatches( text, defs[cls].regex, cls, true, map );
        else
          if (defs[cls].range)
            map = SOT.text.map.addrange( text, defs[cls].range, cls, true, map );
    }
    return map;
  }
  var markupcallback;
  this.setmarkupcallback = function( callback ) {
    var prev = markupcallback ? markupcallback : function(attrs){return attrs;};
    markupcallback = callback;
    return prev;
  }
  this.markupmap = function( text, map, opts ) {
    return SOT.map.markup( text, map, opts, defs, markupcallback );
  }
  this.markup = function( text, map=[], opts={overlayranges:true} ) {
    return SOT.map.markup( text, this.buildmap(text,map,opts.overlayranges), opts, defs, markupcallback );
  }
}

/*
 *  HTML = SOT.map.markup( text, map, opts, callback )
 *    generates layered html from a SOT.text.map
 *    (a SOT.PatternSeries object can be used to set regex/class associations and create the map)
 *
 *  The set names in the map (see SOT.text.map) are the CSS class names used in the mark up
 *
 *  Segments (intersections of overlapping ranges, see SOT.text.map) are marked up in layers
 *
 *  A segment's CSS class list indicates what part of the original range the segment was synthesized from:
 *    a leftmost segment includes "L" and a rightmost segment includes "R"
 *    a middle segment includes neither "L" nor "R"
 *    an unsegmented range includes both "L" and "R"
 *
 *  Examples:
 *
 *    a range of 'cls1' covers another of 'cls0', will be marked up as follows:
 *
 *      <mark class="cls0 L R">
 *        Some
 *        <mark class="cls1 L R">text</mark>
 *        is here
 *      </mark>
 *
 *    the order the patterns are applied is important, if 'cls1' is background:
 *
 *      <mark class="cls0 L">Some </mark>
 *      <mark class="cls1 L R">
 *        <mark class="cls0">text</mark>
 *      </mark>
 *      <mark class="cls0 R"> is here</mark>
 *
 *  'opts': {'htmltag': ..}
 *    if provided, 'htmltag' will be used instead of "mark" globally
 *      (tags can also be specified per-class in 'defs', see SOT.markup comments)
 *
 *  'callback': attrs = function( params )
 *    optional, will be fired on each tag, params:
 *      'attrs': passed in will be {'class': .., ...}, example: {'class': "cls1 L  "}
 *      'class': the class name
 *      'map': the text map
 *      'mapindex': index in 'map' array
 *      'layerindex': index in 'origs' subarray (see SOT.text.map)
 *      'opts': passed in opts
 *    callback can modify and/or add to 'attrs'
 */
SOT.map = {
  markup: function( fulltext, map, opts, defs, callback ) {
    function _tag( layer, end ) {
      var tag = 'mark';
      if (opts && opts.htmltag)
        tag = opts.htmltag;
      if (defs)
        if (end && defs[layer.setname].htmltagend != undefined)
          tag = defs[layer.setname].htmltagend;
        else
          if (defs[layer.setname].htmltag)
            tag = defs[layer.setname].htmltag;
      return tag;
    }
    function _addattrs( attrs, addattrs, origrange ) {
      for( const a in addattrs )
        if (addattrs[a] instanceof RegExp)
          attrs[a] = SOT.text.extract( fulltext.slice(origrange.start,origrange.end), addattrs[a] );
        else
          if (typeof addattrs[a] == 'string')
            attrs[a] = addattrs[a].replace( "$_&", fulltext.slice(origrange.start,origrange.end) );
      return attrs;
    }
    function _istagdif( seg, compareseg, layerindex ) {
      return (!compareseg || layerindex >= compareseg.origs.length || 
              seg.origs[layerindex].setname != compareseg.origs[layerindex].setname ||
              seg.origs[layerindex].range.setindex != compareseg.origs[layerindex].range.setindex);
    }
    function _difdepth( seg, compareseg ) {
      for( var depth=0; depth<seg.origs.length; depth++ )
        if (_istagdif( seg, compareseg, depth ))
          break;
      return depth;
    }
    /*
     * 
     */
    function _tagstart( seg, layer, mapindex, j, pieceindex, offset, insidetext ) {
      var tag = _tag(layer), t = "";
      /* build class attribute */
      var attrs = {'class': layer.setname};
      if (layer.range.start == seg.start)
        attrs['class'] += " L";
      if (defs && defs[layer.setname].htmlattrs)
        attrs = _addattrs( attrs, defs[layer.setname].htmlattrs, layer.range );
      /* get dynamic attributes if any */
      if (callback)
        attrs = callback( {'attrs':attrs,
                           class:layer.setname,
                           'map':map,
                           'mapindex':mapindex,
                           layerindex:j, 
                           'opts':opts} );
      /* markup html tag with attrs */
      t += "<" + tag;
      for( var a in attrs ) {
        t += " " + a + (attrs[a] ? ('="' + attrs[a]) : '');
        if (a == 'class') {
          t += "  ";
          starts[layer.setname] = {pos: offset+t.length-1, 'pieceindex': pieceindex, 'j': j, 'seg': seg};
        }
        t += attrs[a] ? '"' : '';
      }
      return t + ">";
    }
    function _layersstart( prevseg, seg, mapindex, pieceindex, insidetext ) {
      var j =_difdepth( seg, prevseg );
      for( var tags=""; j<seg.origs.length; j++ )
        tags += _tagstart( seg.range, seg.origs[j], mapindex, j, pieceindex, tags.length, insidetext );
      return {'tags':tags, 'insidetext':insidetext};
    }
    /*
     * 
     */
    function _tagend( layer ) {
      const tag = _tag( layer, true );
      if (!tag)
        return "";
      return "</" + SOT.text.extractto(tag, /^[A-Za-z0-9-_]+/) + ">";
    }
    function _layersend( seg, nextseg ) {
      var j =_difdepth( seg, nextseg );
      for( var t="",k=seg.origs.length-1; k>=j; k-- )
        t += _tagend( seg.origs[k] );
      return {tags:t};
    }
    function _setlayerright( seg ) {
      var piece = "";
      for( const layer of seg.origs ) {
        if (starts[layer.setname] && layer.range.end == seg.range.end) {
          /* (insert 'R' in class list) */
          piece = html[starts[layer.setname].pieceindex];
          piece = piece.slice( 0, starts[layer.setname].pos ) +
                  "R" +
                  piece.slice( starts[layer.setname].pos+1 );
          html[starts[layer.setname].pieceindex] = piece;
          delete starts[layer.setname];
        }
      }
    }
    const html = [];
    function htmladd( piece ) {
      if (piece)
        html.push( piece );
    }
    function htmlstring() {
      var hs = "";
      for( const piece of html )
        hs += piece;
      return hs;
    }
    var text = "", start = {}, end = {}, starts = {};
    var prevseg, seg, nextseg;
    for( var i=0,n=0; i<map.length; prevseg=seg,i++ ) {
      seg = map[i];
      htmladd( SOT.text.raw2HTML(fulltext.slice(n, seg.range.start)) );
      nextseg = i < map.length-1 ? map[i+1] : null;
      start = _layersstart( prevseg, seg, i, text ? html.length+1 : html.length, 
                            SOT.text.raw2HTML(fulltext.slice(seg.range.start,seg.range.end)) );
      if (start.tags) {
        htmladd( text ), text = "";
        htmladd( start.tags );
        htmladd( start.insidetext );
      }
      else
        text += start.insidetext;
      end = _layersend( seg, nextseg );
      if (end.tags) {
        if (text)
          htmladd( text + end.tags ), text = "";
        else
          htmladd( end.tags );
        _setlayerright( seg );
      }
      n = seg.range.end;
    }
    return htmlstring() + SOT.text.raw2HTML( fulltext.slice(n) );
  }
}

/*
 *  Text helpers
 */
SOT.text = {
  str2regex: function( regexstr, flags='' ) {
    regexstr = regexstr.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' );
    return new RegExp( regexstr, flags );
  },
  parseregexstr: function( str, reqflags='' ) {
    const regexparts = {pattern: SOT.text.extract( str, /(?<=^\/).+(?=\/\w*$)/ )};
    if (regexparts.pattern) {
      regexparts.flags = SOT.text.extract( str, /(?<=^\/.+\/)\w*$/ );
      if (!regexparts.flags)
        regexparts.flags = reqflags;
      else
        if (!SOT.text.extract( regexparts.flags, SOT.text.str2regex(reqflags) ))
          regexparts.flags += reqflags;
    }
    return regexparts;
  },
  regexstr2regex: function( str, reqflags='' ) {
    const regexparts = SOT.text.parseregexstr( str, reqflags );
    var regex;
    if (regexparts.pattern)
      regex = new RegExp( regexparts.pattern, regexparts.flags );
    else
      regex = SOT.text.str2regex( str, reqflags );
    return regex;
  },
  raw2HTML: function( text ) {
    var newtext = text.replace( /&/g, "&amp;" );
    newtext = newtext.replace( />/g, "&gt;" );
    return newtext.replace( /</g, "&lt;" );
  },
  startswith: function( s, sub ) {
    return s && sub && s.substring( 0, sub.length ) == sub;
  },
  extract: function( s, substr ) {
    const x = s.match( substr );
    if (x && x[0] !== null)
      return x[0];
    return null;
  },
  extractto: function( s, sub ) {
    s = s.match( sub );
    return s[0];
  },
  /* replace range */
  paste: function( text, range, replacewith ) {
    var newtext = text.slice( 0, range.start );
    var token = text.substring( range.start, range.end );
    //newtext += token.replace( SOT.text.str2regex(token,''), replacewith );
    newtext += token.replace( token, replacewith );
    newtext += text.slice( range.end );
    return newtext;
  }
}

/*
 *  SOT.text.map
 *    builds segmented range maps from series of regex matches
 *
 *    map = SOT.text.map.addmatches( text, regex, setname, segment?, map=[] )
 *      adds set of ranges matching regex to map
 *
 *    map = SOT.text.map.addrange( text, range, setname, segment?, map=[] )
 *      adds a range to map
 *
 *  Maps are ordered arrays, each element has the form {range:{start:., end:.}, origs:[...]}
 *
 *  Maps are flat, 'segment?' determines how ranges that overlap or cover others are treated when being added:
 *    !: range being added will overwrite any it overlaps or covers (usurped ranges are discarded)
 *    else: overlapping or covered ranges are segmented
 *
 *  The 'origs' array specifies what range(s) a segment was synthesized from:
 *    each element of 'origs' has the form: {setname:"..", range:{start:.,end:.}}
 *      example: intersection segment resulting from a range of "set0" overlapping one of "set1": 
 *               origs = [{setname:"set0", range:..}, {name:"set1", range:..}]
 *    for unsegmented ranges, origs = [{setname:<samename>, range:<samerange>}
 *
 *  Replace operations:
 *
 *    text = SOT.text.map.replace( text, map, i, newtext )
 *      replaces range i in text with newtext
 *
 *    text = SOT.text.map.replaceall( text, map, i, replacewiths )
 *      replaces all ranges, replacewiths = {setname:"new text", ...}
 *      segment's setname determines the replacement text to use (replacewiths[segment.origs[0].setname])
 *
 *   Segmented ranges are ignored during replacements (replace ops on segments are nonsensical)
 */
SOT.text.map = {
  range: {
    neworigs: function( setname, range={start:0,end:0,setindex:0} ) {
      if (typeof setname == 'string')
        return [{'setname':setname, 'range':{start:range.start,end:range.end,'setindex':range.setindex}}];
      return set;
    },
    mk: function( start, end, origs ) {
      return {range:{'start':start, 'end':end}, 'origs':origs};
    },
    copy: function( r ) {
      return {range:{start:r.start, end:r.end}, origs:r.origs};
    },
    isposin: function( pos, map, i ) {
      return (i >= 0 && i < map.length && pos >= map[i].range.start && pos <= map[i].range.end);
    },
    next: function( pos, map ) {
      var i = -1, test = 0;
      if (map.length) {
        if (map[0].range.end > pos)
          i = 0;
        else {
          i = map.length - 1;
          if (pos < map[i].range.start) {
            var j = map.length/2;
            for( i=j;
                 Math.round(j);
                 j/=2, map[Math.round(i)].range.end<=pos ? i+=j : i-=j, test++ ) //(bin search)
              ;
            i = Math.round( i );
          }
        }
        //console.log( "BINSEARCH 0: " + test );
        for( ; i < map.length && map[i].range.end <= pos; i++, test++ )
          ;
        //console.log( "BINSEARCH 1: " + test );
      }
      return i;
    },
    before: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (i >= 0 && SOT.text.map.range.isposin( pos, map, i ))
        i++;
      return i >= 0 ? Math.max(0,i-1) : i;
    },
    after: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (SOT.text.map.range.isposin( pos, map, i ))
        i++;
      return i;
    },
    nearest: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      i = Math.min( i, map.length-1 );
      if (i > 0 && !SOT.text.map.range.isposin( pos, map, i )) {
        if (pos < ((map[i].range.start - map[i-1].range.end) / 2) + map[i-1].range.end)
          i--;
      }
      return i;
    },
    atpos: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (!SOT.text.map.range.isposin( pos, map, i ))
        i = -1;
     return i;
    }
  },
  /*
   * segmentation loop illustration (_segment):
   *
   *    is0----ie0  is1--ie1        is2----ie2   target sequence, first ie > ms
   *        ms--------------------------me       input (range to add)
   * *
   *    continues while isN < me
   *
   *    is0----ie0
   *        ms--------------------------me
   *    is0-ms-ie0                               segments = [mins,maxs,mine]
   *           ie0----------------------me       next input = [mine,maxe]
   *
   *                is1--ie1
   *           ms-----------------------me
   *           ms---is1--ie1                     segments = [mins,maxs,mine]
   *                     ie1------------me       next input = [mine,maxe]
   *
   *                                is2----ie2
   *                     ms-------------me
   *                     ms---------is2-me       segments = [mins,maxs,mine]
   *                                    me-ie2   next input = [mine,maxe]
   *
   *                                    ms--me   last (dangling) segment
   */
  _seg2: function( m, i, p ) {
    var r = {start:Math.min(m.range.start, i.range.start), end:Math.max(m.range.start, i.range.start)};
    if (r.start < r.end)
      p.newmap.push( SOT.text.map.range.mk(r.start,r.end,r.start<i.range.start?m.origs:i.origs) );
    r = {start:Math.max(m.range.start, i.range.start), end:Math.min(m.range.end, i.range.end)};
    p.newmap.push( SOT.text.map.range.mk(r.start,r.end,[...i.origs,...m.origs]) );
    r = {start:Math.min(m.range.end, i.range.end), end:Math.max(m.range.end, i.range.end)};
    return SOT.text.map.range.mk( r.start, r.end, r.start<m.range.end?m.origs:i.origs );
  },
  _segment: function( start, end, origs, map=[], p ) {
    var m = SOT.text.map.range.mk( start, end, origs );
    if (p.newmap.length && m.range.start < p.newmap[p.newmap.length-1].range.end) {
      /* (edge case: when ranges are added in sequence (regex matches), newmap may contain an iceberg segment) */
      var i = p.newmap.pop();
      m = SOT.text.map._seg2( m, i, p );
    }
    for( ; p.i<map.length && map[p.i].range.start<m.range.end; p.i++ )
      m = SOT.text.map._seg2( m, map[p.i], p );
    if (m.range.start < m.range.end)
      p.newmap.push( m );
    return p;
  },
  /* insert range at current location; discard ranges it overlaps or covers */
  _overwrite: function( start, end, origs, map=[], p ) {
    p.newmap.push( SOT.text.map.range.mk(start,end,origs) );
    for( ; p.i < map.length && map[p.i].range.end <= end; p.i++ )
      ;
    if (p.i < map.length && map[p.i].range.start < end)
      p.i++;
    return p;
  },
  /* insert a range into map; overwrite or segment overlapping/covered ranges */
  _insertrange: function( start, end, set, map, segment, p={newmap:[],i:0,setindex:0} ) {
    for( ; p.i < map.length && map[p.i].range.end <= start; p.i++ )  // add all before entries
      p.newmap.push( map[p.i] );
    var origs = SOT.text.map.range.neworigs( set, {'start':start,'end':end,'setindex':p.setindex} );
    if (segment)
      p = SOT.text.map._segment( start, end, origs, map, p );
    else
      p = SOT.text.map._overwrite( start, end, origs, map, p );
    return p;
  },
  /* add trailing ranges */
  _addendranges: function( map=[], p ) {
    for( ; p.i<map.length; p.i++ )
      p.newmap.push( map[p.i] );
    return p.newmap;
  },
  /* add ranges from regex match to map */
  addmatches: function( text, regex, setname, segment, map=[], alertiferror ) {
    var p = {newmap:[],i:0,setindex:0};
    var matches;
    try {
      matches = text.matchAll( regex );
    }
    catch( e ) {
      if (alertiferror)
        alert( e );
      return map;
    }
    /* (optimization: matches are added in a single pass) */
    for( const match of matches ) {
      p = SOT.text.map._insertrange( match.index, match.index+match[0].length, setname, map, segment, p );
      p.setindex++;
    }
    return SOT.text.map._addendranges( map, p );
  },
  /* add ranges from regex match to map */
  _X_addmatches: function( text, regex, setname, segment, map=[] ) {
    var p = {newmap:[],i:0,setindex:0};
    /* (optimization: matches are added in a single pass) */
    var match;
    while( match = regex.exec(text) )
      if (match[0].length) {
        p = SOT.text.map._insertrange( match.index, match.index+match[0].length, setname, map, segment, p );
        p.setindex++;
      }
      else {
        regex.lastIndex++;
  //console.log( regex );
      }
    return SOT.text.map._addendranges( map, p );
  },
  /* add a range to map */
  addrange: function( text, range, setname, segment, map=[] ) {
    if (range.start > range.end)
      range = {start:range.end, end:range.start};
    var p = SOT.text.map._insertrange( range.start, range.end, setname, map, segment );
    return SOT.text.map._addendranges( map, p );
  },
  /* replace all ranges, replacewiths={setname:"..", ...} */
  replaceall: function( text, map, replacewiths ) {
    if (!map.length)
      return text;
    var newtext = "", token;
    for( var i=0,n=0; i<map.length; i++ ) {
      newtext += text.slice( n, map[i].range.start );
      token = text.substring( map[i].range.start, map[i].range.end );
      if (map[i].origs.length == 1 &&
          map[i].origs[0].range.start == map[i].range.start && map[i].origs[0].range.end == map[i].range.end)
        //newtext += token.replace( SOT.text.str2regex(token,''), replacewiths[map[i].origs[0].setname] );
        newtext += token.replace( token, replacewiths[map[i].origs[0].setname] );
      else
        newtext += token;
      n = map[i].range.end;
    }
    newtext += text.slice( n );
    return newtext;
  },
  /* replace a range */
  replace: function( text, map, i, newtext ) {
    if (i >= map.length)
      return text;
    var replacewiths = {};
    replacewiths[map[i].origs[0].setname] = newtext;
    return SOT.text.map.replaceall( text, [map[i]], replacewiths );
  }
}
  </script>

  <!--script type="text/javascript" src="lib/texteditor.js"/script-->
  <script>
/*
 * texteditor.js
 *
 *   UI.TextEditor:          controller for editable content
 *   UI.texteditor.UndoRedo: undo/redo attachment for a text editor
 *   UI.texteditor.Search:   basic (notepad-like) search/replace attachment
 *   UI.FontPicker:          font picker
 *   TextFileIO:             open and save files
 *
 *   single step init:       editor = UI.texteditor.createinit( elemid, opts={} )
 *
 * texteditor.html provides example of use
 *
 * cc0 (public domain) v.010 September 2025, latest version @ github.com/gregsidal
 */
const UI = {};

UI.texteditor = UI.texteditor ? UI.texteditor : {
  createinit: function( elemid, opts ) {
    const editor = new UI.texteditor.Components( elemid, opts );
    editor.get('texteditor').initrefresh();
    return editor;
  }
};

/*
 * Create a texteditor with optional undoredo, basic search, and/or fontpicker attachments
 *
 * To initialize with all attachments using default opts:
 *   components = new UI.texteditor.Components( editablecontentelemid, opts={undoredo:{},basicsearch:{},fontpicker:{}} )
 *
 * To get a component:
 *   component = components.get( componentname='texteditor' )
 */
UI.texteditor.Components = function( texteditorid, opts={} ) {
  var components = {};
  /* setup text editor */
  components.texteditor = new UI.TextEditor();
  components.texteditor.init( texteditorid, opts.texteditor );
  /* attach undo/redo component if opted for */
  if (opts.undoredo) {
    components.undoredo = new UI.texteditor.UndoRedo();
    components.undoredo.init( components.texteditor, opts.undoredo );
  }
  /* attach fontpicker if opted for */
  if (opts.fontpicker) {
    function onfontselected( name ) {
      components.texteditor.setfont( name );
    }
    components.fontpicker = new UI.FontPicker();
    components.fontpicker.init( onfontselected, opts.fontpicker );
  }
  /* attach basic search if opted for */
  if (opts.basicsearch) {
    components.basicsearch = new UI.texteditor.Search();
    components.basicsearch.init( components.texteditor, opts.basicsearch );
  }
  this.add = function( componentname, component ) {components[componentname] = component; return component;}
  this.get = function( componentname='texteditor' ) {return components[componentname];}
  this.rem = function( componentname ) {delete components[componentname];}
}


/*
 * Text editor UI control
 *   uses a callback to dynamically mark up text as its edited
 *
 * To initialize:
 *   texteditor = new UI.TextEditor()
 *   texteditor.init( elemorid )
 *   texteditor.setcallback( 'remarkup', remarkupcallback );
 *   texteditor.initrefresh()  // (ingest and markup the initial text in the element)
 *
 * 'elemorid' (div most likely) will be given "contenteditable='plaintext-only'" property.
 *
 * Functionality is designed to minimize remarkups
 *
 * Callbacks:
 *
 *   HTML = remarkup( plaintext, e2 )
 *     callback is fired when refreshing,
 *     should mark up 'plaintext' and return the HTML
 *
 *   refresh? = statechanged( e2 )
 *     callback is fired from any event or API call that changes text or moves caret
 *       (text changes can also move the caret, but the callback is fired only once)
 *     if callback returns true, remarkup will take place
 *       (the default callback returns true when 'e2.textchanged' is true)
 *
 *   beforetextchange( e2 )
 *     triggered just before text changes (fired by 'beforeinput' event and also API calls that change text) 
 *
 *   to set a callback: prevcallback = texteditor.setcallback( 'callback', f )
 *     (callbacks override others previously set; callbacks should save and call 'prevcallback')
 *
 *   the UndoRedo component below provides examples of callback use
 *
 * Callbacks and most API functions work with an 'e2' parameter, which can include:
 *   action: string indicating what's happening
 *   event: browser event if any
 *   textchanged?: true when text has changed
 *   selrange: selected range or caret position
 *   prevselrange: previous selection range
 *
 * All positions, including selection start/end, are absolute in plaintext
 *
 * texteditor.el()
 *   get text editor HTML element
 *
 * texteditor.setfont( fn )
 *   set font
 *
 * texteditor.zoom( incr = 1 )
 *   zoom in or out (-1)
 *
 * texteditor.wrap( w )
 *   set wrap mode
 *
 * texteditor.put( text, e2={action:"insertFromPut"}, selrange={0,0} )
 *   replace entire text (resets caret/selected range to selrange)
 *
 * texteditor.insert( pastetext, e2={action:"insertFromInsert"}, range=selection, select=true )
 *   insert text into specified or selected range, select insertion when select == true
 *
 * texteditor.getselrange( normalize )
 *   get selected range or caret position
 *   selection range has directionality, i.e., end may be before start; 'normalize' forces start <= end
 *
 * texteditor.setselrange( r, e2={action:'selchangeFromReset'} )
 *   set selected range or caret position (when start == end)
 *
 * texteditor.setcaretpos( pos=-1, e2={action:'selchangeFromReset'} )
 *   set caret position, resets to last position when -1
 *
 * texteditor.focusto( e2={action:"focusTo"}, selrange=this.getselrange() )
 *   focus and set caret position/selected range
 *
 * texteditor.refresh( e2={action:'refresh'} )
 *   remarkup, does not fire state change callback
 *
 * texteditor.scrollelemintoview( el, opts )
 *   scroll to a marked up element in innerHTML
 */
UI.texteditor.defaultopts = {
  ids: {
    wraptoggle: 'texteditor-wraptoggle',
    zoominbtn:  'texteditor-zoominbtn',
    zoomoutbtn: 'texteditor-zoomoutbtn'
  }
};
UI.TextEditor = function() {
  /* init */
  this.init = function( texteditorid, opts ) {
    function defaultstatechangecallback( e2 ) {
      return e2.textchanged;
    }
    function defaultremarkupcallback( plaintext, e2 ) {
      return UI.h.text2html( plaintext );
    }
    _i.textarea = UI.h.el( texteditorid );
    this.setproperty( 'contentEditable', "plaintext-only", "true" );
    this.setcallback( 'beforetextchange' );
    this.setcallback( 'statechanged', defaultstatechangecallback );
    this.setcallback( 'remarkup', defaultremarkupcallback );
    _i.textarea.addEventListener( "scroll", _i.onscroll );
    _i.textarea.addEventListener( "focus", _i.onfocus, {passive:false} );
    _i.textarea.addEventListener( "blur", _i.onblur );
    document.addEventListener( "selectionchange", _i.onselect );
    _i.textarea.addEventListener( "beforeinput", _i.onbeforeinput );
    _i.textarea.addEventListener( "input", _i.oninput );
    _i.textarea.addEventListener( "click", _i.onclick );
    this.changed( false );
    this.initctls( opts );
  }
  this.initctls = function( opts=UI.texteditor.defaultopts ) {
    _i.ids = opts.ids ? opts.ids : UI.texteditor.defaultopts.ids;
    UI.h.defocusize( [_i.ids.wraptoggle, _i.ids.zoominbtn, _i.ids.zoomoutbtn] );
    UI.h.listen( _i.ids.wraptoggle, "click", _i.wrap );
    UI.h.listen( _i.ids.zoominbtn, "click", _i.zoomin );
    UI.h.listen( _i.ids.zoomoutbtn, "click", _i.zoomout );
    var initialwrap = true;
    if (UI.h.el( _i.ids.wraptoggle ))
      initialwrap = UI.h.el(_i.ids.wraptoggle).checked;
    this.wrap( initialwrap );
    _i.resetctls();
  }
  /* set a textarea element property */
  this.setproperty = function( attrname, attrvalue, alertonerror ) {
    UI.h.setproperty( _i.textarea, attrname, attrvalue, alertonerror );
  }
  /* set properties for plain (code) editor vs spell-checking editor */
  this.seteditproperties = function( plain, alertonerror ) {
    UI.h.seteditproperties( _i.textarea, plain, alertonerror );
  }
  /* set a callback */
  this.setcallback = function( cbn, cb ) {
    function __f(){};
    const pcb = _i.callbacks[cbn];
    _i.callbacks[cbn] = cb ? cb : __f;
    return pcb;
  }
  /* get editor HTML element; get plaintext of element */
  this.el = this.tel = function() {return _i.textarea;}
  this.get = function() {return _i.textarea.innerText;}
  this.changed = function( setto ) {
    if (setto != undefined)
      _i.changed = setto;
    return _i.changed;
  }
  /* get whether editor is focused */
  this.isfocused = function() {return _i.focused;}
  /* set font */
  this.setfont = function( fn ) {
    _i.textarea.style['font-family'] = fn;
  }
  /* zoom in or out */
  this.zoom = function( incr = 1 ) {
    _i.zoom( incr );
  }
  /* get or set wrap mode */
  this.wrap = function( w ) {
    if (w == undefined)
      return _i.textarea.style['white-space'] == 'pre-wrap';
    _i.wrap( null, w );
    if (UI.h.el( _i.ids.wraptoggle ))
      UI.h.el( _i.ids.wraptoggle ).checked = w;
    return w;
  }
  /* replace text */
  this.put = function( newtext, e2={action:"insertFromPut"}, selrange={start:0,end:0} ) {
    _i.textwillchg( e2 );
    var text = this.get();
    _i.textarea.innerText = newtext;
    _i.textchg( e2, selrange );
    if (selrange.end == 0)
      _i.textarea.scrollLeft = 0, _i.textarea.scrollTop = 0;
    return selrange;
  }
  /* insert text into range (paste) */
  this.insert = function( pastetext, e2={action:"insertFromInsert"}, range, select=true ) {
    _i.textwillchg( e2 );
    var text = this.get();
    range = range ? range : this.getselrange( true );
    var len = text.length;
    text = text.substring(0,range.start) + pastetext + text.substring(range.end);
    range = {start:range.start, end:range.end + (text.length - len)};
    _i.textarea.innerText = text;
    e2.insertedrange = range;
    _i.textchg( e2, select ? range : {start:range.end, end:range.end} );
    return range;
  }
  /* get sel range or caret pos (caret pos is always selrange.end, end may be before start) */
  this.getselrange = function( normalize ) {return _i.getselrange(normalize);}
  this.getcaretpos = function() {return _i.getcaretpos();}
  /* set caret/selection (may fire 'onstatechange' callback) */
  this.setselrange = function( r, e2={action:'selchangeFromReset'} ) {
    return _i.resetselrange( e2, r );
  }
  /* set caret (may cause 'onstatechange' callback to be fired) */
  this.setcaretpos = function( pos=-1, e2 ) {
    pos = pos < 0 ? this.getcaretpos() : pos;
    return this.setselrange( {start:pos, end:pos}, e2 );
  }
  /* raw remarkup (does not fire state change) */
  this.refresh = function( e2={action:'refresh'} ) {
    _i.remarkup( e2 );
  }
  /* full re-markup (fires state change callback) */
  this.textchanged = function( e2={action:"textChanged"} ) {
    _i.textchg( e2 );
  }
  /* full markup of text in textarea HTML (fires callback) */
  this.initrefresh = function() {
    this.textchanged( {action:"insertFromInit"} );
  }
  /* get scroll position */
  this.getscrollpos = function() {
    return {left:_i.textarea.scrollLeft, top:_i.textarea.scrollTop};
  }
  /* scroll to a scroll position */
  this.scrollto = function( scrollpos={left:0,top:0}, opts ) {
    UI.h.scrolltopos( _i.textarea, scrollpos.left, scrollpos.top, opts );
  }
  /* scroll to an marked up element */
  this.scrollelemintoview = function( el, opts ) {
    UI.h.scrollelemintoview( _i.textarea, el, opts );
  }
  /* scroll to a marked up element cluster */
  this.scrollelemsintoview = function( els, opts ) {
    UI.h.scrollelemsintoview( _i.textarea, els, opts );
  }
  /* focus and set caret/selection */
  this.focusto = function( e2={action:"focusTo"}, selrange=this.getselrange() ) {
    _i.focused = true;
    if (!_i.resetselrange( e2, selrange ))
      _i.hardsetselrange();
    _i.textarea.focus();
  }
  /* internals */
  var _i = {
    resetctls: function() {
    },
    wrap: function( e, w ) {
      const curw = _i.textarea.style['white-space'] == 'pre-wrap';
      if (w == undefined)
        w = !curw;
      if (w != curw)
        _i.textarea.style['white-space'] = w ? 'pre-wrap' : 'pre';
    },
    zoom: function( incr = 1 ) {
      UI.h.zoom( incr, _i.textarea );
    },
    zoomin: function( e ) {
      _i.zoom( 1 );
    },
    zoomout: function( e ) {
      _i.zoom( -1 );
    },
    keepselection: true,
    textarea: null,
    callbacks: {},
    selrange: {start:0, end:0}, prevselrange: {start:0, end:0},
    getselrange: function( normalize ) {
      var r = {start:_i.selrange.start, end:_i.selrange.end};
      if (normalize)
        r = r.end < r.start ? {start:r.end, end:r.start} : r;
      return r;
    },
    getcaretpos: function() {
      return _i.getselrange().end;
    },
    getabsselrange: function() {
      var r = UI.h.getabsselrange( _i.textarea );
      if (!r)
        r = _i.selrange;
      return r;
    },
    snapselrange: function() {
      _i.selrange = _i.getabsselrange( _i.textarea );
      _i.conlog( {f:"snapselrange", start:_i.selrange.start, end:_i.selrange.end}, 1 );
      return _i.selrange;
    },
    hardsetselrange: function() {
      if (_i.focused) {
        UI.h.setabsselrange( _i.selrange, _i.textarea );
        _i.conlog( {f:"hardsetselrange", start:_i.selrange.start, end:_i.selrange.end}, 4 );
      }
    },
    resetselrange: function( e2={action:'selchangeFromReset'}, r ) {
      e2.prevselrange = {start: _i.selrange.start, end: _i.selrange.end};
      if (!r)
        r = _i.snapselrange();
      _i.selrange = {start:r.start, end:r.end};
      e2.selrange = r;
      e2.focused = _i.focused;
      var refreshed = _i.callbacks.statechanged( e2 );
      if (refreshed)
        _i.remarkup( e2 );
      _i.conlog( {f:"resetselrange", 'e2':e2, 'refreshed':refreshed}, 3 );
      return refreshed;
    },
    scroll: {left:0, top:0},
    onscroll: function() {
      _i.conlog( {f:"onscroll"}, 1 );
      _i.scroll = {left:_i.textarea.scrollLeft, top:_i.textarea.scrollTop};
    },
    onfocus: function( e ) {
      var r = UI.h.getabsselrange( _i.textarea );
      _i.conlog( {f:"onfocus", 'start':r?r.start:'undef', 'end':r?r.end:'undef', 'e':e}, 4 );
      /* (the assumption is that if the user has scrolled that's what they wanted to do) */
      _i.textarea.scrollLeft = _i.scroll.left, _i.textarea.scrollTop = _i.scroll.top;
    },
    onblur: function() {
      _i.conlog( {f:"onblur"}, 1 );
      _i.focused = false;
      _i.resetselrange( {action:'blur'} );
    },
    onselect: function( e ) {
      var r = UI.h.getabsselrange( _i.textarea );
      if (r) {
        var restoresel, e2 = {action:'selchangeFromSelect', event:e};
        _i.conlog( {f:"onselect", 'start':r.start, 'end':r.end, 'e':e}, 6 );
        if (!_i.focused && r.start == r.end) {
          e2.action = 'selchangeFromFocus';
          const selr = _i.getselrange( true );
          /* restore prev selection if user is focusing by tapping in that selected range */
          /* restore prev caret/selection if it looks like a focus is idiotically forcing a reset to top */
          if (r.end == 0 || (selr.start < selr.end && r.start >= selr.start && r.end <= selr.end)) {
            r = _i.getselrange();
            _i.conlog( {f:"-- RESTORE SEL", 'start':_i.selrange.start, 'end':_i.selrange.end}, 6 );
            restoresel = true;
          }
        }
        const pr = _i.getselrange();
        if (!_i.focused || r.start != pr.start || r.end != pr.end) {
          _i.focused = true;
          if (!_i.resetselrange( e2, r ))
            if (restoresel)
              _i.hardsetselrange();
        }
      }
    },
    onbeforeinput: function( e ) {
      _i.conlog( {f:"onbeforeinput"}, 1 );
      _i.textwillchg( {action:e.inputType, inputType:e.inputType, event:e} );
    },
    oninput: function( e ) {
      _i.conlog( {f:"oninput"}, 1 );
      _i.textchg( {action:e.inputType, inputType:e.inputType, event:e} );
    },
    onclick: function( e ) {
      //_i.conlog( {f:"onclick", 'e':e}, 6 );
      //if (!_i.focused)
        //_i.clicked = true;
      //_i.hardsetselrange();
    },
    textwillchg: function( e2 ) {
      e2.inputType = e2.inputType ? e2.inputType : e2.action;
      return _i.callbacks.beforetextchange( e2 );
    },
    textchg: function( e2={action:"selchangeFromInput"}, r ) {
      _i.changed = true;
      e2.textchanged = true;
      return _i.resetselrange( e2, r );
    },
    remarkup: function( e2 ) {
      _i.conlog( {f:"remarkup", 'action':e2.action, 'e2':e2}, 4 );
      _i.conlog( {f:"remarkup 1", innerText:_i.textarea.innerText}, 3 );
      if (_i.callbacks.remarkup)
        _i.textarea.innerHTML = _i.callbacks.remarkup( _i.textarea.innerText, e2 );
      _i.hardsetselrange();
      _i.conlog( {f:"remarkup 2", innerText:_i.textarea.innerText, innerHTML:_i.textarea.innerHTML}, 3 );
    },
    conmsg: false,
    conmsggroup: 6,
    conlog: function( msg, group ) {
      if (_i.conmsg && _i.conmsggroup == group) console.log( msg );
    }
  }
}

/*
 *  Undo/redo attachment for TextEditor
 *
 *  To set up:
 *    undoredo = new UI.texteditor.UndoRedo();
 *    undoredo.init( texteditor, opts=UI.texteditor.undoredo.defaultopts );
 *
 *  The controls in 'ids' trigger the undo and redo operations when clicked
 */
UI.texteditor.undoredo = {
  defaultopts: {
    ids: {
      undobtn:  'undoredo-undobtn',
      redobtn:  'undoredo-redobtn'
    },
    lockctls: true
  }
}
UI.texteditor.UndoRedo = function() {
  this.init = function( texteditor, opts=UI.texteditor.undoredo.defaultopts ) {
    _i.texteditor = texteditor;
    _i.ids = opts.ids ? opts.ids : UI.texteditor.undoredo.defaultopts.ids;
    _i.prevbeforechangecallback = _i.texteditor.setcallback( 'beforetextchange', _i.onbeforeinput );
    _i.prevchangecallback = _i.texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    UI.h.defocusize( [_i.ids.undobtn, _i.ids.redobtn] );
    this.lockctls( opts.lockctls );
  }
  this.lockctls = function( lock=true ) {
    if (lock) {
      UI.h.listen( _i.ids.undobtn, "click", _i.undo );
      UI.h.listen( _i.ids.redobtn, "click", _i.redo );
      _i.resetctls();
    }
    else {
      UI.h.ignore( _i.ids.undobtn, "click", _i.undo );
      UI.h.ignore( _i.ids.redobtn, "click", _i.redo );
    }
  }
  this.undo = function() {
    _i.undo();
  }
  this.redo = function() {
    _i.redo();
  }
  this.clear = function() {
    _i.clear();
  }
  this.reset = function() {
    _i.resetctls();
  }
  // internals
  var _i = {
    texteditor: null, ids: {},
    resetctls: function() {
      var states = {canundo: _i.undolog.length,
                    canredo: _i.redolog.length};
      UI.h.enable( _i.ids.undobtn, states.canundo );
      UI.h.enable( _i.ids.redobtn, states.canredo );
    },
    clear: function() {
      _i.undolog = [], _i.redolog = [], _i.mark = false;
      _i.previnputtype = "", _i.wasblank = true;
      _i.resetctls();
    },
    undolog:[], redolog:[],
    log: function( log, text, selrange=_i.texteditor.getselrange(), 
                   wrap=_i.texteditor.wrap(), scrollpos=_i.texteditor.getscrollpos() ) {
      log.push( {'text':text, 'selrange':selrange, 'wrap':wrap, 'scrollpos':scrollpos} );
    },
    unlog: function( log, e2 ) {
      const le = log.pop();
      _i.texteditor.put( le.text, e2, le.selrange );
      _i.texteditor.wrap( le.wrap );
      _i.texteditor.scrollto( le.scrollpos );
    },
    willchange: function( action ) {
      const t = _i.texteditor.get();
      if (t) {
        _i.redolog = [];
        _i.log( _i.undolog, t );
        _i.mark = true;
      }
    },
    haschanged: function() {
      const t = _i.texteditor.get();
      if (_i.mark && t) {  // (remove trailing line feeds)
        var len = t.length;
        for( var i=t.length-1; i>=0; i-- )
          if (t[i] == '\n' || t[i] == ' ')
            len--;
          else
            break;
        if (len < t.length) {
          var t2 = t.slice( 0, len );
          if (t2 == _i.undolog[_i.undolog.length-1])
            _i.undolog.length--;
        }
      }
      _i.mark = false;
      _i.resetctls();
    },
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      if (e2.group && e2.group.more)
        return refresh;
      if (e2.textchanged) {
        if (e2.action != "insertFromUndo" && e2.action != "insertFromRedo")
          _i.haschanged();
        _i.previnputtype = e2.action;
        _i.resetctls();
      }
      return refresh;
    },
    undo: function() {
      if (!_i.undolog.length)
        return alert( "No edit history" );
      _i.log( _i.redolog, _i.texteditor.get() ); 
      _i.unlog( _i.undolog, {action:"insertFromUndo"} );
    },
    redo: function() {
      if (!_i.redolog.length)
        return alert( "No undo history" );
      _i.log( _i.undolog, _i.texteditor.get() );
      _i.unlog( _i.redolog, {action:"insertFromRedo"} );
    },
    previnputtype: "", wasblank: true,
    onbeforeinput: function( e ) {
      const ret = _i.prevbeforechangecallback( e );
      if (e.inputType == "insertFromUndo" || e.inputType == "insertFromRedo")
        return;
      if (e.group && !e.group.start)
        return;
      //console.log( 'beforeinput previnputtype: ' + _i.previnputtype );
      //console.log( 'beforeinput inputtype: ' + e.inputType );
      //if (e.inputType == "insertLineBreak")
        //return;
      //console.log( "oninput, e=", e );
      function startswith( s, sub ) {
        return s && sub && s.substring( 0, sub.length ) == sub;
      }
      if (startswith( e.inputType, "insertFrom" ) || startswith( _i.previnputtype, "insertFrom" )) 
        _i.willchange( e.inputType );
      else {
        var pt = _i.previnputtype;
        var t = e.inputType;
        const ins = "insert";
        if (startswith( t, "delete" ))
          t = ins;
        if (startswith( pt, "delete" ))
          pt = ins;
        if (t.substring( 0, ins.length ) != pt.substring( 0, ins.length ))
          _i.willchange( e.inputType );
      }
      return ret;
    }
  }
}

/*
 *  Basic (notepad-like) search/replace attachment for a TextEditor
 *
 *  To set up:
 *    search = new UI.texteditor.Search();
 *    search.init( texteditor, ids=UI.search.defaultids );
 *
 *  The controls in 'ids' trigger the search/replace functions
 */
UI.texteditor.search = {
  defaultopts: {
    ids: {
      find:           'search-find',        //input
      findbtn:        'search-findbtn',
      nextbtn:        'search-nextbtn',
      replace:        'search-replace',     //input
      replacebtn:     'search-replacebtn',
      replaceallbtn:  'search-replaceallbtn'
    },
    classes: {
      current:        'search-current'
    },
    regexflags:       'g'
  }
};
UI.texteditor.Search = function() {
  this.init = function( texteditor, opts = UI.texteditor.search.defaultopts ) {
    _i.texteditor = texteditor;
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    _i.prevremarkupcallback = texteditor.setcallback( 'remarkup', _i.onremarkup );
    _i.ids = opts.ids ? opts.ids : UI.texteditor.search.defaultopts.ids;
    _i.classes = opts.classes ? opts.classes : UI.texteditor.search.defaultopts.classes;
    _i.regexflags = opts.regexflags ? opts.regexflags : UI.texteditor.search.defaultopts.regexflags;
    //UI.h.defocusize( [_i.ids.findbtn, _i.ids.nextbtn, _i.ids.replacebtn, _i.ids.replaceallbtn] );
    UI.h.listen( _i.ids.findbtn, "click", _i._find );
    UI.h.listen( _i.ids.nextbtn, "click", _i._next );
    UI.h.listen( _i.ids.replacebtn, "click", _i.replace );
    UI.h.listen( _i.ids.replaceallbtn, "click", _i.replaceall );
    UI.h.seteditproperties( _i.ids.find, true );
    UI.h.seteditproperties( _i.ids.replace, true );
    UI.h.listen( _i.ids.find, "input", _i.clear );
    _i.resetctls();
  }
  this.clear = function() {
    _i.clear( null );
  }
  this.find = function( verbose=true ) {
    _i.find( verbose );
  }
  this.next = function( start, verbose ) {
    _i.next( start, verbose );
  }
  this.scrollcurrentintoview = function( opts ) {
    _i.scrollcurrentintoview( opts );
  }
  this.replace = function() {
    return _i.replace();
  }
  // internals
  var _i = {
    texteditor: null,
    action: function( e, t ) {
      return e && e.action && e.action.substring( 0, t.length ) == t;
    },
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      if (e2.action == 'selchangeFromFocus')
        refresh = true;
      else
        if (!e2.focused)
          if (e2.selrange.start != e2.selrange.end || e2.prevselrange.start != e2.prevselrange.end)
            refresh = true;
      _i.resetctls();
      return refresh;
    },
    onremarkup: function( plaintext, e2 ) {
      var html;
      const sr = _i.texteditor.getselrange( true );
      if (sr.start != sr.end && !e2.focused) {
        html = UI.h.text2html( plaintext.substring(0,sr.start) ) + 
               "<mark class='" + _i.classes.current + "'>" + 
               UI.h.text2html( plaintext.substring(sr.start,sr.end) ) +
               "</mark>" + 
               UI.h.text2html( plaintext.substring(sr.end) );
      }
      else
        html = _i.prevremarkupcallback( plaintext, e2 );
      return html;
    },
    resetctls: function() {
      const cantfind = !UI.h.get( _i.ids.find );
      const sr = _i.texteditor.getselrange();
      const end = sr.end >= (_i.texteditor.get().length-1);
      const cantreplace = sr.start == sr.end;
      UI.h.el( _i.ids.findbtn ).disabled = cantfind;
      UI.h.el( _i.ids.nextbtn ).disabled = cantfind || end;
      UI.h.el( _i.ids.replacebtn ).disabled = cantreplace;
      UI.h.el( _i.ids.replaceallbtn ).disabled = cantreplace;
    },
    clear: function( e ) {
      _i.resetctls();
    },
    nextrange: function( start=-1, text=_i.texteditor.get() ) {
      const regexstr = UI.h.get( _i.ids.find );
      start = start >= 0 ? start : _i.texteditor.getselrange( true ).end;
      const matches = text.matchAll( new RegExp(regexstr,_i.regexflags) );
      var r;
      for( const match of matches ) {
        if (match.index >= start) {
          r = {start:match.index, end:match.index+match[0].length};
          break;
        }
      }
      return r;
    },
    next: function( e2={action:'selchangeFromNext'}, start=_i.texteditor.getselrange(true).end, verbose=true ) {
      var r = _i.nextrange( start );
      if (!r)
        r = {start:_i.texteditor.get().length, end:_i.texteditor.get().length};
      _i.texteditor.setselrange( r, e2 );
      _i.scrollcurrentintoview();
      return r;
    },
    _next: function( e ) {
      return _i.next();
    },
    find: function( verbose=true ) {
      const r = _i.next( {action:'selchangeFromFind'}, 0, verbose );
    },
    _find: function( e ) {
      _i.find();
    },
    scrollmarkintoview: function( cls, opts ) {
      const els = _i.texteditor.el().getElementsByClassName( cls );
      if (els && els.length)
        _i.texteditor.scrollelemintoview( els[0], opts );
    },
    scrollcurrentintoview: function( opts ) {
      _i.scrollmarkintoview( _i.classes.current, opts );
    },
    str2regex: function( regexstr, flags='' ) {
      regexstr = regexstr.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' );
      return new RegExp( regexstr, flags );
    },
    pastetext: function( text, range, replacewith ) {
      var newtext = text.slice( 0, range.start );
      var token = text.substring( range.start, range.end );
      //newtext += token.replace( str2regex(token,''), replacewith );
      newtext += token.replace( token, replacewith );
      newtext += text.slice( range.end );
      return newtext;
    },
    _replace: function( group ) {
      var sr = _i.texteditor.getselrange( true );
      if (sr.start == sr.end) {
        //alert( "No selection" );
        if (group)
          group.more = false;
      }
      else {
        var e2 = {action:'insertFromReplace'};
        var text = _i.texteditor.get();
        var len = text.length;
        text = _i.pastetext( text, sr, UI.h.get(_i.ids.replace) );
        sr = {start:sr.start, end:sr.end + (text.length - len)};
        var newpos = sr.end;
        sr = _i.nextrange( newpos, text );
        if (group) {
          group.more = sr;
          e2.group = group;
        }
        _i.texteditor.put( text, e2, {start:newpos, end:newpos} );
        newpos = sr ? newpos : text.length;
        _i.next( e2, newpos );
      }
      return group;
    },
    replace: function() {
      return _i._replace();
    },
    replaceall: function() {
      function repl1() {
        group = _i._replace( group );
        group.start = false;
        if (group.more)
          setTimeout( repl1, 250 );
      }
      var group = {start:true};
      repl1();
    }
  }
}

/*
 *  Font picker
 *
 *  To set up:
 *    fontpicker = new UI.FontPicker();
 *    search.init( onselectcallback, ids=UI.fontpicker.defaultids, 
 *                 classes=UI.fontpicker.defaultclasses, fallbacks=UI.fontpicker.fallbacks );
 *
 *  onselectcallback( fontname )
 *
 *  The controls in 'ids' handle selections, etc.
 */
UI.fontpicker = {
  defaultopts: {
    ids: {
      list:                      'fontpicker-list',      //div
      fontname:                  'fontpicker-fontname',  //input
      addbtn:                    'fontpicker-addbtn',
      msg:                       'fontpicker-msg'
    },
    classes: {
      'item-container':          'fontpicker-item-container',         //div
      'item-container-selected': 'fontpicker-item-container-selected',
      item:                      'fontpicker-item'                    //div
    },
    fallbacks: [
            {fullName:"Monospace", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Arial", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Courier New", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Agency FB", postscriptName:"", family:"", style:"serif"},
            {fullName:"Book Antiqua", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Calibri", postscriptName:"", family:"", style:"sans-erif"}, 
            {fullName:"Cambria", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Comic Sans MS", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Consolas", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Franklin Gothic", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Garamond", postscriptName:"", family:"", style:"serif"},
            {fullName:"Impact", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Lucida Sans", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Lucida Handwriting", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Lucida Calligraphy", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Lucida Console", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Mistral", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Palatino Linotype", postscriptName:"", family:"", style:"serif"},
            {fullName:"Papyrus", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Segoe UI", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Tahoma", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Times New Roman", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Verdana", postscriptName:"", family:"", style:"sans-serif"}
    ]
  },
  _onselect: function( listid, fontname ) {UI.fontpicker[listid].select( fontname );}
}
UI.FontPicker = function() {
  this.init = function( onselectcallback, opts=UI.fontpicker.defaultopts ) {
    _i.selectcallback = onselectcallback;
    _i.ids = opts.ids ? opts.ids : UI.fontpicker.defaultopts.ids;
    _i.classes = opts.classes ? opts.classes : UI.fontpicker.defaultopts.classes;
    _i.fallbacks = opts.fallbacks ? opts.fallbacks : UI.fontpicker.defaultopts.fallbacks;
    UI.fontpicker[_i.ids.list] = this;
    UI.h.listen( _i.ids.addbtn, "click", _i.add );
    UI.h.seteditproperties( _i.ids.fontname, true );
    UI.h.listen( _i.ids.fontname, "input", _i.fontnameinput );
    _i.fontnameinput();
  }
  this.populatelist = async function() {
    return _i.populatelist();
  },
  this.add = function() {
    return _i.add();
  }
  this.select = function( fontname ) {
    _i.selectcallback( fontname );
    if (_i.selectedid)
      UI.h.class.rem( _i.selectedid, _i.classes['item-container-selected'] );
    _i.selectedid = fontname;
    UI.h.class.add( _i.selectedid, _i.classes['item-container-selected'] );
  }
  // internals
  var _i = {
    selectedid: null,
    fontnameinput: function() {
      UI.h.el(_i.ids.addbtn).disabled = !UI.h.el(_i.ids.fontname).value;
    },
    add: function() {
      //var fn = prompt( "Name of font to add:", "" );
      const fn = UI.h.el(_i.ids.fontname).value;
      if (fn && !({fullName:fn} in _i.fallbacks)) {
        var tmp = [{fullName:fn}];
        for( const fd of _i.fallbacks )
          tmp.push( fd );
        _i.fallbacks = tmp;
        _i.populatelist();
        UI.h.el(_i.ids.list).firstElementChild.scrollIntoView( {behavior: "smooth"} );
      }
    },
    populatelist: async function() {
      var availfonts;
      try {
        availfonts = await window.queryLocalFonts();
        //test availfonts = _i.fallbacks;
        UI.h.el(_i.ids.addbtn).innerHTML = "";
        UI.h.el(_i.ids.msg).innerHTML = "";
      }
      catch( e ) {
        /*if (!_i.listalerted)
          alert( "Web browser does not support font query API, " + 
                 "so some common fonts will be shown.  Fonts not available on device will render with system defaults." );*/
        _i.listalerted = true;
        availfonts = _i.fallbacks;
      }
      var html = "", name, attrs;
      for( var fd of availfonts ) {
        name = fd.fullName ? fd.fullName : (fd.family ? fd.family : fd.style);
        html += UI.h.markuphtml( 'div', { 
             'class':   _i.classes['item-container'] + (_i.selected == name ? " "+_i.classes['item-container-selected'] : ""),
             'id':      name,
             'style':   "font-family:" + name,
             'onclick': "UI.fontpicker._onselect(" + "'" + _i.ids.list + "','" + name + "'" + ")"
            },
            UI.h.markuphtml( 'div', {'class':_i.classes.item}, fd.showName?fd.showName:name) );
      }
      UI.h.el(_i.ids.list).innerHTML = html;
    }
  }
}

/*
 * File open/save/etc.
 */
var TextFileIO = {
  /* make data url */
  __lastobjurl: null,
  todataurl: function( mimetype, content ) {
    if (TextFileIO.__lastobjurl)
      URL.revokeObjectURL( TextFileIO.__lastobjurl );
    var b = new Blob( [content], {type:mimetype} );
    TextFileIO.__lastobjurl = URL.createObjectURL( b );
    return TextFileIO.__lastobjurl;
  },
  /* save content to a file by activating a <href href=".." download=".."> control */
  savedataurl: function( id, fn, mimetype, content ) {
    var e = UI.h.el( id );
    e.download = fn;
    e.href = TextFileIO.todataurl( mimetype, content );
    e.click();
  },
  /* save a text file using a <href href=".." download=".."> control */
  save: function( id, fn, content ) {
    TextFileIO.savedataurl( id, fn, 'text/plain', content );
  },
  /* activate a <input type='file'> control so user can select file(s) */
  selfile: function( idinp ) {
    var e = UI.h.el( idinp );
    e.value = "";
    e.click();
  },
  /* open a text file */
  open: function( callback, file, onlyfiletype="text/*" ) {
    if (!file)
      return;
    var reader = new FileReader();
    reader.onerror = function( e ) {UI.h.el(idout).value = e;}
    reader.onload = function( e ) {
      if (file.type.slice(0,("text").length) == "text" || file.type == "image/svg+xml")
        callback( file.name, e.target.result, file.type );
      else
        alert( "Invalid file type ("+file.type+")" );
    }
    reader.readAsText( file );
  }
}

/*
 *  Popup support
 */
UI.popup = {
  show: function( idbtn, id ) {
    if (idbtn) {
      UI.h.class.rem( idbtn, 'closed' );
      UI.h.class.add( idbtn, 'open' );
    }
    UI.h.class.rem( id, 'closed' );
    UI.h.class.add( id, 'open' );
  },
  hide: function( idbtn, id ) {
    if (idbtn) {
      UI.h.class.rem( idbtn, 'open' );
      UI.h.class.add( idbtn, 'closed' );
    }
    UI.h.class.rem( id, 'open' );
    UI.h.class.add( id, 'closed' );
  },
  toggle: function( idbtn, id, focusonopen, togglecallback ) {
    if (togglecallback)
      if (togglecallback( UI.h.el(id).classList.contains('closed'), idbtn, id ))
        return;
    if (idbtn)
      UI.h.class.toggle( idbtn, 'open', 'closed' );
    UI.h.class.toggle( id, 'open', 'closed' );
    if (focusonopen && id)
      if (UI.h.el(id).classList.contains( 'open' ))
        UI.h.el(id).focus();
  },
  init: function( idgroup, idbtn, idpopup, autoclose=[], sel=[], selcallback, togglecallback ) {
    function btnclick() {
      UI.popup.toggle( idbtn, idpopup, true, togglecallback );
    }
    function clickout( e ) {
      if (idgroup)
        if (!UI.h.isdescendantof( e.target, UI.h.el(idgroup) ))
          UI.popup.hide( idbtn, idpopup );
    }
    var prevsel = '';
    function selclick( e ) {
      prevsel = prevsel ? prevsel : sel[0];
      var close;
      if (selcallback)
        close = selcallback( e.target, idbtn, idpopup );
      UI.popup.select( idbtn, idpopup, e.target.id, prevsel, close );
      prevsel = e.target.id;
    }
    for( var i=0; i<autoclose.length; i++ )
      UI.h.listen( autoclose[i], "click", clickout );
    for( i=0; i<sel.length; i++ )
      UI.h.listen( sel[i], "click", selclick );
    if (idbtn)
      UI.h.listen( idbtn, "click", btnclick );
  },
  prompt: function( idpopup ) {
    UI.popup.show( null, idpopup );
  },
  select: function( idbtn, idpopup, idnewitem, idprevitem, close ) {
    if (idprevitem && UI.h.el(idprevitem).classList.contains( 'open' ))
      UI.popup.hide( null, idprevitem );
    if (idnewitem && UI.h.el(idnewitem).classList.contains( 'closed' ))
      UI.popup.show( null, idnewitem );
    if (close)
      UI.popup.hide( idbtn, idpopup );
  }
}

/*
 *  UI helpers
 */
UI.h = {
  el: function( id ) {
    var e = null;
    if (id)
      if (id instanceof HTMLElement)
        e = id;
      else
        e = document.getElementById( id );
    return e;
  },
  get: function( id ) {
    var e = UI.h.el( id );
    return e ? e.value : "";
  },
  put: function( id, text, append ) {
    var t = "";
    if (append)
      t += UI.h.el( id ).value;
    UI.h.el( id ).value = t + text;
  },
  listen: function( id, eventstr, callback ) {
    const e = UI.h.el( id );
    if (e)
      return e.addEventListener( eventstr, callback );
  },
  ignore: function( id, eventstr, callback ) {
    const e = UI.h.el( id );
    if (e)
      return e.removeEventListener( eventstr, callback );
  },
  /* set element property */
  setproperty: function( id, attrname, attrvalue, alertonerror ) {
    const el = UI.h.el( id );
    try {
      const prevval = el[attrname];
      el[attrname] = attrvalue;
      return prevval;
    }
    catch( e ) {
      if (alertonerror)
        alert( "Browser doesn't support '" + attrname + "' attribute" );
    }
  },
  /* set properties for plain (code) editor vs spell-checking editor */
  seteditproperties: function( id, plain, alertonerror ) {
    UI.h.setproperty( id, 'autocapitalize', plain ? "off" : "on", alertonerror );
    UI.h.setproperty( id, 'autocomplete', plain ? "off" : "on", alertonerror );
    UI.h.setproperty( id, 'autocorrect', plain ? "off" : "on", alertonerror );
    UI.h.setproperty( id, 'spellcheck', plain ? false : true, alertonerror );
  },
  defocusize: function( elems ) {
    for ( const el of elems )
      UI.h.listen( el, "mousedown", function(e){e.preventDefault();} );
  },
  enable: function( id, enable ) {
    const e = UI.h.el( id );
    if (e)
      return e.disabled = !enable;
  },
  zoom: function( incr = 1, id ) {
    var z = UI.h.el( id ).style['font-size'];
    z = z ? z : "100%";
    z = z.slice( 0, z.length-1 ) * 1;
    z += incr * 6; if (z < 40) z = 40;
    UI.h.el( id ).style['font-size'] = z + "%";
  },
  setstyle: function( id, c, v ) {
    UI.h.el( id ).style[c] = v;
  },
  setdisplay: function( id, dis ) {
    UI.h.setstyle( id, 'display', dis );
  },
  /* determine if 'el' is inside 'parel' */
  isdescendantof: function( el, parel ) {
    //el = UI.h.el( el );
    //parel = UI.h.el( parel );
    while (el && el != parel)
      el = el.parentNode;
    return el;
  },
  /* get selection range relative to innerText (plaintext) of 'parel' */
  getabsselrange: function( parel ) {
    var sr;
    const s = window.getSelection();
    if (s.rangeCount && UI.h.isdescendantof(s.anchorNode,parel) && UI.h.isdescendantof(s.focusNode,parel)) {
      sr = {start:0, end:0};
      const r = s.getRangeAt( 0 );
      const pfx = r.cloneRange();
      pfx.selectNodeContents( parel );
      pfx.setEnd( s.anchorNode, s.anchorOffset );
      sr.start = pfx.toString().length;
      pfx.setEnd( s.focusNode, s.focusOffset );
      sr.end = pfx.toString().length;
    }
    return sr;
  },
  /* get position in DOM of pos in innerText (plaintext) of 'parel' */
  getDOMposofabspos: function( pos, parel ) {
    for( const node of parel.childNodes) {
      if (node.nodeType == Node.TEXT_NODE) {
        if (node.length >= pos)
          return {'node':node, offset:pos};
        else
          pos -= node.length;
      }
      else {
        const DOMpos = UI.h.getDOMposofabspos( pos, node );
        if (DOMpos)
          return DOMpos;
        pos -= node.innerText.length;
      }
    }
  },
  /* set selection in innerText (plaintext) of 'parel' */
  setabsselrange: function( sr, parel ) {
    const s = window.getSelection();
    s.removeAllRanges();
    const r = document.createRange();
    var DOMpos1 = DOMpos2 = UI.h.getDOMposofabspos( Math.min(parel.innerText.length,sr.start), parel );
    if (DOMpos1) {
      if (sr.end != sr.start)
        DOMpos2 = UI.h.getDOMposofabspos( Math.min(parel.innerText.length,sr.end), parel );
      if (DOMpos2)
        s.setBaseAndExtent( DOMpos1.node, DOMpos1.offset, DOMpos2.node, DOMpos2.offset );
    }
    return sr;
  },
  unionclientrects: function( els ) {
    var r, ur = {};
    for( var i=0; i<els.length; i++ ) {
      r = els[i].getBoundingClientRect();
      if (ur.left == undefined || r.left < ur.left)
        ur.left = r.left;
      if (ur.top == undefined || r.top < ur.top)
        ur.top = r.top;
      if (ur.right == undefined || r.right > ur.right)
        ur.right = r.right;
      if (ur.bottom == undefined || r.bottom > ur.bottom)
        ur.bottom = r.bottom;
    }
    return ur;
  },
  /* smooth scroll an element to a pixel position */
  scrolltopos: function( el, posx, posy, opts={} ) {
    opts.smooth = opts.smooth == undefined ? true : opts.smooth,
    opts.delay = opts.delay == undefined ? 20 : opts.delay;
    opts.maxsteps = opts.maxsteps == undefined ? 20 : opts.maxsteps;
    opts.minincr = opts.minincr == undefined ? 5 : opts.minincr;
    var delta = {
      x: (posx - el.scrollLeft) / opts.maxsteps,
      y: (posy - el.scrollTop) / opts.maxsteps
    }
    delta.x = delta.x < 0 ? Math.min(delta.x,opts.minincr) : Math.max(delta.x,opts.minincr);
    delta.y = delta.y < 0 ? Math.min(delta.y,opts.minincr) : Math.max(delta.y,opts.minincr);
    var nextpos = {
      x: el.scrollLeft,
      y: el.scrollTop
    }
    function anim() {
      nextpos.x += delta.x,
      nextpos.y += delta.y;
      nextpos.x = delta.x < 0 ? Math.max(nextpos.x,posx) : Math.min(nextpos.x,posx);
      nextpos.y = delta.y < 0 ? Math.max(nextpos.y,posy) : Math.min(nextpos.y,posy);
      nextpos.x = opts.smooth ? nextpos.x : posx;
      nextpos.y = opts.smooth ? nextpos.y : posy;
      el.scrollLeft = nextpos.x;
      el.scrollTop = nextpos.y;
      if (nextpos.x != posx || nextpos.y != posy)
        setTimeout( anim, opts.delay );
      else
        if (opts.scrollingdonecallback)
          opts.scrollingdonecallback();
    }
    anim();
  },
  /* scroll to and center a rect in an element */
  scrolltorect: function( el, r={left:0,right:0,top:0,bottom:0}, opts={} ) {
    function inside( pt, r ) {
      return (pt.x >= r.left && pt.x < r.right && 
              pt.y >= r.top && pt.y < r.bottom);
    }
    function toobigx( r, cr ) {
      var w = r.right - r.left;
      var cw = cr.right - cr.left;
      return (w > cw);
    }
    function toobigy( r, cr ) {
      var h = r.bottom - r.top;
      var ch = cr.bottom - cr.top;
      return (h > ch);
    }
    opts.center = opts.center == undefined ? true : opts.center;
    const ebr = el.getBoundingClientRect();
    var vr = {
      left: el.scrollLeft,
      right: el.scrollLeft + ebr.width,
      top: el.scrollTop,
      bottom: el.scrollTop + ebr.height
    };
    /* (if rect is already visible, no scrolling takes place) */
    if (inside( {x:r.left, y:r.top}, vr ) && inside( {x:r.right, y:r.bottom}, vr )) {
      if (opts.scrollingdonecallback)
        opts.scrollingdonecallback();
    }
    else {
      var pt = {x: r.left + ((r.right - r.left) / 2),
                y: r.top + ((r.bottom - r.top) / 2)};
      if (toobigx( r, ebr ))
        /* scroll to left if rect is too wide to fit in client */
        pt.x = r.left - 10;
      else {
        /* (the bias is to scroll to 0 horizontally (don't center) if rect in leftmost area) */
        if (r.right < ebr.width)
          pt.x = 0;
        else
          if (opts.center)
            /* move x to center if entire width not already visible */
            if (r.left < vr.left || r.right > vr.right)
              pt.x -= ebr.width / 2;
            else
              pt.x = el.scrollLeft;
      }
      if (toobigy( r, ebr ))
        /* scroll to top if rect is too long to fit in client */
        pt.y = r.top - 10;
      else
        if (opts.center)
          /* move y to center if entire length not already visible */
          if (r.top < vr.top || r.bottom > vr.bottom)
            pt.y -= ebr.height / 2;
          else
            pt.y = el.scrollTop;
      UI.h.scrolltopos( el, pt.x, pt.y, opts );
      return true;
    }
  },
  /* scroll container to an element cluster */
  scrollelemsintoview: function( containerel, insideels, opts={} ) {
    const ir = UI.h.unionclientrects( insideels );
    const cr = containerel.getBoundingClientRect();
    const oir = {
      left: ir.left - cr.left + containerel.scrollLeft,
      right: ir.right - cr.left + containerel.scrollLeft,
      top: ir.top - cr.top + containerel.scrollTop,
      bottom: ir.bottom - cr.top + containerel.scrollTop
    };
    function scrollingdone() {
      if (opts.blink) {
        var t = opts.blink.targets;
        if (!t)
          t = insideels;
        for( var i=0; i<t.length; i++ )
          UI.h.class.add( t[i], opts.blink.class );
        function blinkdone() {
          for( var j=0; j<t.length; j++ )
            UI.h.class.rem( t[j], opts.blink.class );
        }
        setTimeout( blinkdone, opts.blink.duration );
      }
      delete opts.scrollingdonecallback;
    }
    opts.scrollingdonecallback = scrollingdone;
    UI.h.scrolltorect( containerel, oir, opts );
  },
  /* scroll container to an element, centered (default) */
  scrollelemintoview: function( containerel, insideel, opts={} ) {
    UI.h.scrollelemsintoview( containerel, [insideel], opts );
  },
  markuphtml: function( tag, attrs, innerhtml ) {
    var html = '<' + tag;
    for( var a in attrs )
      html += " " + a + '="' + attrs[a] + '"';
    return html + '>' + innerhtml + '</' + tag + '>';
  },
  text2html: function( text ) {
    var newtext = text.replace( /&/g, "&amp;" );
    newtext = newtext.replace( />/g, "&gt;" );
    return newtext.replace( /</g, "&lt;" );
  },
  class: {
    add: function( id, c ) {
      var e = UI.h.el( id );
      if (e)
        e.classList.add( c );
    },
    rem: function( id, c ) {
      var e = UI.h.el( id );
      if (e && e.classList.contains( c ))
        e.classList.remove( c );
    },
    toggle: function( id, c1, c2 ) {
      var e = UI.h.el( id );
      if (e)
        if (e.classList.contains( c1 )) {
          e.classList.remove( c1 );
          if (c2) e.classList.add( c2 );
        }
        else {
          if (c2) e.classList.remove( c2 );
          e.classList.add( c1 );
        }
    },
    replace: function( id, c1, c2 ) {
      var e = UI.h.el( id );
      if (e) {
        if (e.classList.contains( c1 ))
          e.classList.remove( c1 );
        if (c2) e.classList.add( c2 );
      }
    }
  }
}
  </script>

  <!--script type="text/javascript" src="lib/stylotroneditor.js"/script-->
  <script>
/*
 * stylotroneditor.js: foundation for WYSIWYG editor using stylotron.js for dynamic markup
 *
 *   UI.stylotroneditor.Styler:     uses a SOT.PatternSeries object to mark up content in a UI.TextEditor as it changes
 *
 *   UI.stylotroneditor.Selections: souped up selection and multi-selections support
 *   UI.stylotroneditor.Search:     regex search and replace; marks up matched, current, and replaced ranges
 *
 *   UI.StylotronEditor:            a UI.TextEditor with Styler and other opt-in attachments
 *
 *   single step init:              editor = UI.stylotroneditor.createinit( texteditorid, opts, patterndefs )
 *
 * Requires stylotron.js and texteditor.js
 *
 * See texteditor.html and stylotronIDE.html for examples of use
 *
 * cc0 (public domain) v.010 September 2025, latest version @ github.com/gregsidal
 */

/*
 * Single-step setup
 */
UI.stylotroneditor = {
  createinit: function( texteditorid, opts, patterndefs={} ) {
    const editor = new UI.StylotronEditor( texteditorid, opts );
    editor.styler.patterns().add( patterndefs );
    editor.texteditor.initrefresh();
    return editor;
  }
}

/*
 * Texteditor with styler; also optional undo/redo, fontpicker, and search attachments
 */
UI.StylotronEditor = function( texteditorid, opts={} ) {
  /* setup text editor with undo/redo and fontpicker if indicated */
  this.components = new UI.texteditor.Components( texteditorid, opts );
  this.texteditor = this.components.get( 'texteditor' );
  /* attach patterns component */
  this.styler = this.components.add( 'styler', new UI.stylotroneditor.Styler() );
  this.styler.init( this.texteditor );
  /* attach optional selections component */
  if (opts.selections) {
    this.selections = this.components.add( 'selections', new UI.stylotroneditor.Selections() );
    this.selections.init( this.texteditor, this.styler, opts.selections.profiles );
  }
  /* attach optional search component */
  if (opts.search) {
    this.search = this.components.add( 'search', new UI.stylotroneditor.Search() );
    this.search.init( this.texteditor, this.styler, opts.search );
  }
}

/*
 * Styler attachment for a TextEditor
 *   marks up content in a text editor with CSS classes using stylotron.js
 *
 * To set up:
 *   styler = new UI.stylotroneditor.Styler();
 *   styler.init( texteditor );
 *
 * An internal SOT.PatternSeries object determines what ranges of text are marked up
 *   to get: patterns = styler.patterns()
 *   regexs and ranges can be added to 'patterns' as described in SOT.PatternSeries comments
 */
UI.stylotroneditor.Styler = function() {
  this.init = function( texteditor ) {
    _i.texteditor = texteditor;
    _i.patterns = new SOT.PatternSeries();
    _i.prevbeforetextchangecallback = texteditor.setcallback( 'beforetextchange', _i.oneditorbeforetextchange );
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    _i.prevremarkupcallback = texteditor.setcallback( 'remarkup', _i.oneditorremarkup );
  }
  this.patterns = function() {return _i.patterns};
  /* get text map (map of all regex matches) */
  this.textmap = function( recreate ) {
    if (recreate || !_i.currenttextmap)
      _i.currenttextmap = _i.patterns.buildmatchesmap( _i.texteditor.get() );
    return _i.currenttextmap;
  }
  this.reset = function() {
    this.textmap( true );
    return _i.texteditor.refresh();
  }
  // internals
  var _i = {
    texteditor: null, profiles: {},
    oneditorbeforetextchange: function( e2 ) {
      const ret = _i.prevbeforetextchangecallback( e2 );
      _i.currenttextmap = null; //_i.patterns.buildmatchesmap( _i.textarea.get() );
      return ret;
    },
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      refresh = e2.textchanged || refresh;
      return refresh;
    },
    oneditorremarkup: function( text, e2 ) {
      //var HTML = _i.prevremarkupcallback( e2 );
      if (!_i.currenttextmap)
        _i.currenttextmap = _i.patterns.buildmatchesmap( text );
      var fullmap = _i.patterns.buildrangesmap( text, _i.currenttextmap );
      return _i.patterns.markupmap( text, fullmap );
    }
  }
}

/*
 *  Multiple selections attachment for a TextEditor
 *
 *  To set up:
 *    selections = new UI.stylotroneditor.Selections();
 *    selections.init( texteditor, texteditorstyler, profiles = {default} );
 *
 *  To select/deselect a range:
 *    selections.selectrange = function( profilename, range, refresh )
 *    selections.clrrange = function( profilename, refresh )
 *
 *  To insert text and select it with a profile:
 *    selections.inserttext( text, e2={action:"insertFromCustomInsert"}, range, profilename )
 *
 *  Profiles:
 *    cls: range is marked up with this class when selected
 *    trackselection: when set, selected range will mirror browser's (native) selection
 *    removewhen:
 *      focused:        selection removed when editor focused
 *      blurred:        - when editor blurred
 *      caretmoved:     - when caret is moved
 *      textchanged:    - when text changes
 *
 *  Default profile marks up browser's selection with class 'texteditor-selected' when not focused:
 *    'selection-notfocused': {cls:'texteditor-selected', trackselection:true, removewhen:{focused:true}}
 */
UI.stylotroneditor.Selections = function() {
  this.init = function( texteditor, texteditorstyler, profiles=
           {'selection-notfocused': {cls:'texteditor-selected', trackselection:true, removewhen:{focused:true}}} ) {
    _i.texteditor = texteditor;
    _i.editorstyler = texteditorstyler;
    _i.profiles = profiles;
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
  }
  this.profiles = function() {return _i.profiles};
  this.selectrange = function( profilename, range, refresh ) {
    const needsrefresh = _i.sel( profilename, range );
    if (refresh && needsrefresh)
      _i.texteditor.refresh();
    return needsrefresh;
  }
  this.clrrange = function( profilename, refresh ) {
    const needsrefresh = _i.clr( profilename );
    if (refresh && needsrefresh)
      _i.texteditor.refresh();
    return needsrefresh;
  }
  /* insert text into range (default selected range) and mark it with a profile */
  this.inserttext = function( text, e2={action:"insertFromCustomInsert"}, range, profilename ) {
    e2.insertedprofilename = profilename;
    return _i.texteditor.insert( text, e2, range, false );
  }
  // internals
  var _i = {
    texteditor: null, profiles: {},
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      if (_i.testall( e2 ))
        refresh = true;
      return refresh;
    },
    sel: function( profilename, r ) {
      if (!r || r.start == r.end)
        return _i.clr( profilename );
      _i.profiles[profilename].range = r;
      var m = _i.editorstyler.patterns().get( _i.profiles[profilename].cls );
      if (!m || m.range.start != r.start || m.range.end != r.end) {
        _i.editorstyler.patterns().addrange( r, _i.profiles[profilename].cls );
        return true;
      }
    },
    clr: function( profilename ) {
      _i.profiles[profilename].range = null;
      var m = _i.editorstyler.patterns().get( _i.profiles[profilename].cls );
      if (m) {
        _i.editorstyler.patterns().del( _i.profiles[profilename].cls );
        return true;
      }
    },
    test: function( profilename, e2 ) {
      var remove = false;
      const profile = _i.profiles[profilename];
      const removewhen = profile.removewhen ? profile.removewhen : {};
      if (removewhen.focused && e2.focused)
        remove = true;
      if (removewhen.blurred && !e2.focused)
        remove = true;
      if (removewhen.textchanged)
        if (!e2.insertedprofilename || e2.insertedprofilename != profilename)
          if (e2.textchanged)
            remove = true;
      if (removewhen.caretmoved)
        if (SOT.text.startswith( e2.action, 'selchange' ))
          remove = true;
      var refresh;
      if (remove) {
        if (_i.clr( profilename ))
          refresh = true;
      }
      else {
        if (profile.trackselection)
          profile.range = e2.selrange;
        else
          if (e2.insertedprofilename && e2.insertedprofilename == profilename && e2.insertedrange)
            profile.range = e2.insertedrange;
        if (_i.sel( profilename, profile.range ))
          refresh = true;
      }
      return refresh;
    },
    testall: function( e2 ) {
      var refresh = false;
      for( const profilename in _i.profiles )
        if (_i.test( profilename, e2 ))
          refresh = true;
      return refresh;
    }
  }
}

/*
 *  Search/replace attachment for a TextEditor
 *
 *  To set up:
 *    search = new UI.stylotroneditor.Search();
 *    search.init( texteditor, texteditorstyler, ids=UI.search.defaultids, classes=UI.search.defaultclasses );
 *
 *  The controls in 'ids' trigger the search/replace functions 
 *
 *  CSS class classes.match is applied to text matching search results
 *  classes.current is applied to current match
 *  classes.replaced is applied to replacement text
 *
 *  Current match is determined by position of the caret
 *    (navigation repositions the caret which in turn repositions the current match)
 */
UI.stylotroneditor.search = {
  defaultopts: {
    ids: {
      find:           'search-find',        //input
      findbtn:        'search-findbtn',
      nextbtn:        'search-nextbtn',
      scrolltobtn:    'search-scrolltobtn',
      prevbtn:        'search-prevbtn',
      clearbtn:       'search-clearbtn',
      replace:        'search-replace',     //input
      replacebtn:     'search-replacebtn',
      replaceallbtn:  'search-replaceallbtn'
    },
    classes: {
      match:          'search-match',
      current:        'search-current',
      currentflash:   'search-currentflash',
      currentblink:   'search-currentblink',
      replaced:       'search-replaced'
    },
    miscopts: {
      currentblinkduration: 1100,
      replaceanimationdelay: 350
    },
    lockctls: true
  }
};
UI.stylotroneditor.Search = function() {
  this.init = function( texteditor, texteditorstyler, opts = UI.stylotroneditor.search.defaultopts ) {
    _i.texteditor = texteditor;
    _i.editorstyler = texteditorstyler;
    _i.prevbeforetextchangecallback = texteditor.setcallback( 'beforetextchange', _i.oneditorbeforetextchange );
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    _i.ids = opts.ids ? opts.ids : UI.stylotroneditor.search.defaultopts.ids;
    _i.classes = opts.classes ? opts.classes : UI.stylotroneditor.search.defaultopts.classes;
    _i.miscopts = opts.miscopts ? opts.miscopts : UI.stylotroneditor.search.defaultopts.miscopts;
    _i.searchsets[0].classes = {match: _i.classes.match};
    this.lockctls( opts.lockctls == undefined ? UI.stylotroneditor.search.defaultopts.lockctls : opts.lockctls );
  }
  this.lockctls = function( lock=true ) {
    _i.ctlslocked = lock;
    if (lock) {
      UI.h.listen( _i.ids.findbtn, "click", _i.find );
      UI.h.listen( _i.ids.nextbtn, "click", _i.next );
      UI.h.listen( _i.ids.scrolltobtn, "click", _i.viewcurrent );
      UI.h.listen( _i.ids.prevbtn, "click", _i.prev );
      UI.h.listen( _i.ids.clearbtn, "click", _i.clear );
      UI.h.listen( _i.ids.replacebtn, "click", _i.replace );
      UI.h.listen( _i.ids.replaceallbtn, "click", _i.replaceall );
      UI.h.seteditproperties( _i.ids.find, true );
      UI.h.seteditproperties( _i.ids.replace, true );
      UI.h.listen( _i.ids.find, "input", _i.clear );
      _i.resetctls();
    }
    else {
      UI.h.ignore( _i.ids.findbtn, "click", _i.find );
      UI.h.ignore( _i.ids.nextbtn, "click", _i.next );
      UI.h.ignore( _i.ids.scrolltobtn, "click", _i.viewcurrent );
      UI.h.ignore( _i.ids.prevbtn, "click", _i.prev );
      UI.h.ignore( _i.ids.clearbtn, "click", _i.clear );
      UI.h.ignore( _i.ids.replacebtn, "click", _i.replace );
      UI.h.ignore( _i.ids.replaceallbtn, "click", _i.replaceall );
      UI.h.ignore( _i.ids.find, "input", _i.clear );
    }
  }
  this.clear = function( keepmatches, refresh ) {
    _i.clear( null, keepmatches, refresh );
  }
  this.activate = function( active ) {
    _i.activate( active );
  }
  this.find = function( verbose=true ) {
    _i.find( verbose );
  }
  this.next = function( dir=1, verbose=true ) {
    _i.next( dir, verbose );
  }
  this.scrollcurrentintoview = function( opts ) {
    _i.scrollcurrentintoview( opts );
  }
  this.scrollreplacedintoview = function( opts ) {
    _i.scrollreplacedintoview( opts );
  }
  this.replace = function() {
    return _i.replace();
  }
  this.replaceall = function() {
    return _i.replaceall();
  }
  this.quickreplaceall_DONOTUSE = function() {
    if (!_i.searchset().found)
      alert( "No matches" );
    else {
      var map = _i.textmap();
      if (!map.length)
        alert( "No matches" );
      else {
        var text = _i.texteditor.get();
        var replacewiths = {};
        replacewiths[_i.classes.match] = UI.h.get( _i.ids.replace );
        text = SOT.text.map.replaceall( text, map, replacewiths );
        _i.texteditor.put( text, {action:'insertFromReplaceAll'} );
      }
    }
  }
  // internals
  var _i = {
    texteditor: null, active:0, searchsets: [{found:"", regex:null, mapindex:-1}],
    searchset: function() {return _i.active >= 0 ? _i.searchsets[_i.active] : null;},
    action: function( e, t ) {
      return e && e.action && e.action.substring( 0, t.length ) == t;
    },
    oneditorbeforetextchange: function( e2 ) {
      const ret = _i.prevbeforetextchangecallback( e2 );
      _i.searchset().currenttextmap = null;
      return ret;
    },
    /* reposition the current match when caret moves/text changes */
    oneditorstatechange: function( e2 ) {
      function reposcurrent() {
        var redraw = false;
        var map = _i.textmap();
        const pro = _i.searchset();
        var i = SOT.text.map.range.nearest( e2.selrange.start, map );
        if (i != pro.mapindex || e2.textchanged || _i.action(e2,'insertFromReplace')) {
          if (!_i.action( e2, 'insertFromReplace' ))
            if (_i.editorstyler.patterns().get( _i.classes.replaced ))
              _i.editorstyler.patterns().del( _i.classes.replaced ), redraw = true;
          pro.mapindex = i;
          if (pro.mapindex >= 0)
            _i.editorstyler.patterns().addrange( map[pro.mapindex].range, _i.classes.current ), redraw = true;
          else
            if (_i.editorstyler.patterns().get( _i.classes.current ))
              _i.editorstyler.patterns().del( _i.classes.current ), redraw = true;
        }
        return redraw;
      }
      var refresh = _i.prevchangecallback( e2 );
      if (_i.searchset().awake)
        if (e2.textchanged) {
          _i.resetctls();
          reposcurrent();
          refresh = true;
        }
        else
          if (_i.action( e2, 'selchange' ) && e2.selrange.start == e2.selrange.end && 
              (e2.selrange.start != e2.prevselrange.start || 
               e2.selrange.end != e2.prevselrange.end ||
               _i.action( e2, 'selchangeFromFind') ||
               _i.action( e2, 'selchangeFromActivate'))) {
            if (reposcurrent())
              refresh = true;
          }
      return refresh;
    },
    /* build a text map of current search set */
    newmap: function( text ) {
      const patterns = new SOT.PatternSeries();
      if (_i.searchset().regex)
        patterns.addregex( _i.searchset().regex, _i.searchset().classes.match );
      return patterns.buildmatchesmap( text ? text : _i.texteditor.get() );
    },
    /* get map of regex matches in search set */
    textmap: function( regen ) {
      var map;
      if (_i.searchsets.length) {
        if (regen || !_i.searchset().currenttextmap)
          _i.searchset().currenttextmap = _i.newmap();
        if (regen)
          _i.editorstyler.textmap( regen );
        map = _i.searchset().currenttextmap;
      }
      else
        map = _i.editorstyler.textmap( regen );
      return map;
    },
    resetctls: function() {
      const canfind = UI.h.get( _i.ids.find );
      const matches = _i.textmap().length;
      const canmove = canfind && _i.textmap().length != 1;
      if (_i.ctlslocked) {
        UI.h.enable( _i.ids.findbtn, canfind );
        UI.h.enable( _i.ids.nextbtn, canmove );
        UI.h.enable( _i.ids.scrolltobtn, matches );
        UI.h.enable( _i.ids.prevbtn, canmove );
        UI.h.enable( _i.ids.clearbtn, matches );
        UI.h.enable( _i.ids.replacebtn, matches );
        UI.h.enable( _i.ids.replaceallbtn, _i.textmap().length > 1 );
      }
    },
    clear: function( e, keepmatches, refresh=true ) {
      const pro = _i.searchset();
      if (!pro)
        return;
      pro.awake = 0;
      pro.mapindex = -1;
      if (!keepmatches) {
        _i.editorstyler.patterns().del( pro.classes.match );
        pro.found = "", pro.regex = null;
      }
      _i.editorstyler.patterns().del( _i.classes.current );
      _i.editorstyler.patterns().del( _i.classes.replaced );
      _i.textmap( true );
      if (refresh)
        _i.texteditor.refresh();
      _i.resetctls();
    },
    activate: function( searchsetindex=0 ) {
      _i.active = searchsetindex;
      _i.searchset().awake = 1;
      _i.texteditor.setcaretpos( -1, {action:'selchangeFromActivate'} );
      //_i.scrollcurrentintoview();
      _i.resetctls();
    },
    find: function( verbose=true, dir=1 ) {
      try {
        _i.searchset().found = UI.h.get( _i.ids.find );
        _i.searchset().regex = SOT.text.regexstr2regex( _i.searchset().found, 'g' );
        _i.searchset().awake = 1;
        _i.searchset().mapindex = -1;
        _i.editorstyler.patterns().del( _i.classes.current );
        _i.editorstyler.patterns().del( _i.classes.replaced );
        _i.editorstyler.patterns().addregex( _i.searchset().regex, _i.searchset().classes.match );
        _i.textmap( true );
        _i.resetctls();
        _i.movecurrent( dir, verbose, {action:'selchangeFromFind'} );
      }
      catch( e ) {
        _i.clear();
        if (verbose)
          alert( e ); //"Invalid regular expression" );
      }
    },
    scrollmarkintoview: function( cls, opts ) {
      const els = _i.texteditor.el().getElementsByClassName( cls );
      if (els && els.length) {
        /*if (opts.blink)
          opts.blink.targets = els;*/
        _i.texteditor.scrollelemsintoview( els, opts );
      }
    },
    scrollcurrentintoview: function( opts ) {
      _i.scrollmarkintoview( _i.classes.current, 
              {blink: {class:_i.classes.currentflash, duration:_i.miscopts.currentblinkduration}} );
    },
    viewcurrent: function( e ) {
      _i.scrollmarkintoview( _i.classes.current, 
              {blink: {class:_i.classes.currentblink, duration:_i.miscopts.currentblinkduration}} );
    },
    scrollreplacedintoview: function( opts ) {
      _i.scrollmarkintoview( _i.classes.replaced, opts );
    },
    movecurrent: function( dir=1, verbose=true, e2={action:'selchangeFromNav'} ) {
      if (!_i.searchset().found)
        return _i.find( true, dir );
      _i.editorstyler.patterns().del( _i.classes.current );
      _i.editorstyler.patterns().del( _i.classes.replaced );
      var pos = -1, map = _i.textmap();
      /* find start position of next/prev */
      if (map.length) {
        var i = _i.searchset().mapindex + dir;
        i = i < 0 ? map.length-1 : (i >= map.length ? 0 : i);
        pos = map[i].range.start;
      }
      else {
        if (verbose)
          alert( "No matches" );
      }
      /* reposition the caret (will cause current match to update) */
      _i.texteditor.setcaretpos( pos, e2 );
      /* at this point, current match is updated so make sure it's in view */
      _i.scrollcurrentintoview();
    },
    next: function( e ) {
      _i.movecurrent( 1 );
      if (e)
        e.preventDefault();
    },
    prev: function( e ) {
      _i.movecurrent( -1 );
      if (e)
        e.preventDefault();
    },
    _replace: function( group ) {
      if (group)
        group.more = false;
      if (!_i.searchset().found || _i.searchset().mapindex < 0)
        alert( "No matches" );
      else {
        var map = _i.textmap();
        if (!map.length)
          alert( "No matches" );
        else {
          var text = _i.texteditor.get();
          var len = text.length;
          var i = _i.searchset().mapindex;
          var r = map[i].range;
          var e2 = {action:'insertFromReplace'};
          if (group) {
            group.more = i < map.length - 1;
            e2.group = group;
          }
          text = SOT.text.map.replace( text, map, _i.searchset().mapindex, UI.h.get(_i.ids.replace) );
          /* calculate replaced text range */
          r = {start:r.start, end:r.end + (text.length - len)};
          /* ready caret to be repositioned to the next match if any */
          /*   (replacement can change the match count, so that is taken into account) */
          var newpos = r.end;
          var newmap = _i.newmap( text );
          if (newmap.length) {
            i += newmap.length - map.length;
            i = i >= newmap.length-1 ? 0 : i+1;
            newpos = newmap[i].range.start;
          }
          _i.searchset().mapindex = -1;
          _i.editorstyler.patterns().addrange( r, _i.classes.replaced );
          /* put the new text (will reposition the caret, causing current match to update) */
          _i.texteditor.put( text, e2, {start:newpos, end:newpos} );
          /* at this point, replacement is styled, make sure it's in view */
          _i.scrollreplacedintoview( {smooth:!group} );
        }
      }
      return group;
    },
    replace: function() {
      return _i._replace();
    },
    replaceall: function() {
      function repl1() {
        group = _i._replace( group );
        group.start = false;
        if (group && group.more)
          setTimeout( repl1, _i.miscopts.replaceanimationdelay );
      }
      var group = {start:true};
      repl1();
    }
  }
}
  </script>

  <script>
const IDE = {
  opts: {
    selections:{},
    undoredo: {},
    search: {}
  },
  plaintextpatternseries: {
    'IDE IDE_documentcontainer': {regex: /(.*(\n|$))*/g}, //htmltag:'div'},
    IDE_documentbody:            {regex: /(.*(\n|$))*/g}, //htmltag:'div'},
    IDE_block:                   /.+/g,
  },
  codepatternseries: {
    'IDE IDE_documentcontainer': {regex: /(.*(\n|$))*/g}, //htmltag:'div'},
    IDE_documentbody:            {regex: /(.*(\n|$))*/g}, //htmltag:'div'},
    IDE_codeblockcontainer:      /(?:.*(?:\n|$))*/g,
    IDE_codeblock:               /(?:.*(?:\n|$))*/g,
    IDE_block:                   /(?:.+\n)|\n/g,

    'IDE_comment html':          /(?<=^|\W)\<\!--(?:.|\n)+?--\>/g,
    'IDE_comment js':            /(?<=^|\W)\/\*(?:.|\n)+?\*\/| \/\/.*/g,

    IDE_regex:                   /(?<=\W)\/.+\/[gmis]+(?=[ .,;\n\]\}\)])/g,
    IDE_regexslashed:            /(?<=\W)\/.+\/(?=[gmis]+[ .,;\n\]\}\)])/g,
    IDE_regexpattern:            /(?<=\W\/).+(?=\/[gmis]+[ .,;\n\]\}\)])/g,

    'IDE_tag js':                /(?<=^|[\{\[\(\s,])[\w-]+(?=:)/g,
    'IDE_tag json':              /(?<=^|\W)'[\w- ]+'(?=:)/g,
    'IDE_tag html':              /(?<=<\/{0,1})\w+(?=[\s\[>])/g,

    'IDE_quoted single':         /(?<=^|\W)'.*?'(?=\W)/g,
    'IDE_quoted double':         /(?<=^|\W)\".*?\"(?=\W)/g,
    'IDE_quoted slant':          /(?<=^|\W)`.*?`(?=\W)/g,

    'IDE_number dec':            /(?<=^|[^\w.#])[+|-]{0,1}(?:\d+[.]\d+|\d+)(?=$|[^\w.]|\.[ \n]+|px\W|em\W|rem\W)/g,
    'IDE_number hex':            /(?<=#)[A-Fa-f0-9]+(?=$|\W)/g,
    'IDE_number htmlentity':     /&(?:[a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/g,

    IDE_keyword:                 /(?<=[^"'`.-\w])(?:new|if|else|do|while|switch|for|in|of|continue|break|return|typeof|function|var|const|let|\.length)(?=[^"'`.-\w])/g,
  },
  onload: function() {
    IDE.save.updatesavedialog();
    IDE.views['js'].editedtext = UI.h.el('IDE_patternscript').innerHTML;
    IDE.views['css'].editedtext = UI.h.el('IDE_cssscript').innerHTML;
    IDE.editor = UI.stylotroneditor.createinit( 'IDE_stylotroncontainer', IDE.opts, UserDocument.patternseries );
    IDE.editor.texteditor.changed( false );
    UI.h.listen( 'IDE_savefile-filename', "input", IDE.onfilenamechanged );
    UI.popup.init( 'IDE_selectview', 'IDE_selectviewbtn', 'IDE_selectviewpopup', ['IDE_body'],
                   ['html','txt','js','css'], 
                   IDE.selectview );
    UI.popup.init( 'IDE_savechanges', 'IDE_savechanges-togglebtn', 'IDE_savechanges-popup', ['IDE_body'], 
                   ['IDE_savechanges-okbtn','IDE_savechanges-cancelbtn'], 
                   IDE.open.savechangesresponse, IDE.open.togglesavechanges );
    UI.popup.init( 'IDE_savefile', 'IDE_savefile-togglebtn', 'IDE_savefile-popup', ['IDE_body'], 
                   ['IDE_savefile-savebtn'], 
                   IDE.save.savefile );
    UI.popup.init( null, 'IDE_searchbtn', 'IDE_searchpopup', [], [], undefined, IDE.togglesearch );
  },
  onbeforeunload: function( e ) {
    if (IDE.ispartchanged( 'html' ) ||
        IDE.ispartchanged( 'txt' ) ||
        IDE.ispartchanged( 'js' ) ||
        IDE.ispartchanged( 'css' )) {
      e.preventDefault();
      e.returnValue = "";
    }
  },
  wrap: function( e ) {
    /*if (UI.h.el('texteditor-wraptoggle').checked)
      UI.h.el('IDE_stylotroncontainer').style['overflow-x'] = 'clip';*/
  },
  togglesearch: function( isopen ) {
    if (isopen) {
      UI.h.class.add( 'IDE_panelcontainer', 'openbar' );
      UI.h.class.add( 'IDE_toolbar', 'openbar' );
      IDE.editor.search.activate( 0 );
    }
    else {
      UI.h.class.rem( 'IDE_panelcontainer', 'openbar' );
      UI.h.class.rem( 'IDE_toolbar', 'openbar' );
      IDE.editor.search.clear( true );
    }
  },
  selectview: function( e ) {
    const newview = e.id;
    if (IDE.view != newview)
      IDE.toggleview( newview );
    return true;
  },
  view: 'html',
  views: {
    html:      {filename: "", changed: false, wrap:true}, 
    txt:       {filename: "", changed: false, wrap:true},
    js:        {filename: "", changed: false, wrap:false},
    css:       {filename: "", changed: false, wrap:false}
  },
  onfilenamechanged: function() {
    if (IDE.view == 'html') {
      if (IDE.filenamepfx('html') == IDE.filenamepfx('txt'))
        IDE.views['txt'].filename = "";
      if (IDE.filenamepfx('html') == IDE.filenamepfx('js'))
        IDE.views['js'].filename = "";
      if (IDE.filenamepfx('html') == IDE.filenamepfx('css'))
        IDE.views['css'].filename = "";
    }
  },
  defaultfilename: "userdocument",
  getfilename: function( view=IDE.view ) {
    var fn = IDE.views[view].filename ? IDE.views[view].filename : (IDE.defaultfilename + "." + view);
    if (view != 'html' && !IDE.filenamepfx(view))
      fn = IDE.filenamepfx('html') + "." + view;
    return fn;
  },
  setfilename: function( fn, view=IDE.view ) {
    if (fn)
      IDE.views[view].filename = fn;
  },
  resetfilename: function( view=IDE.view ) {
    IDE.views[view].filename = "";
  },
  filenamepfx: function( view ) {
    if (!IDE.views[view].filename)
      return "";
    return SOT.text.extract( IDE.views[view].filename, IDE.pgmarkers.fileregex );
  },
  mkfilenamefrom: function( part, frompart ) {
    return SOT.text.extract(IDE.getfilename(frompart), IDE.pgmarkers.fileregex) + "." + part;
  },
  ispartembedded: function( part ) {
    if (part == 'txt' || part == 'html')
      return true;
    return IDE.views[part].extractedtext !== null;
  },
  ispartchanged: function( part ) {
    return IDE.viewchanged( true, part );
  },
  viewchanged: function( testchanged=true, view=IDE.view ) {
    if (view == IDE.view && IDE.editor.texteditor.changed() === testchanged)
      return true;
    return IDE.views[view].changed === testchanged;
  },
  ispagechanged: function() {
    return IDE.ispartchanged('html') ||
           IDE.ispartchanged('txt') ||
           (IDE.ispartembedded('js') && IDE.ispartchanged('js')) ||
           (IDE.ispartembedded('css') && IDE.ispartchanged('css'));
  },
  toggleview: function( newview='txt' ) {
    const elem = document.getElementById( 'IDE_stylotroncontainer' );
    const patterns = IDE.editor.styler.patterns();
    patterns.clear();
    /* save changes in current view */
    IDE.setfilename( UI.h.get('IDE_savefile-filename') );
    IDE.views[IDE.view].changed = IDE.editor.texteditor.changed();
    IDE.views[IDE.view].wrap = UI.h.el( 'texteditor-wraptoggle' ).checked;
    IDE.views[IDE.view].scrollpos = IDE.editor.texteditor.getscrollpos();
    IDE.views[IDE.view].editedtext = IDE.editor.texteditor.get();
    if (IDE.view == 'js')
      IDE.putcode( IDE.views[IDE.view].editedtext, 'script' );
    else
      if (IDE.view == 'css')
        IDE.putcss( IDE.views[IDE.view].editedtext, 'style' );
      else
        if (IDE.view == 'txt') {
          IDE.views['html'].editedtext = IDE.views[IDE.view].editedtext;
          IDE.views['html'].changed = IDE.views[IDE.view].changed;
        }
        else
          if (IDE.view == 'html')
            IDE.views['txt'].changed = IDE.views['html'].changed;
    /* setup new view */
    var text = IDE.views[newview].editedtext;
    if (newview == 'html') {
      patterns.add( UserDocument.patternseries );
    }
    else
      if (newview == 'txt') {
        patterns.add( IDE.plaintextpatternseries );
        text = IDE.views['html'].editedtext;
      }
      else
        patterns.add( IDE.codepatternseries );
    IDE.editor.texteditor.seteditproperties( newview == 'css' || newview == 'js' );
    /* put contents */
    IDE.editor.texteditor.put( text, {action:"insertFromToggleView"} );
    IDE.editor.texteditor.wrap( IDE.views[newview].wrap );
    IDE.editor.texteditor.scrollto( IDE.views[newview].scrollpos, {smooth:false} );
    /* reset everything */
    IDE.editor.components.get('undoredo').clear();
    IDE.editor.search.clear( false );
    IDE.view = newview;
    IDE.save.updatesavedialog( newview );
    UI.h.el( 'IDE_openinsertbtn' ).disabled = newview == 'html';
    IDE.editor.styler.reset();
    IDE.editor.texteditor.changed( IDE.views[newview].changed );
  },
  putcode: function( code, tag='script', id='IDE_patternscript' ) {
    try {
      eval( code );  // (will throw on syntax error)
      
      const el = document.createElement( tag );
      el.innerHTML = code;
      el.id = id;
      document.head.removeChild( UI.h.el(id) );
      document.head.appendChild( el );
    }
    catch( e ) {
      alert( "Code contains error(s), any changes made will not be applied to markup. Response was:\n\n" + e + "" );
    }
  },
  putcss: function( css, tag='style', id='IDE_cssscript' ) {
    try {
      const el = document.createElement( tag );
      el.innerHTML = css;
      el.id = id;
      document.head.removeChild( UI.h.el(id) );
      document.head.appendChild( el );
    }
    catch( e ) {
      alert( "CSS contains error(s), any changes made will not be applied to markup. Response was:\n\n" + e + "" );
    }
  },
  pgmarkers: {
    css:       {start: `/` + `*!!!STYLOTRON IDE CSS START!!!*` + `/`,  end: `/` + `*!!!STYLOTRON IDE CSS END!!!*` + `/`,
                regex: /(?<=\/\*!!!STYLOTRON IDE CSS START!!!\*\/)(?:.|\n)*(?=\/\*!!!STYLOTRON IDE CSS END!!!\*\/)/},
    js:        {start: `/` + `*!!!STYLOTRON IDE JS START!!!*` + `/`,   end: `/` + `*!!!STYLOTRON IDE JS END!!!*` + `/`,
                regex: /(?<=\/\*!!!STYLOTRON IDE JS START!!!\*\/)(?:.|\n)*(?=\/\*!!!STYLOTRON IDE JS END!!!\*\/)/},
    html:      {start: `<` + `!--!!!STYLOTRON IDE HTML START!!!--` + `>`, end: `<` + `!--!!!STYLOTRON IDE HTML END!!!--` + `>`, 
                regex: /(?<=<\!--!!!STYLOTRON IDE HTML START!!!--\>)(?:.|\n)*(?=<\!--!!!STYLOTRON IDE HTML END!!!--\>)/},
    txt:       {start: `<` + `!--!!!STYLOTRON IDE PLAINTEXT START!!!`, end: `!!!STYLOTRON IDE PLAINTEXT END!!!--` + `>`, 
                regex: /(?<=<\!--!!!STYLOTRON IDE PLAINTEXT START!!!)(?:.|\n)*(?=!!!STYLOTRON IDE PLAINTEXT END!!!--\>)/,
                commentend: "!!!STYLOTRON IDE COMMENT END!!!", commentendregex: /!!!STYLOTRON IDE COMMENT END!!!/g},
    innertxt:  {start: `<` + `!--!!!STYLOTRON IDE INNERTEXT START!!!--` + `>`, end: `<` + `!!!STYLOTRON IDE INNERTEXT END!!!--` + `>`, 
                regex: /(?<=<\!--!!!STYLOTRON IDE INNERTEXT START!!!--\>)(?:.|\n)*(?=<\!--!!!STYLOTRON IDE INNERTEXT END!!!--\>)/},
    fileregex: /.*(?=[.]\w*$)/,
    titleregex: /(?<=\<title\>).+?(?=\<\/title\>)/
  },
  extractpart: function( text, part ) {
    return SOT.text.extract( text, IDE.pgmarkers[part].regex );
  },
  extracttitle: function() {
    const text = IDE.openhtmlfile ? IDE.openhtmlfile : IDE.save.defaulthtmlfile;
    return SOT.text.extract( text, IDE.pgmarkers.titleregex );
  },
  /*
   * Insertion and file save functions
   */
  save: {
    defaulthtmlfile:
`<!DOCTYPE html>\n` +
`<html>\n` +
`<head>\n` +
`  <meta charset="utf-8">\n` +
`  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n` +
`  <title>Stylotron-IDE Generated Page</title>\n` +
`  <meta content="" name="description">\n` +
`  <meta content="" name="author">\n` +
`  <` + `style>\n` +
`body {margin:0; padding:0; white-space:pre-wrap; background-color:#eee; font-family:sans-serif; font-size:0.98em;}\n\n` +
`/` + `*!!!STYLOTRON IDE CSS START!!!*` + `/` + `/` + `*!!!STYLOTRON IDE CSS END!!!*` + `/` + 
`\n  <` + `/style>\n` +
`  <` + `script>\n` +
`const UserDocument = {FOLDED:true, onload:function(){}};\n\n` +
`document.addEventListener( 'DOMContentLoaded', UserDocument.onload );\n\n` +
`/` + `*!!!STYLOTRON IDE JS START!!!*` + `/` + `/` + `*!!!STYLOTRON IDE JS END!!!*` + `/` +
`\n  <` + `/script` + `>\n` +
`</head>\n` +
`<body class="FOLDED">` +
`<` + `!--!!!STYLOTRON IDE HTML START!!!--` + `>` + `<` +`!--!!!STYLOTRON IDE HTML END!!!--` + `>` +
`</body>` +
`</html>` +
`<` + `!--!!!STYLOTRON IDE PLAINTEXT START!!!` + `!!!STYLOTRON IDE PLAINTEXT END!!!--` + `>`,
    mkpage: function( plaintext ) {
      function ins( part, output, input ) {
        if (!input)
          input = IDE.views[part].editedtext;
        ret.inserted[part] = IDE.extractpart( openpage, part ) !== null;
        if (ret.inserted[part])
          output = output.replace( IDE.pgmarkers[part].regex, input );
        return output;
      }
      const ret = {inserted:{}};
      const markup = IDE.editor.texteditor.el().innerHTML;
      ret.output = IDE.openhtmlfile ? IDE.openhtmlfile : IDE.save.defaulthtmlfile;
      const openpage = ret.output;
      ret.output = ins( 'css', ret.output );
      ret.output = ins( 'js', ret.output );
      ret.output = ins( 'html', ret.output, markup );
      ret.output = ins( 'innertxt', ret.output, SOT.text.raw2HTML(plaintext) );
      ret.output = ins( 'txt', ret.output, plaintext.replace(/-->/g, IDE.pgmarkers.txt.commentend) );
      return ret;
    },
    savefilemsgs: {
      htmlopt: "Open page will be updated and saved",
      html:    "Default page will be updated and saved",
      txt:     "Plaintext (.txt) will be saved",
      js:      "Patterns (.js) will be saved",
      css:     "Styles (.css) will be saved",
      txtin:   "Plaintext will be exported to .txt file (open page can be saved in Markup view)",
      jsin:    "Patterns will be exported to .js file (open page can be saved in Markup view)",
      cssin:   "Styles will be exported to .css file (open page can be saved in Markup view)",
      jssave:  "Changes to JS can be saved separately in Patterns editor",
      csssave: "Changes to CSS can be saved separately in Styles editor"
    },
    updatesavedialog: function( view=IDE.view, updatefilename=true, title ) {
      var viewmsg = view;
      if (view != 'html' && IDE.ispartembedded( view ))
        viewmsg = view + 'in';
      if (updatefilename)
        UI.h.put( 'IDE_savefile-filename', IDE.getfilename() );
      if (viewmsg == 'html' && IDE.openhtmlfile)
        viewmsg = 'htmlopt';
      UI.h.setdisplay( 'IDE_savefile-titlesec', view == 'html' ? 'block' : 'none' );
      UI.h.el('IDE_savefile-msg').innerHTML = IDE.save.savefilemsgs[viewmsg];
      if (title)
        UI.h.put('IDE_savefile-title', title );
    },
    savedflag: 'saved',
    save2file: function() {
      function setsaved( view ) {
        if (IDE.viewchanged( true, view ))
          IDE.views[view].changed = IDE.save.savedflag;
      }
      try {
        var fn = UI.h.get( 'IDE_savefile-filename' );
        var t = IDE.editor.texteditor.get();
        if (IDE.view == 'html') {
          const ret = IDE.save.mkpage( t );
          t = ret.output;
          setsaved( 'txt' );
          //IDE.resetfilename( 'txt' );
          if (ret.inserted['js']) {
            setsaved( 'js' );
            //IDE.resetfilename( 'js' );
          }
          else
            if (IDE.viewchanged( true, 'js' ))
              alert( IDE.save.savefilemsgs['jssave'] );
          if (ret.inserted['css']) {
            setsaved( 'css' );
            //IDE.resetfilename( 'css' );
          }
          else
            if (IDE.viewchanged( true, 'css' ))
              alert( IDE.save.savefilemsgs['csssave'] );
          //if (!IDE.openhtmlfile)
            //IDE.openhtmlfile = IDE.save.defaulthtmlfile;
          t = t.replace( IDE.pgmarkers.titleregex, UI.h.get('IDE_savefile-title') );
        }
        setsaved( IDE.view );
        IDE.editor.texteditor.changed( IDE.views[IDE.view].changed );
        TextFileIO.save( 'IDE_savefile-save', fn, t );
        IDE.save.updatesavedialog( undefined, false );
      }
      catch( e ) {
        alert( "Unable to save file, response was: " + e );
      }
    },
    savefile: function( e ) {
      IDE.save.save2file();
      return true;
    }
  },
  /*
   * open and extraction functions
   */
  open: {
    extractmsgs: {
      txt:       {notin:   "HTML file contains no extractable plaintext",
                  nottext: "Opened HTML file contained no extractable plaintext\n"},
      js:        {notin:   "HTML file contains no extractable JS",
                  nottext: "/* Opened HTML file contained no extractable pattern series */\nUserDocument.patternseries = {}\n"},
      css:       {notin:   "HTML file contains no extractable CSS",
                  nottext: "/* Opened HTML file contained no extractable styles */\n"},
      html:      {notin:   "HTML file contains no extractable plaintext"}
    },
    putintoeditor: function( text, insert=false, fn ) {
      if (insert)
        //IDE.editor.selections.inserttext( text, {action:"insertFromOpenInsert"}, undefined, 'selection-open' );
        IDE.editor.texteditor.insert( text, {action:"insertFromOpenInsert"} ); //(apply browser's selection)
      else {
        var title;
        IDE.editor.search.clear( false );
        IDE.editor.texteditor.put( text, {action:"insertFromOpenPut"} );
        if (IDE.view == 'html') {
          IDE.editor.components.get('undoredo').clear();
          title = IDE.extracttitle();
          IDE.views[IDE.view].changed = false;
          IDE.editor.texteditor.changed( false );
        }
        else {
          IDE.views[IDE.view].changed = IDE.ispartembedded( IDE.view );
          IDE.editor.texteditor.changed( IDE.ispartembedded(IDE.view) );
        }
        IDE.setfilename( fn );
        IDE.save.updatesavedialog( IDE.view, undefined, title );
      }
    },
    extractpart: function( part, html ) {
      IDE.views[part].extractedtext = SOT.text.extract( html, IDE.pgmarkers[part].regex );
      if (IDE.views[part].extractedtext) {
        if (part == 'txt')
          IDE.views[part].extractedtext = 
                           IDE.views[part].extractedtext.replace( IDE.pgmarkers.txt.commentendregex, "-->" );
        IDE.views[part].editedtext = IDE.views[part].extractedtext;
      }
      else {
        if (IDE.view == 'html')
          IDE.views[part].editedtext = IDE.open.extractmsgs[part].nottext;
        var m = IDE.open.extractmsgs[part].notin;
        if (IDE.view == 'html')
          if (part == 'js')
            m += " (JS can be opened separately in Patterns view)";
          else
            if (part == 'css')
              m += " (CCS can be opened separately in Styles view)";
        alert( m );
      }
      IDE.resetfilename( part );
      IDE.views[part].scrollpos = {start:0, end:0};
      IDE.views[part].changed = false;
      return IDE.views[part].extractedtext;
    },
    extractpg: function( html, part ) {
      if (!html || typeof html != 'string')
        return null;
      var parttext = null, plaintext = null, jstext = null, csstext = null;
      const prevextractedtext = IDE.views[part].extractedtext;
      if (part == 'html' || part == 'txt') {
        /* extract plaintext */
        plaintext = IDE.open.extractpart( 'txt', html );
        parttext = IDE.views['txt'].editedtext;
        if (plaintext === null)
          return null;
      }
      if (part == 'html' || part == 'css') {
        /* extract css */
        parttext = IDE.open.extractpart( 'css', html );
        csstext = IDE.views['css'].editedtext;
      }
      if (part == 'html' || part == 'js') {
        /* extract js */
        parttext = IDE.open.extractpart( 'js', html );
        jstext = IDE.views['js'].editedtext;
      }
      if (part == 'html') {
        IDE.views[part].changed = false;
        IDE.openhtmlfile = html;
        parttext = plaintext;
        /* put parts in browser */
        if (csstext)
          IDE.putcss( csstext, 'style' );
        if (jstext) {
          UserDocument.patternseries = {};
          IDE.putcode( jstext, 'script' );
          /* replace patterns in styler */
          const patterns = IDE.editor.styler.patterns();
          patterns.clear();
          patterns.add( UserDocument.patternseries );
        }
      }
      else
        IDE.views[part].extractedtext = prevextractedtext;
      return parttext;
    },
    openfile: function( f, insert ) {
      function callback( fn, text, filetype ) {
        if (IDE.view == 'html' || filetype == 'text/html')
          text = IDE.open.extractpg( text, IDE.view );
        if (insert || (IDE.view != 'html' && filetype == 'text/html'))
          fn = null;
        if (text != null && typeof text == 'string')
          IDE.open.putintoeditor( text, insert, fn );
      }
      TextFileIO.open( callback, f );
    },
    changedwarnmsg: function( testchanged, partsmsg, partsmsg2 ) {
      var msg = "";
      if (IDE.view == 'html') {
        function tag( view, name ) {
          if (IDE.viewchanged( testchanged, view )) {
            if (IDE.ispartembedded( view ))
              return "";
            else
              return "<br>&nbsp;&nbsp;" + name;
          }
          return "";
        }
        msg += tag( 'js', "Patterns" );
        msg += tag( 'css', "Styles" );
        if (msg) {
          if (IDE.viewchanged( testchanged ))
            msg = "<br>&nbsp;&nbsp;Open page" + msg;
          msg = partsmsg + "<br>" + msg + "<br><br>" + partsmsg2;
        }
        else
          if (IDE.viewchanged( testchanged ) ||
              IDE.viewchanged( testchanged, 'js' ) ||
              IDE.viewchanged( testchanged, 'css' ))
            msg = partsmsg + " open page " + partsmsg2;
      }
      return msg;
    },
    changedmsg: function() {
      return IDE.open.changedwarnmsg( true, 
                  "Changes made to", "will be lost" );
    },
    verifymsg: function() {
      return IDE.open.changedwarnmsg( IDE.save.savedflag, 
                  "Verifying that changes made to", 
                  "have been successfully saved is recommended before continuing" );
    },
    setaccept: function( openid ) {
      var a = 'text/html';
      if (IDE.view == 'txt')
        a = 'text/*';
      if (IDE.view == 'js')
        a = 'application/javascript, text/html';
      if (IDE.view == 'css')
        a = 'text/css, text/html';
      UI.h.el( openid ).accept = a;
    },
    togglesavechanges: function( isopening ) {
      if (!IDE.open.asksavechanges()) {
        IDE.open.setaccept( 'IDE_open' );
        TextFileIO.selfile( 'IDE_open' );
        return true;
      }
    },
    savechangesresponse: function( e ) {
      if (e.id == 'IDE_savechanges-okbtn') {
        IDE.open.setaccept( 'IDE_savechanges-open' );
        TextFileIO.selfile( 'IDE_savechanges-open' );
      }
      return true;
    },
    asksavechanges: function() {
      var msg = IDE.open.changedmsg();
      if (!msg)
        msg = IDE.open.verifymsg();
      if (msg)
        UI.h.el('IDE_savechanges-msg').innerHTML = msg;
      return msg;
    },
    selfile: function( oid ) {
      if (oid == 'IDE_openinsert' && IDE.view != 'html') {
        IDE.open.setaccept( oid );
        TextFileIO.selfile( oid );
      }
    }
  }
}
const UserDocument = {};
document.addEventListener( 'DOMContentLoaded', IDE.onload );
window.addEventListener( 'beforeunload', IDE.onbeforeunload );
  </script>

<script id="IDE_patternscript">/* (pasted from slylotron-samplepatterns.js) */

/*
 * Patterns Shared by Stylotron Demos and Project Documents
 * cc0 (public domain) v.010 September 2025
 * Stylotron project @ github.com/gregsidal
 *
 * Pattern series must be in 'UserDocument' namespace to be visible to IDE
 * Functions and other javascript can also be added to UserDocument
 * Patterns without g flag in regex are ignored
 *
 * Patterns that will mark up as images, form controls, etc. must be high enough in the pattern order to 
 * prevent them from being segmented
 *
 * Regexs can be tested and optimized using search in Plaintext view
 *   shape of match's endcaps will reveal whether line feeds at match's beginning or end are captured by regex
 *   the browser may timeout when iterating through the matches of some poorly designed regex's
 */
UserDocument.patternseries = {
  /* 
   * whole document container
   */
  document:                {regex: /(?:.*(\n|$))*/g, htmltag: 'div'},
  /*
   * inner containers
   */
  'block multiline':       /.+(?:\n(?!\n).+)+/g,
  'block singleline':      /(?<=\n\n+|^\n*).+(?=\n\n+|\n*$)/g,
  codeblockcontainer:      {regex: /(?:.*(?:[\{<=\\]|\/\*).*(\n(?!\n).+)+)|(?:(?<=\n\n+) +.+(?=$|\n\n+))/g, htmltag: 'div'},
  'codeblock multiline':   {regex: /.*(?:[\{<=\\]|\/\*).*(\n(?!\n).+)+/g, htmltag: 'div'},
  'codeblock snippet':     {regex: /(?<=\n\n+) +.+(?=$|\n\n+)/g, htmltag: 'div'},
  paragraph:               /(?<=\n\n+|^\n*)([A-Z].+[.?!:][ ]*)+.*(?=(?:\n\n+|\n*$))/g,
  heading:                 /(?<=^\n*|\n\n+)(?:[0-9. -]+)*(?:(?:(?:[A-Z0-9@#$][a-z0-9-'",!?]*)|o[rnf]{0,1}|t[o]{0,1}|th[e]{0,1}|a|an|as|and|by|vs|i[sn]*|f|fo|for) *)+(?=\n\n+)/g,
  footnote:                {regex: /(?<=\n)\d +.+(?=$|\n)/g, 
                            htmlattrs: {id: /\d/g}},
  line:                    /.+/g,
  /*
   * patterns that allow buttons (_#...#_) and inputs (_$...$_) to be inserted inline
   * while editing (the default CSS causes the tags to disappear when .FOLDED;
   * controls in real world apps would usually use specialized patterns)
   */
  button:                  {regex: /(?<=_#).+?(?=#_)/g, htmltag: 'button',
                            htmlattrs: {id: "$_&", onclick: 'UserDocument.buttononclick(this)'}},
  inputcontainer:          {regex: /_\$.+?\$_/g, htmltag: 'label',
                            htmlattrs: {id: /(?<=_\$).+?(?=\$_)/g}},
  input:                   {regex: /(?<=_\$.+?)\$_/g, htmltag: 'input', htmltagend: '',
                            htmlattrs: {type: 'text', onchange: 'UserDocument.inputonchange(this)'}},
  /*
   * image in CSS (uses :before, recommended way to handle images)
   */
  'image sample':          {regex: "sample image", htmltag: 'div'},
  /*
   * links to page (caveat: won't capture file names containing spaces)
   */
  'link page':             {regex: /[-\w]+\.html/g, htmltag: 'a', 
                            htmlattrs: {href: "$_&", target: "_blank"}},
  /*
   * links to lib sources
   */
  'link lib main':         {regex: /lib\/(?:\w|\-)+\.(?:js|css)/g, htmltag: 'a', 
                            htmlattrs: {href: "$_&", target: "_blank", tooltip: "view source"}},
  'link lib':              {regex: /[Ss]tylotron-\w*\.(?:js|css)/g, htmltag: 'a', 
                            htmlattrs: {href: "$_&", target: "_blank", tooltip: "view source"}},
  /*
   * patterns that allow italics (_`...`_), bold (_"..."_) and footnote refs (^num) to be
   * added inline while editing (the default CSS causes the tags to disappear when .FOLDED)
   */
  'tag inline':            /_`|`_|_"|"_|_#|#_|_\$|\$_|_@|@_/g,
  'tag inline footref':    /\^(?=\d)/g,
  italic:                  /(?<=_`).*?(?=`_)/g,
  bold:                    /(?<=_").*?(?="_)/g,
  /*
   * comment atoms
   */
  'comment html':          /(?<=^|\W)\<\!--(?:.|\n)+?--\>/g,
  'comment js':            /(?<=^|\W)\/\*(?:.|\n)+?\*\/|\/\/.*/g,
  /* 
   * regexs
   */
  regex:                   /(?<=\W)\/.+\/[gmis]+(?=[ .,;\n\]\}\)])/g,
  regexslashed:            /(?<=\W)\/.+\/(?=[gmis]+[ .,;\n\]\}\)])/g,
  regexpattern:            /(?<=\W\/).+(?=\/[gmis]+[ .,;\n\]\}\)])/g,
  /*
   * code tags
   */
  'tag js':                /(?<=^|[\{\[\(\s,])[\w-]+(?=:)/g,
  'tag json':              /(?<=^|\W)'[\w- ]+'(?=:)/g,
  'tag html':              /(?<=<\/{0,1})\w+(?=[\s\[>])/g,
  /*
   * quoted
   */
  'quoted single':         /(?<=^|\W)'.*?'(?=\W)/g,
  'quoted double':         /(?<=^|\W)".*?"(?=\W)/g,
  /*
   * number-like atoms
   */
  'number dec':            /(?<=^|[^\w.#])[+|-]{0,1}(?:\d+[.]\d+|\d+)(?=$|[^\w.]|\.[ \n]+|px\W|em\W|rem\W)/g,
  'number hex':            /(?<=#)[A-Fa-f0-9]+(?=$|\W)/g,
  'number htmlentity':     /&(?:[a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/g,
  numberprefix:            /[@#$](?=[A-Fa-f0-9]+(?:$|\W))/g,
  footnoteref:             {regex: /(?<=\^)\d/g, htmltag: 'a', htmlattrs: {href: "#$_&"}},
  /*
   * logo
   */
  logoleft:                "STYLO",
  logoright:               "OTRON",
}
/*
 * sample input event handler
 */
UserDocument.inputonchange = function( inputelem ) {
  if (UserDocument.FOLDED) {
    const id = inputelem.parentNode.id;
    alert( `Contents of '` + id + `' is "` + inputelem.value + `"` );
  }
}
/*
 * sample button event handler
 */
UserDocument.buttononclick = function( buttonelem ) {
  if (UserDocument.FOLDED) {
    const id = buttonelem.id;
    alert( `Button '` + id + `' clicked` );
  }
}

</script>

</head>

<body class="IDE_body" id="IDE_body">


<div class="IDE_panelcontainer" id="IDE_panelcontainer"><div class="IDE_panel UNFOLDED" id="IDE_stylotroncontainer">STYLOTRON  IDE


Stylotron (lib/stylotron.js) uses patterns in plaintext documents to dynamically mark them up with structured html.  The demo (stylotron-demo.html) explains stylotron's markup generation process.

Markup is generated from plaintext and patterns, and styled with CSS.  This IDE provides editors for each of these, as well as a WYSIWYG editor for the styled document.  The menu that drops down from the eye icon toggles between the different editors.  When the WYSIWYG editor is active, the generated markup can be inspected using the browser's developer tools.

This intro document is marked up with patterns preloaded from stylotron-samplepatterns.js, and styled with CSS preloaded from stylotron-samplestyles.css.  The sample patterns and styles are summarized further below.


Opening and Saving Files

The document icons are used to open files into and save the contents of the active editor^1.

When the Markup editor is active, html files are opened and saved.  The plaintext, generated markup, patterns, and/or CSS are inserted into the open page when it is saved (a default container page is active when no other page is open).  When a saved page is later reopened, the various parts will be retrieved from it.

Exactly which parts are extracted from an html file when it is opened depends on what _`insertion/extraction points`_^2 are present in the page, and these points also determine which parts are reinserted when it is saved.  This intro document can be saved to a file and the source inspected to see how insertion/extraction points are defined and placed.

Plaintext, JS and CSS files can be opened and saved using the corresponding editors.  When one of these editors is active, only the part applicable to that editor will be extracted when an html file is opened.


Editable vs Output CSS

Elements like popups, fixed toolbars, independently scrollable blocks, etc., are not WYSIWYG editable.  To account for this, the IDE treats a document like origami: different CSS selectors are applied to the editable, or unfolded document, and the output, or folded one^3.

The selectors make it possible to define styles that act to fold or unfold the document, for example:

.UNFOLDED .toolbar {position:relative;}
.FOLDED .toolbar {position:fixed;}

The sample CSS employs a few folding tweaks, which can be examined by toggling to the Styles editor^4.


Regular Expressions

Regular expressions specify what parts of a text a pattern should capture.

Regex's can be tested and optimized using the search function in the Plaintext editor^5.


Sample Patterns and Styles

The 'block' pattern captures blocks of text separated by two or more linefeeds.

The 'codeblockcontainer' pattern captures indented single-line blocks, or blocks containing multiple lines where the first line includes a _`code-like`_ character such as '{', '/', or '='.

The 'codeblock multiline' and 'codeblock snippet' patterns capture the two types of code blocks.  They are styled to be horizontally scrollable; a left margin leaves room for line numbers in multi-line code blocks.

{this is a multi-line 
code block}

 This is a code snippet

this is not a code block 
(contains consecutive lines, 
but the first line does not 
include a code-like character)

this is not a code snippet (it is not indented)

The 'paragraph' pattern captures blocks with only one line that include sentence-like formations (a sentence starts with a capitalized word and ends with punctuation).

The 'heading' pattern captures single-line blocks that do not end in a period where significant words are capitalized.

This is not a heading (includes non-capitalized significant words), nor is it a paragraph (there is no sentence-like punctuation)

The 'line' pattern captures all lines.  Lines inside code blocks are numbered using a CSS counter.

Atomic patterns include /regular expressions/g, 'quoted tags', "quoted text", /*code comments*/, &lt;!--html comments--&gt;, and numbers like 0.123, -1, +5.67, and #a345.


Known Issues

While using recent versions of chromium-based browsers on Android: when selecting a range in the code editors (Patterns or Styles), selection may be dropped when range's starting position is flush left.  Selection start may also snap to top when the selection height is greater than editor height (select, scroll, stretch selection).


Notes

1  The filled document icon is used to paste the contents of a file at the position of the the caret or current selection.

2  Sample patterns are provided that allow _`italics`_, _"bold"_, and footnote links^1 to be tagged while editing.  The tags are hidden by the CSS when the document is folded.

3  While it is possible to automatically create an unfolded version of the CSS, this IDE does not include code to do that at this time.

4  The WYSIWYG editor currently doesn't run in an iframe, so some styles such as 'position:fixed' used without 'FOLDED' may cover up the IDE's toolbar or make the IDE unusable in other ways.

5  The shape of a highlight's endcaps can be used to determine whether a match begins or ends with line feeds (often not desirable).  The browser may timeout when iterating through the matches of some poorly designed regex's.

</div></div>


<div class="IDE_toolbar" id="IDE_toolbar"><div>

  <div class="popup fullwidth closed" id="IDE_searchpopup">
    <div class="list bar">
      <div>
        <input type="text" id="search-find" value="" placeholder="String or /RegEx/"/>
        <button class="dark" id='search-nextbtn'>&gt;</button>
        <button class="dark" id='search-scrolltobtn'>&#x2022;</button>
        <button class="dark" id='search-prevbtn'>&lt;</button>
        <button class="dark" id='search-clearbtn'>C</button>
      </div>
      <div>
        <input type="text" id="search-replace" value=""/>
        <button class="dark" id='search-replacebtn'>Replace</button>
        <button class="dark" id='search-replaceallbtn'>All</button>
      </div>
    </div>
  </div>

  <div>

    <div class="popuppositioner" id="IDE_selectview">
      <button class="icon" id="IDE_selectviewbtn"><span class="icon view"></span></button>
      <div id="IDE_selectviewpopup" class="popup left closed">
        <div class="list menu left">
          <label class="open" id="html">Markup</label>
          <label class="closed" id="txt">Plaintext</label>
          <label class="closed" id="js">Patterns</label>
          <label class="closed" id="css">Styles</label>
        </div>
      </div>
    </div>

  </div>

  <div>

    <div class="popuppositioner" id="IDE_savechanges">
      <button class="icon" id="IDE_savechanges-togglebtn"><span class="icon openfile"></span></button>
      <div id="IDE_savechanges-popup" class="popup closed">
        <div class="list dialog">
          <div><span class="warn" id="IDE_savechanges-msg"></span></div>
          <div class="btnbank"><button id='IDE_savechanges-okbtn'>Continue</button>
          <input style="display:none;" type="file" accept="text/*" id="IDE_savechanges-open" onchange="IDE.open.openfile(this.files[0]);">
          <button id='IDE_savechanges-cancelbtn'>Cancel</button></div>
        </div>
      </div>
    </div>
    <input style="display:none;" type="file" accept="text/*" id="IDE_open" onchange="IDE.open.openfile(this.files[0]);">

    <div class="popuppositioner">
      <button class="icon" id="IDE_openinsertbtn" onclick="IDE.open.selfile('IDE_openinsert')" disabled><span class="icon openfileinsert"></span></button>
    </div>
    <input style="display:none;" type="file" accept="text/*" id="IDE_openinsert" onchange="IDE.open.openfile(this.files[0],true);">

    <div class="popuppositioner" id="IDE_savefile">
      <button class="icon" id="IDE_savefile-togglebtn"><span class="icon savefile"></span></button>
      <div id="IDE_savefile-popup" class="popup closed">
        <div class="list dialog">
          <div id="IDE_savefile-filenamesec"><label><span>Save To File</span>
            <input type="text" class="short" id="IDE_savefile-filename"/>
          </label></div>
          <a href="" download="*.txt" style="display:none;" id="IDE_savefile-save"></a>
          <div id="IDE_savefile-titlesec"><label><span>Page Title</span>
            <input type="text" class="short" id="IDE_savefile-title" value="StylotronIDE Default Page"/>
          </label></div>
          <div class="btnbank"><button id='IDE_savefile-savebtn'>Save</button></div>
          <div><span><i id="IDE_savefile-msg"></i></span></div>
        </div>
      </div>
    </div>

  </div>

  <div>

    <label class="toggle"><input type="checkbox" id="texteditor-wraptoggle" checked/><span>wrap</span></label>
    <div class="popuppositioner">
      <button class="icon" id="undoredo-undobtn"><span class="icon small undo"></span></button>
    </div>
    <div class="popuppositioner">
      <button class="icon" id="undoredo-redobtn"><span class="icon small redo"></span></button>
    </div>
    <div class="popuppositioner" id="IDE_search">
      <button class="icon" id="IDE_searchbtn"><span class="icon small search"></span></button>
    </div>

  </div>

</div></div>

</body>
</html>
