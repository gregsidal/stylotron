<!DOCTYPE html>
<!--
  texteditor.html

    Text editor with RegEx highlighter
    RegEx replace
    Undo/redo
    Font picker

  cc0 (public domain) v.010 June 2025, latest version @ github.com/gregsidal
-->

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Editor</title>
  <meta content="in-browser text editor with regex find/replace, font picker, undo/redo" name="description">
  <meta content="" name="author">

  <style>

*, *::before, *::after {box-sizing:border-box; text-size-adjust:none; outline:none;}
div, textarea {display:block; margin:0; border:0; border-radius:0; padding:0;}
span, button, input, label {display:inline-block; border-radius:0; vertical-align:middle;}

/* 
 * framing for full screen app with top toolbar
 */
body {
  display:block; position:fixed; left:0; top:0; right:0; bottom:0; margin:0; padding:0;
  font-family:sans-serif; font-size:0.85em; color:#444; background-color:#c8c8c8;
}
.toolbar {position:absolute; left:0; top:0; right:0; bottom:auto;}
.toolbar {height:2.2em; background-color:#aaaaaa /*#aebeae*/; transition:height 0.5s ease-in;}
.toolbar.open {height:4.5em;}
.ground {position:absolute; left:0; right:0; bottom:0; background-color:#aaaaaa;}
.ground {top:2.2em; transition:top 0.5s ease-in;}
.ground.open {top:4.5em;}
@media all and (max-width:999px) {
  /*body {font-size:0.94em;}*/
  .ground {top:4.3em;}
  .ground.open {top:8.5em;}
  .toolbar {height:4.3em; background-color:#ececec;}
  .toolbar.open {height:8.5em;}
}
@media all and (max-width:699px) {
  .ground.open {top:8.5em;}
  .toolbar.open {height:8.5em;}
}
/*
@media all and (max-width:499px) {
  body {font-size:0.94em;}
}
*/
@media print {
  .toolbar {display:none;}
}

/*
 * editor with framing
 */
.backing, .editor {background-color:transparent;}
.backing {position:absolute; left:0; top:0; right:0; bottom:0;}
.editorpositioner {
  max-width:100%; height:100%; margin:0 auto; font-size:115%; width:52em;
}
.editorcontainer {position:relative; width:100%; height:100%; background-color:#edd;}
/*.editor {height:100%; margin-left:1.4em; background-color:white;}*/
.markup {
  position:relative; background-color:white;
  height:100%; overflow:auto; resize:none;
  padding:0.6em; 
  /*padding-left:1.6em; (will set on unwrap)*/
  font-family:sans-serif; font-size:100%; color:#333;
  /*white-space:pre-wrap; word-wrap:break-word;*/
  caret-color:red;
}
/*.markup::selection, .markup *::selection {background-color:rgba(100,130,200,0.25);}*/
@media print {
  body, .ground, .backing, .editorcontainer {position:static; margin:0; padding:0; width:100%;}
}

mark {
  border-radius:0; color:inherit; /*background-color:#b1d5e5;*/ background-color:transparent;
}


.line.L {counter-increment:line;}

/*
.line.L:before {
  content:counter(line);
  position:absolute; left:0.5em; margin-top:0.2em; width:2.8em; text-align:center;
  font-family:sans-serif; font-size:7px; font-weight:bold; color:#855; opacity:0.8;
}
*/

.line.L:before {
  content:counter(line);
  position:absolute; left:0.5em; margin-top:0.2em; width:2.8em; text-align:center;
  font-family:sans-serif; font-size:7px; font-weight:bold; color:#a77;
}


/* search highlights */
.search-match {background-color:#f4ecd8 !important;}
@keyframes replacedflash {
    0% {background-color:rgba(164,200,164,0.6);}
   30% {background-color:transparent;}
   60% {background-color:rgba(164,200,164,0.6);}
   90% {background-color:transparent;}
}
.search-replaced {
  background-color:transparent; animation-name:replacedflash; animation-delay:0.0s; animation-duration:0.7s;
}
.search-match .search-current {
  background-color:rgba(230,190,190,0.99);
}
@keyframes currentflash {
    0% {background-color:rgba(230,190,190,0.99);}
   50% {background-color:transparent;}
  100% {background-color:rgba(230,190,190,0.99);}
}
.search-match .search-current.search-currentflash {
  animation-name:currentflash; animation-delay:0.0s; animation-duration:0.7s;
}
@keyframes currentblink {
    0% {background-color:rgba(230,190,190,0.99);}
   25% {background-color:transparent;}
   50% {background-color:rgba(230,190,190,0.99);}
   75% {background-color:transparent;}
  100% {background-color:rgba(230,190,190,0.99);}
}
.search-match .search-current.search-currentblink {
  animation-name:currentblink; animation-delay:0.0s; animation-duration:1.0s;
}


mark.L {border-top-left-radius:0.25em; border-bottom-left-radius:0.25em;}
mark.R {border-top-right-radius:0.25em; border-bottom-right-radius:0.25em;}

/* selection when not focused */
.texteditor-selected {background-color:rgba(210,210,225,0.5);}
mark.texteditor-selected.L, mark.texteditor-selected.R {border-radius:0;}

/* custom selection when open insert */
.texteditor-selected-open {background-color:rgba(255,255,200,0.25); /*background-color:rgba(243,240,195,0.5);*/}
mark.texteditor-selected-open.R, mark.texteditor-selected-open.L {border-radius:0;}

/*
 * menus
 */
.menu, .menusection {position:absolute; left:0; right:0; top:0; bottom:auto; height:2.25em; overflow:hidden;}
.menu.lower {top:2.23em; height:0; visibility:hidden; transition:visibility 0.5s ease-in, height 0.5s ease-in;}
.menu.lower.open {height:2.26em; visibility:visible;}
.menusection.left {right:auto;}
.menusection.right {left:auto; right:0;}
.menu.lower > .menusection.right {padding-top:0.25em; background-color:#8d8b8b; /*background-color:#aebeae;*/}
.menusubsection {position:relative; display:inline-block;}
.menusubsection > .content {height:2.2em; padding:0.1em 0.3em; background-color:#dddddd;}
.menusubsection > .content.small {padding:0.25em 0.3em;}
.menu.lower > .menusection > .menusubsection > .content {background-color:transparent;}
@media all and (max-width:999px) {
  .menu.lower {background-color:#ffffff;}
  .menu.lower > .menusection.left {display:none;}
  .menu.lower > .menusection.right {left:0; right:0;}
  .menu.lower > .menusection > .menusubsection > .content {padding-left:0.5em;}
}
@media all and (max-width:999px) {
  .menu.open {height:4.3em;}
  .menu.lower {top:4.3em;}
  .menusection.left {right:0; top:0;}
  .menusection.right {left:0; top:2.25em;}
  .menu.lower > .menusection.right {top:0;}
  .menusubsection > .content {background-color:#ececec;}
  .menusubsection > .content.small {padding:0.1em 0.1em;}
  .menusubsection.right, .content.right {position:absolute; left:auto; right:0;}
  .menusubsection.full {position:absolute; left:0; right:0;}
  .menusubsection > .content {padding:0.1em 0;}
}
@media all and (max-width:999px) {
  .menu.lower.open {height:4.3em; visibility:visible;}
  .menu.lower > .menusection.right {height:4.3em;}
  .menu.lower > .menusection.right > .menusubsection {display:block; top:-0.2em;}
  .menu.lower > .menusection.right > .menusubsection:first-child {display:block; top:0.1em;}
}
@media all and (max-width:699px) {
  .menu.lower.open {height:4.3em; visibility:visible;}
  .menu.lower > .menusection.right {height:4.3em;}
  .menu.lower > .menusection.right > .menusubsection {display:block; top:-0.15em;}
  .menu.lower > .menusection.right > .menusubsection:first-child {display:block; top:0.3em;}
}
@media all and (max-width:499px) {
  .menu.lower > .menusection.right {left:0;}
}

/*
 * popups
 */
.popup {
  position:absolute; left:auto; top:auto; right:0; bottom:0; padding:0.9em; background-color:#eee;
  transition: visibility 0.5s ease-in, opacity 0.5s ease-in;
}
.popup.open {visibility: visible; opacity: 1.0;}
.popup.closed {visibility: hidden; opacity: 0.0;}
@media all and (max-width:349px) {
  .popup {left:0;}
}
@media print {
  .popup {display:none;}
}

/*
 * heads, msgs, etc.
 */
h3 {display:inline-block; margin:0; padding-right:0.7em;}
.list {max-height:10em; overflow-y:auto;}
.list > div {margin-right:2em; margin-bottom:0.5em;}
.p {display:block; margin-bottom:0.5em;}
.p:first-child, .p:last-child {margin-top:1.3em;}
.p:empty {display:none;}
.foot {padding-top:1.9em;}
tt, .big {font-size:115%;}
.tiny {font-size:85%;}
.tinyer {font-size:80%;}

/*
 * buttons
 */
/*
.btnbank {margin:0 0.2em;}
*/
button, .clickable {
  user-select:none; cursor:pointer; border:0; border-radius:0.3em; opacity:0.95;
  transition:background-color 0.3s ease, color 0.3s ease;
}
button {
  border:1px solid #ccc;
  min-width:30px; padding:0.2em 0.3em; background-color:transparent; /*#7c6e8b;*/ color:white;
  letter-spacing:0.1em; vertical-align:middle;
}
/*
@media all and (max-width:499px) {
  button {min-width:20px;}
}
*/
/*
button:not(.ctl) {font-size:0.9em;}
*/
button:active, .clickable:active {color:rgb(230,200,120);}
button:disabled, .clickable:disabled {opacity:0.35; cursor:default;}
button.dark {min-width:34px; border:1px solid #aaa; font-size:88%; color:white;}
@media all and (hover:hover) {
  button:hover, button.ctl:hover, .clickable:hover {
    opacity:1.0;
    background-color:rgba(210,120,120,0.4);
  }
  button:disabled:hover {
    opacity:0.35;
    background-color:transparent;
  }
  button.open:hover, .clickable.open:hover {
    background-color:#aebeae;
  }
}
@media all and (max-width:699px) {
  button.dark {font-size:75%;}
}
@media print {
  button {display:none;}
}

/*
 * icon and text buttons
 */
.clickable {padding-left:0.1em; padding-right:0.1em;}
button.ctl, .clickable {
  border:0; background-color:transparent; color:#333;
}
button.open, button.ctl.open, .clickable.open {background-color: /*rgba(80,160,80,0.4);*/ #aebeae;}
button.ctl {
  margin:0 0.2em; border:0; padding-top:0.2em;
}
button.text.baseline {vertical-align:baseline; font-weight:bold; margin-left:0;}
button.larger {font-size:110%;}
button.large  {font-size:105%;}
button.tiny {font-size:90%;}
button.tinyer {font-size:82%;}
button.icon.slim {margin-left:0;}
@media all and (max-width:999px) {
  /* button.ctl {margin:0 0.4em;} */
  button.ctl.text:first-child {margin-left:0.06em;}
}
.clickable.font {min-height:1em;}
.font > .fontname {vertical-align:middle;}

/*
 * inputs
 */
input {vertical-align:middle;}
input[type="text"] {outline:none; margin:0 0.4em; width:26em; padding-top:0.05em;}
input[type="text"] {border:1px solid #ddd; font-family:monospace; text-overflow:ellipsis; background-color:rgb(248,248,248);}
input[type="text"]:focus, input[type="text"]:hover {background-color:#fff;}
input[type="checkbox"] {cursor:pointer; margin-left:0.4em; margin-right:0.2em; width:0.87em; height:0.87em;}
input[type="text"]:disabled {background-color:rgb(240,240,240);}
input[type="text"].inpctl.short {border-color:#8d8b8b;}
.tag {font-size:0.75em; margin-right:0.5em;}
@media all and (max-width:999px) {
  input[type="text"].inpctl.short {width:32em; /*margin-left:0;*/}
}
@media all and (max-width:699px) {
  input[type="text"] {font-size:112%;}
  input[type="text"] {width:14em;}
  input[type="text"].inpctl {width:26em;}
  input[type="text"].inpctl.short {width:26em;}
}
@media all and (max-width:599px) {
  input[type="text"].inpctl {width:26em;}
  input[type="text"].inpctl.short {width:26em;}
}
@media all and (max-width:519px) {
  input[type="text"].inpctl {width:17em;}
  input[type="text"].inpctl.short {width:17em;}
}
@media all and (max-width:399px) {
  input[type="text"].inpctl {width:13em;}
  input[type="text"].inpctl.short {width:13em;}
}
@media all and (max-width:359px) {
  input[type="text"].inpctl {width:11em;}
  input[type="text"].inpctl.short {width:11em;}
}
@media all and (max-width:319px) {
  input[type="text"].inpctl {width:8em;}
  input[type="text"].inpctl.short {width:8em;}
}
@media print {
  label, input[type="file"] {display:none;}
  #qrio-generator-status {max-width:100%;}
}
input {
  transition: background-color 0.3s ease, color 0.3s ease;
}

/*
 * custom checkbox
label container>text
  input type=checkbox
  span checkmark
 */
/*
.container {
  blk; rel; padleft; curs; user-select: none;
}
.container input {
  pos abs; opac 0; hgt 0; wid 0;
}
.checkmark {
  pos abs; top 0; left 0; hgt 1; wid 1; baccol eee;
}
.container:hover input ~ .checkmark {
  baccol ccc;
}
.container input:checked ~ .checkmark {
  baccol blue;
}
.checkmark:after {
  content ''; pos abs; disp none;
}
.container input:checked ~ .checkmark:after {
  left 9; top 5; wid 5; hgt 10; border sol white; border-wid 0 3 3 0; tranform rot(45deg);
}
*/

/*
 * icons
 */
span.icon {
  background-repeat:no-repeat; background-size:contain;
  width:1.8em; height:1.8em; font-size:0.78em; color:#f00; fill:#f00;
}
span.icon.small {
  font-size:0.7em;
}
span.icon.logo {
  position:relative; top:-0.3em; left:-0.3em;
  font-size:3.5em;
}
/*
@media all and (max-width:699px) {
  span.icon {font-size:0.94em;}
  span.icon.small {font-size:0.81em;}
}
*/
.logo {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIEdlbmVyYXRvcjogU1ZHIFJlcG8gTWl4ZXIgVG9vbHMgLS0+DQo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPg0KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJDYXBhXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIA0KCSB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCA2MDAgNjAwIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA2MDAgNjAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxnPg0KCTxwYXRoIGZpbGw9IiNFN0JENzkiIGQ9Ik01MDAsNDIzLjEzOUM1MDAsNDY1LjU4Nyw0NjUuNTg3LDUwMCw0MjMuMTM4LDUwMEgxNzYuODYyQzEzNC40MTEsNTAwLDEwMCw0NjUuNTg3LDEwMCw0MjMuMTM5VjE3Ni44NjINCgkJQzEwMCwxMzQuNDEzLDEzNC40MTEsMTAwLDE3Ni44NjIsMTAwaDI0Ni4yNzVDNDY1LjU4NywxMDAsNTAwLDEzNC40MTMsNTAwLDE3Ni44NjJWNDIzLjEzOXoiLz4NCgk8cGF0aCBmaWxsPSIjREVCNDZGIiBkPSJNNTAwLDQyMy4xMzl2LTczLjc3N2wtMTI0LjM0My05Ni4wNzZMMTc5Ljg5LDMwMS4xNTRMNDEwLjg2MSw1MDBoMTIuMjc2DQoJCUM0NjUuNTg3LDUwMCw1MDAsNDY1LjU4Nyw1MDAsNDIzLjEzOXoiLz4NCgk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNNDIzLjM3OCwyOTYuNTI1Yy0wLjU1LTAuNzc3LTU1LjgyNy03Ny42NjYtMTIzLjM4LTc3LjY2NmMtNjcuNTUxLDAtMTIyLjgyOCw3Ni44ODktMTIzLjM4Niw3Ny42NzgNCgkJYy0xLjQ1NiwyLjA3MS0xLjQ1Niw0Ljg1MywwLjAwOCw2LjkzNWMwLjU1LDAuNzc4LDU1LjgyOCw3Ny42NjgsMTIzLjM3OCw3Ny42NjhjNjcuNTUzLDAsMTIyLjgzLTc2Ljg5LDEyMy4zODQtNzcuNjcyDQoJCUM0MjQuODQ4LDMwMS4zOTQsNDI0Ljg0OCwyOTguNjA1LDQyMy4zNzgsMjk2LjUyNXoiLz4NCgk8cGF0aCBmaWxsPSIjOERCM0IzIiBkPSJNMzYwLjA3MiwzMDAuMDAxYzAtMzMuMTc4LTI2Ljg5Ni02MC4wNzQtNjAuMDcyLTYwLjA3NGMtMzMuMTc4LDAtNjAuMDczLDI2Ljg5Ni02MC4wNzMsNjAuMDc0DQoJCWMwLDMzLjE3NSwyNi44OTUsNjAuMDczLDYwLjA3Myw2MC4wNzNDMzMzLjE3NywzNjAuMDc0LDM2MC4wNzIsMzMzLjE3NiwzNjAuMDcyLDMwMC4wMDF6Ii8+DQoJPGNpcmNsZSBmaWxsPSIjMjIzRTUyIiBjeD0iMzAwIiBjeT0iMzAwLjAwMSIgcj0iMjYuMTE3Ii8+DQoJPGNpcmNsZSBmaWxsPSIjRkZGRkZGIiBjeD0iMzMwLjEyNSIgY3k9IjI2NC40MzkiIHI9IjEzLjgyOSIvPg0KPC9nPg0KPC9zdmc+");
}
.docdownfilled {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIG9wYWNpdHk9IjAuMSIgZD0iTTE3LjgyODQgNi44Mjg0M0MxOC40MDY1IDcuNDA2NDkgMTguNjk1NSA3LjY5NTUyIDE4Ljg0NzggOC4wNjMwNkMxOSA4LjQzMDYgMTkgOC44MzkzNSAxOSA5LjY1Njg1TDE5IDE3QzE5IDE4Ljg4NTYgMTkgMTkuODI4NCAxOC40MTQyIDIwLjQxNDJDMTcuODI4NCAyMSAxNi44ODU2IDIxIDE1IDIxSDlDNy4xMTQzOCAyMSA2LjE3MTU3IDIxIDUuNTg1NzkgMjAuNDE0MkM1IDE5LjgyODQgNSAxOC44ODU2IDUgMTdMNSA3QzUgNS4xMTQzOCA1IDQuMTcxNTcgNS41ODU3OSAzLjU4NTc5QzYuMTcxNTcgMyA3LjExNDM4IDMgOSAzSDEyLjM0MzFDMTMuMTYwNiAzIDEzLjU2OTQgMyAxMy45MzY5IDMuMTUyMjRDMTQuMzA0NSAzLjMwNDQ4IDE0LjU5MzUgMy41OTM1MSAxNS4xNzE2IDQuMTcxNTdMMTcuODI4NCA2LjgyODQzWiIgZmlsbD0iIzMyMzIzMiIvPg0KPHBhdGggZD0iTTE3LjgyODQgNi44Mjg0M0MxOC40MDY1IDcuNDA2NDkgMTguNjk1NSA3LjY5NTUyIDE4Ljg0NzggOC4wNjMwNkMxOSA4LjQzMDYgMTkgOC44MzkzNSAxOSA5LjY1Njg1TDE5IDE3QzE5IDE4Ljg4NTYgMTkgMTkuODI4NCAxOC40MTQyIDIwLjQxNDJDMTcuODI4NCAyMSAxNi44ODU2IDIxIDE1IDIxSDlDNy4xMTQzOCAyMSA2LjE3MTU3IDIxIDUuNTg1NzkgMjAuNDE0MkM1IDE5LjgyODQgNSAxOC44ODU2IDUgMTdMNSA3QzUgNS4xMTQzOCA1IDQuMTcxNTcgNS41ODU3OSAzLjU4NTc5QzYuMTcxNTcgMyA3LjExNDM4IDMgOSAzSDEyLjM0MzFDMTMuMTYwNiAzIDEzLjU2OTQgMyAxMy45MzY5IDMuMTUyMjRDMTQuMzA0NSAzLjMwNDQ4IDE0LjU5MzUgMy41OTM1MSAxNS4xNzE2IDQuMTcxNTdMMTcuODI4NCA2LjgyODQzWiIgc3Ryb2tlPSIjMzIzMjMyIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4NCjxwYXRoIGQ9Ik0xMiAxNkwxMiAxMSIgc3Ryb2tlPSIjMzIzMjMyIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPg0KPHBhdGggZD0iTTkuNSAxNEwxMS41IDE2VjE2QzExLjc3NjEgMTYuMjc2MSAxMi4yMjM5IDE2LjI3NjEgMTIuNSAxNlYxNkwxNC41IDE0IiBzdHJva2U9IiMzMjMyMzIiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8L3N2Zz4=");
}
.docdown, .savefile {
content:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xMiAxNkwxMiAxMSIgc3Ryb2tlPSIjMzIzMjMyIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPg0KPHBhdGggZD0iTTkuNSAxNEwxMS41IDE2VjE2QzExLjc3NjEgMTYuMjc2MSAxMi4yMjM5IDE2LjI3NjEgMTIuNSAxNlYxNkwxNC41IDE0IiBzdHJva2U9IiMzMjMyMzIiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8cGF0aCBkPSJNMTcuODI4NCA2LjgyODQzQzE4LjQwNjUgNy40MDY0OSAxOC42OTU1IDcuNjk1NTIgMTguODQ3OCA4LjA2MzA2QzE5IDguNDMwNiAxOSA4LjgzOTM1IDE5IDkuNjU2ODVMMTkgMTdDMTkgMTguODg1NiAxOSAxOS44Mjg0IDE4LjQxNDIgMjAuNDE0MkMxNy44Mjg0IDIxIDE2Ljg4NTYgMjEgMTUgMjFIOUM3LjExNDM4IDIxIDYuMTcxNTcgMjEgNS41ODU3OSAyMC40MTQyQzUgMTkuODI4NCA1IDE4Ljg4NTYgNSAxN0w1IDdDNSA1LjExNDM4IDUgNC4xNzE1NyA1LjU4NTc5IDMuNTg1NzlDNi4xNzE1NyAzIDcuMTE0MzggMyA5IDNIMTIuMzQzMUMxMy4xNjA2IDMgMTMuNTY5NCAzIDEzLjkzNjkgMy4xNTIyNEMxNC4zMDQ1IDMuMzA0NDggMTQuNTkzNSAzLjU5MzUxIDE1LjE3MTYgNC4xNzE1N0wxNy44Mjg0IDYuODI4NDNaIiBzdHJva2U9IiMzMjMyMzIiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPg0KPC9zdmc+");
}
.doc, .openfile {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xNy44Mjg0IDYuODI4NDNDMTguNDA2NSA3LjQwNjQ5IDE4LjY5NTUgNy42OTU1MiAxOC44NDc4IDguMDYzMDZDMTkgOC40MzA2IDE5IDguODM5MzUgMTkgOS42NTY4NUwxOSAxN0MxOSAxOC44ODU2IDE5IDE5LjgyODQgMTguNDE0MiAyMC40MTQyQzE3LjgyODQgMjEgMTYuODg1NiAyMSAxNSAyMUg5QzcuMTE0MzggMjEgNi4xNzE1NyAyMSA1LjU4NTc5IDIwLjQxNDJDNSAxOS44Mjg0IDUgMTguODg1NiA1IDE3TDUgN0M1IDUuMTE0MzggNSA0LjE3MTU3IDUuNTg1NzkgMy41ODU3OUM2LjE3MTU3IDMgNy4xMTQzOCAzIDkgM0gxMi4zNDMxQzEzLjE2MDYgMyAxMy41Njk0IDMgMTMuOTM2OSAzLjE1MjI0QzE0LjMwNDUgMy4zMDQ0OCAxNC41OTM1IDMuNTkzNTEgMTUuMTcxNiA0LjE3MTU3TDE3LjgyODQgNi44Mjg0M1oiIHN0cm9rZT0iIzMyMzIzMiIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+DQo8L3N2Zz4=");
}
.docfilled, .openfileinsert {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIG9wYWNpdHk9IjAuMSIgZD0iTTE3LjgyODQgNi44Mjg0M0MxOC40MDY1IDcuNDA2NDkgMTguNjk1NSA3LjY5NTUyIDE4Ljg0NzggOC4wNjMwNkMxOSA4LjQzMDYgMTkgOC44MzkzNSAxOSA5LjY1Njg1TDE5IDE3QzE5IDE4Ljg4NTYgMTkgMTkuODI4NCAxOC40MTQyIDIwLjQxNDJDMTcuODI4NCAyMSAxNi44ODU2IDIxIDE1IDIxSDlDNy4xMTQzOCAyMSA2LjE3MTU3IDIxIDUuNTg1NzkgMjAuNDE0MkM1IDE5LjgyODQgNSAxOC44ODU2IDUgMTdMNSA3QzUgNS4xMTQzOCA1IDQuMTcxNTcgNS41ODU3OSAzLjU4NTc5QzYuMTcxNTcgMyA3LjExNDM4IDMgOSAzSDEyLjM0MzFDMTMuMTYwNiAzIDEzLjU2OTQgMyAxMy45MzY5IDMuMTUyMjRDMTQuMzA0NSAzLjMwNDQ4IDE0LjU5MzUgMy41OTM1MSAxNS4xNzE2IDQuMTcxNTdMMTcuODI4NCA2LjgyODQzWiIgZmlsbD0iIzMyMzIzMiIvPg0KPHBhdGggZD0iTTE3LjgyODQgNi44Mjg0M0MxOC40MDY1IDcuNDA2NDkgMTguNjk1NSA3LjY5NTUyIDE4Ljg0NzggOC4wNjMwNkMxOSA4LjQzMDYgMTkgOC44MzkzNSAxOSA5LjY1Njg1TDE5IDE3QzE5IDE4Ljg4NTYgMTkgMTkuODI4NCAxOC40MTQyIDIwLjQxNDJDMTcuODI4NCAyMSAxNi44ODU2IDIxIDE1IDIxSDlDNy4xMTQzOCAyMSA2LjE3MTU3IDIxIDUuNTg1NzkgMjAuNDE0MkM1IDE5LjgyODQgNSAxOC44ODU2IDUgMTdMNSA3QzUgNS4xMTQzOCA1IDQuMTcxNTcgNS41ODU3OSAzLjU4NTc5QzYuMTcxNTcgMyA3LjExNDM4IDMgOSAzSDEyLjM0MzFDMTMuMTYwNiAzIDEzLjU2OTQgMyAxMy45MzY5IDMuMTUyMjRDMTQuMzA0NSAzLjMwNDQ4IDE0LjU5MzUgMy41OTM1MSAxNS4xNzE2IDQuMTcxNTdMMTcuODI4NCA2LjgyODQzWiIgc3Ryb2tlPSIjMzIzMjMyIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4NCjwvc3ZnPg==");
}
.doc1983 {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOS4yOTI4OSAxLjI5Mjg5QzkuNDgwNDMgMS4xMDUzNiA5LjczNDc4IDEgMTAgMUgxOEMxOS42NTY5IDEgMjEgMi4zNDMxNSAyMSA0VjIwQzIxIDIxLjY1NjkgMTkuNjU2OSAyMyAxOCAyM0g2QzQuMzQzMTUgMjMgMyAyMS42NTY5IDMgMjBWOEMzIDcuNzM0NzggMy4xMDUzNiA3LjQ4MDQzIDMuMjkyODkgNy4yOTI4OUw5LjI5Mjg5IDEuMjkyODlaTTE4IDNIMTFWOEMxMSA4LjU1MjI4IDEwLjU1MjMgOSAxMCA5SDVWMjBDNSAyMC41NTIzIDUuNDQ3NzIgMjEgNiAyMUgxOEMxOC41NTIzIDIxIDE5IDIwLjU1MjMgMTkgMjBWNEMxOSAzLjQ0NzcyIDE4LjU1MjMgMyAxOCAzWk02LjQxNDIxIDdIOVY0LjQxNDIxTDYuNDE0MjEgN1pNNyAxM0M3IDEyLjQ0NzcgNy40NDc3MiAxMiA4IDEySDE2QzE2LjU1MjMgMTIgMTcgMTIuNDQ3NyAxNyAxM0MxNyAxMy41NTIzIDE2LjU1MjMgMTQgMTYgMTRIOEM3LjQ0NzcyIDE0IDcgMTMuNTUyMyA3IDEzWk03IDE3QzcgMTYuNDQ3NyA3LjQ0NzcyIDE2IDggMTZIMTZDMTYuNTUyMyAxNiAxNyAxNi40NDc3IDE3IDE3QzE3IDE3LjU1MjMgMTYuNTUyMyAxOCAxNiAxOEg4QzcuNDQ3NzIgMTggNyAxNy41NTIzIDcgMTdaIiBmaWxsPSIjMDAwMDAwIi8+DQo8L3N2Zz4=");
}
.down {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xMSAzLjAxMjU0QzEwLjk5ODMgMi40NjAyNiAxMS40NDQ2IDIuMDExMTQgMTEuOTk2OSAyLjAwOTQxQzEyLjU0OTIgMi4wMDc2OCAxMi45OTgzIDIuNDUzOTkgMTMgMy4wMDYyN0wxMSAzLjAxMjU0WiIgZmlsbD0iIzAwMDAwMCIvPg0KPHBhdGggZD0iTTE0LjMxNTggMTAuMjk1MUwxMy4wMjY5IDExLjU5MkwxMyAzLjAwNjI3TDExIDMuMDEyNTRMMTEuMDI2OSAxMS41OTgzTDkuNzMwMDMgMTAuMzA5NUM5LjMzODI4IDkuOTIwMTggOC43MDUxIDkuOTIyMTQgOC4zMTU4IDEwLjMxMzlDNy45MjY1IDEwLjcwNTYgNy45Mjg0OSAxMS4zMzg4IDguMzIwMjQgMTEuNzI4MUw4LjMyMjc1IDExLjczMDZMOC4zMjM3NCAxMS43MzE2TDEyLjAzOSAxNS40MjM2TDE1LjcyMDYgMTEuNzE4N0wxNS43MjYyIDExLjcxMzFMMTUuNzI3IDExLjcxMjNMMTUuNzI3OCAxMS43MTE1TDE1LjczMzcgMTEuNzA1NkwxNS43MzQ0IDExLjcwNDlMMTQuMzE1OCAxMC4yOTUxWiIgZmlsbD0iIzAwMDAwMCIvPg0KPHBhdGggZD0iTTE1LjczNDQgMTEuNzA0OUMxNi4xMjM3IDExLjMxMzEgMTYuMTIxNyAxMC42Nzk5IDE1LjczIDEwLjI5MDZDMTUuMzM4MiA5LjkwMTM0IDE0LjcwNSA5LjkwMzM1IDE0LjMxNTggMTAuMjk1MUwxNS43MzQ0IDExLjcwNDlaIiBmaWxsPSIjMDAwMDAwIi8+DQo8cGF0aCBkPSJNNCAxMkM0IDEwLjg5NTQgNC44OTU0MyAxMCA2IDEwQzYuNTUyMjggMTAgNyA5LjU1MjI4IDcgOUM3IDguNDQ3NzEgNi41NTIyOCA4IDYgOEMzLjc5MDg2IDggMiA5Ljc5MDg2IDIgMTJWMThDMiAyMC4yMDkxIDMuNzkwODYgMjIgNiAyMkgxN0MxOS43NjE0IDIyIDIyIDE5Ljc2MTQgMjIgMTdWMTJDMjIgOS43OTA4NiAyMC4yMDkxIDggMTggOEMxNy40NDc3IDggMTcgOC40NDc3MSAxNyA5QzE3IDkuNTUyMjggMTcuNDQ3NyAxMCAxOCAxMEMxOS4xMDQ2IDEwIDIwIDEwLjg5NTQgMjAgMTJWMTdDMjAgMTguNjU2OSAxOC42NTY5IDIwIDE3IDIwSDZDNC44OTU0MyAyMCA0IDE5LjEwNDYgNCAxOFYxMloiIGZpbGw9IiMwMDAwMDAiLz4NCjwvc3ZnPg==");
}
.floppyfilled {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIGZpbGw9IiMwMDAwMDAiIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iMCAwIDI0IDI0IiBpZD0iZmxvcHB5LWRpc2stc2F2ZSIgZGF0YS1uYW1lPSJGbGF0IExpbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9Imljb24gZmxhdC1saW5lIj48cGF0aCBpZD0ic2Vjb25kYXJ5IiBkPSJNMTcsM0gxNVY3SDlWM0g1QTEsMSwwLDAsMCw0LDRWMjBhMSwxLDAsMCwwLDEsMUgxOWExLDEsMCwwLDAsMS0xVjZaTTEyLDE3YTMsMywwLDEsMSwzLTNBMywzLDAsMCwxLDEyLDE3WiIgc3R5bGU9ImZpbGw6IHJnYig0NCwgMTY5LCAxODgpOyBzdHJva2Utd2lkdGg6IDI7Ij48L3BhdGg+PHBhdGggaWQ9InByaW1hcnkiIGQ9Ik0xNSwzSDlWN2g2Wk05LDE0YTMsMywwLDAsMCwzLDNoMGEzLDMsMCwwLDAsMy0zaDBhMywzLDAsMCwwLTMtM2gwYTMsMywwLDAsMC0zLDNaTTIwLDZWMjBhMSwxLDAsMCwxLTEsMUg1YTEsMSwwLDAsMS0xLTFWNEExLDEsMCwwLDEsNSwzSDE3WiIgc3R5bGU9ImZpbGw6IG5vbmU7IHN0cm9rZTogcmdiKDAsIDAsIDApOyBzdHJva2UtbGluZWNhcDogcm91bmQ7IHN0cm9rZS1saW5lam9pbjogcm91bmQ7IHN0cm9rZS13aWR0aDogMjsiPjwvcGF0aD48L3N2Zz4=");
}
.floppy {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNCA1QzQgNC40NDc3MiA0LjQ0NzcyIDQgNSA0SDdWN0M3IDcuNTUyMjggNy40NDc3MiA4IDggOEgxNUMxNS41NTIzIDggMTYgNy41NTIyOCAxNiA3VjRIMTYuMTcxNkMxNi40MzY4IDQgMTYuNjkxMSA0LjEwNTM2IDE2Ljg3ODcgNC4yOTI4OUwxOS43MDcxIDcuMTIxMzJDMTkuODk0NiA3LjMwODg2IDIwIDcuNTYzMjEgMjAgNy44Mjg0M1YxOUMyMCAxOS41NTIzIDE5LjU1MjMgMjAgMTkgMjBIMThWMTNDMTggMTIuNDQ3NyAxNy41NTIzIDEyIDE3IDEySDdDNi40NDc3MiAxMiA2IDEyLjQ0NzcgNiAxM1YyMEg1QzQuNDQ3NzIgMjAgNCAxOS41NTIzIDQgMTlWNVpNOCAyMEgxNlYxNEg4VjIwWk0xNCA0SDlWNkgxNFY0Wk01IDJDMy4zNDMxNSAyIDIgMy4zNDMxNSAyIDVWMTlDMiAyMC42NTY5IDMuMzQzMTUgMjIgNSAyMkgxOUMyMC42NTY5IDIyIDIyIDIwLjY1NjkgMjIgMTlWNy44Mjg0M0MyMiA3LjAzMjc4IDIxLjY4MzkgNi4yNjk3MiAyMS4xMjEzIDUuNzA3MTFMMTguMjkyOSAyLjg3ODY4QzE3LjczMDMgMi4zMTYwNyAxNi45NjcyIDIgMTYuMTcxNiAySDVaIiBmaWxsPSIjMDAwMDAwIi8+DQo8L3N2Zz4=");
}
.qr {
content:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIGZpbGw9IiMwMDAwMDAiIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iMCAwIDU2IDU2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0gMzQuNDMzNSAyNi4wNjY0IEwgNDUuMDk3NiAyNi4wNjY0IEMgNDguMDk3NiAyNi4wNjY0IDQ5LjU3NDMgMjQuNTY2NCA0OS41NzQzIDIxLjQ3MjcgTCA0OS41NzQzIDEwLjk5NjEgQyA0OS41NzQzIDcuOTAyMyA0OC4wOTc2IDYuNDI1OCA0NS4wOTc2IDYuNDI1OCBMIDM0LjQzMzUgNi40MjU4IEMgMzEuNDU3MCA2LjQyNTggMjkuOTU3MCA3LjkwMjMgMjkuOTU3MCAxMC45OTYxIEwgMjkuOTU3MCAyMS40NzI3IEMgMjkuOTU3MCAyNC41NjY0IDMxLjQ1NzAgMjYuMDY2NCAzNC40MzM1IDI2LjA2NjQgWiBNIDEwLjkwMjMgMjYuMDY2NCBMIDIxLjU4OTggMjYuMDY2NCBDIDI0LjU2NjMgMjYuMDY2NCAyNi4wNjYzIDI0LjU2NjQgMjYuMDY2MyAyMS40NzI3IEwgMjYuMDY2MyAxMC45OTYxIEMgMjYuMDY2MyA3LjkwMjMgMjQuNTY2MyA2LjQyNTggMjEuNTg5OCA2LjQyNTggTCAxMC45MDIzIDYuNDI1OCBDIDcuOTI1NyA2LjQyNTggNi40MjU3IDcuOTAyMyA2LjQyNTcgMTAuOTk2MSBMIDYuNDI1NyAyMS40NzI3IEMgNi40MjU3IDI0LjU2NjQgNy45MjU3IDI2LjA2NjQgMTAuOTAyMyAyNi4wNjY0IFogTSAxMC45NDkyIDIyLjc2MTcgQyAxMC4xMjg4IDIyLjc2MTcgOS43MzA0IDIyLjMzOTggOS43MzA0IDIxLjQ3MjcgTCA5LjczMDQgMTAuOTk2MSBDIDkuNzMwNCAxMC4xNTIzIDEwLjEyODggOS43MzA1IDEwLjk0OTIgOS43MzA1IEwgMjEuNTE5NSA5LjczMDUgQyAyMi4zMzk4IDkuNzMwNSAyMi43NjE3IDEwLjE1MjMgMjIuNzYxNyAxMC45OTYxIEwgMjIuNzYxNyAyMS40NzI3IEMgMjIuNzYxNyAyMi4zMzk4IDIyLjMzOTggMjIuNzYxNyAyMS41MTk1IDIyLjc2MTcgWiBNIDM0LjQ4MDQgMjIuNzYxNyBDIDMzLjY2MDEgMjIuNzYxNyAzMy4yNjE3IDIyLjMzOTggMzMuMjYxNyAyMS40NzI3IEwgMzMuMjYxNyAxMC45OTYxIEMgMzMuMjYxNyAxMC4xNTIzIDMzLjY2MDEgOS43MzA1IDM0LjQ4MDQgOS43MzA1IEwgNDUuMDc0MiA5LjczMDUgQyA0NS44NzEwIDkuNzMwNSA0Ni4yNjk1IDEwLjE1MjMgNDYuMjY5NSAxMC45OTYxIEwgNDYuMjY5NSAyMS40NzI3IEMgNDYuMjY5NSAyMi4zMzk4IDQ1Ljg3MTAgMjIuNzYxNyA0NS4wNzQyIDIyLjc2MTcgWiBNIDE0LjIzMDQgMTguNzA3MSBMIDE4LjIzODIgMTguNzA3MSBDIDE4LjU4OTggMTguNzA3MSAxOC43MzA0IDE4LjU2NjQgMTguNzMwNCAxOC4xNjgwIEwgMTguNzMwNCAxNC4yNzc0IEMgMTguNzMwNCAxMy45MDIzIDE4LjU4OTggMTMuNzYxNyAxOC4yMzgyIDEzLjc2MTcgTCAxNC4yMzA0IDEzLjc2MTcgQyAxMy44Nzg4IDEzLjc2MTcgMTMuNzg1MSAxMy45MDIzIDEzLjc4NTEgMTQuMjc3NCBMIDEzLjc4NTEgMTguMTY4MCBDIDEzLjc4NTEgMTguNTY2NCAxMy44Nzg4IDE4LjcwNzEgMTQuMjMwNCAxOC43MDcxIFogTSAzNy45MDIzIDE4LjcwNzEgTCA0MS44ODY2IDE4LjcwNzEgQyA0Mi4yMzgyIDE4LjcwNzEgNDIuMzc4OCAxOC41NjY0IDQyLjM3ODggMTguMTY4MCBMIDQyLjM3ODggMTQuMjc3NCBDIDQyLjM3ODggMTMuOTAyMyA0Mi4yMzgyIDEzLjc2MTcgNDEuODg2NiAxMy43NjE3IEwgMzcuOTAyMyAxMy43NjE3IEMgMzcuNTUwNyAxMy43NjE3IDM3LjQzMzUgMTMuOTAyMyAzNy40MzM1IDE0LjI3NzQgTCAzNy40MzM1IDE4LjE2ODAgQyAzNy40MzM1IDE4LjU2NjQgMzcuNTUwNyAxOC43MDcxIDM3LjkwMjMgMTguNzA3MSBaIE0gMTAuOTAyMyA0OS41NzQyIEwgMjEuNTg5OCA0OS41NzQyIEMgMjQuNTY2MyA0OS41NzQyIDI2LjA2NjMgNDguMDk3NyAyNi4wNjYzIDQ1LjAwMzkgTCAyNi4wNjYzIDM0LjUwMzkgQyAyNi4wNjYzIDMxLjQzMzYgMjQuNTY2MyAyOS45MzM2IDIxLjU4OTggMjkuOTMzNiBMIDEwLjkwMjMgMjkuOTMzNiBDIDcuOTI1NyAyOS45MzM2IDYuNDI1NyAzMS40MzM2IDYuNDI1NyAzNC41MDM5IEwgNi40MjU3IDQ1LjAwMzkgQyA2LjQyNTcgNDguMDk3NyA3LjkyNTcgNDkuNTc0MiAxMC45MDIzIDQ5LjU3NDIgWiBNIDMxLjUyNzMgMzYuMDAzOSBMIDM1LjUzNTEgMzYuMDAzOSBDIDM1Ljg4NjYgMzYuMDAzOSAzNi4wMjczIDM1Ljg2MzMgMzYuMDI3MyAzNS40NjQ5IEwgMzYuMDI3MyAzMS41NzQyIEMgMzYuMDI3MyAzMS4xOTkyIDM1Ljg4NjYgMzEuMDU4NiAzNS41MzUxIDMxLjA1ODYgTCAzMS41MjczIDMxLjA1ODYgQyAzMS4xNzU3IDMxLjA1ODYgMzEuMDgyMCAzMS4xOTkyIDMxLjA4MjAgMzEuNTc0MiBMIDMxLjA4MjAgMzUuNDY0OSBDIDMxLjA4MjAgMzUuODYzMyAzMS4xNzU3IDM2LjAwMzkgMzEuNTI3MyAzNi4wMDM5IFogTSA0My45NzI2IDM2LjAwMzkgTCA0Ny45ODA0IDM2LjAwMzkgQyA0OC4zMzIwIDM2LjAwMzkgNDguNDcyNyAzNS44NjMzIDQ4LjQ3MjcgMzUuNDY0OSBMIDQ4LjQ3MjcgMzEuNTc0MiBDIDQ4LjQ3MjcgMzEuMTk5MiA0OC4zMzIwIDMxLjA1ODYgNDcuOTgwNCAzMS4wNTg2IEwgNDMuOTcyNiAzMS4wNTg2IEMgNDMuNjIxMCAzMS4wNTg2IDQzLjUwMzkgMzEuMTk5MiA0My41MDM5IDMxLjU3NDIgTCA0My41MDM5IDM1LjQ2NDkgQyA0My41MDM5IDM1Ljg2MzMgNDMuNjIxMCAzNi4wMDM5IDQzLjk3MjYgMzYuMDAzOSBaIE0gMTAuOTQ5MiA0Ni4yNjk1IEMgMTAuMTI4OCA0Ni4yNjk1IDkuNzMwNCA0NS44NDc3IDkuNzMwNCA0NS4wMDM5IEwgOS43MzA0IDM0LjUyNzQgQyA5LjczMDQgMzMuNjYwMiAxMC4xMjg4IDMzLjIzODMgMTAuOTQ5MiAzMy4yMzgzIEwgMjEuNTE5NSAzMy4yMzgzIEMgMjIuMzM5OCAzMy4yMzgzIDIyLjc2MTcgMzMuNjYwMiAyMi43NjE3IDM0LjUyNzQgTCAyMi43NjE3IDQ1LjAwMzkgQyAyMi43NjE3IDQ1Ljg0NzcgMjIuMzM5OCA0Ni4yNjk1IDIxLjUxOTUgNDYuMjY5NSBaIE0gMTQuMjMwNCA0Mi4yMzgzIEwgMTguMjM4MiA0Mi4yMzgzIEMgMTguNTg5OCA0Mi4yMzgzIDE4LjczMDQgNDIuMDk3NyAxOC43MzA0IDQxLjY3NTggTCAxOC43MzA0IDM3LjgwODYgQyAxOC43MzA0IDM3LjQzMzYgMTguNTg5OCAzNy4yOTMwIDE4LjIzODIgMzcuMjkzMCBMIDE0LjIzMDQgMzcuMjkzMCBDIDEzLjg3ODggMzcuMjkzMCAxMy43ODUxIDM3LjQzMzYgMTMuNzg1MSAzNy44MDg2IEwgMTMuNzg1MSA0MS42NzU4IEMgMTMuNzg1MSA0Mi4wOTc3IDEzLjg3ODggNDIuMjM4MyAxNC4yMzA0IDQyLjIzODMgWiBNIDM3LjgwODUgNDIuMjM4MyBMIDQxLjgxNjMgNDIuMjM4MyBDIDQyLjE2NzkgNDIuMjM4MyA0Mi4zMDg1IDQyLjA5NzcgNDIuMzA4NSA0MS42NzU4IEwgNDIuMzA4NSAzNy44MDg2IEMgNDIuMzA4NSAzNy40MzM2IDQyLjE2NzkgMzcuMjkzMCA0MS44MTYzIDM3LjI5MzAgTCAzNy44MDg1IDM3LjI5MzAgQyAzNy40NTcwIDM3LjI5MzAgMzcuMzYzMiAzNy40MzM2IDM3LjM2MzIgMzcuODA4NiBMIDM3LjM2MzIgNDEuNjc1OCBDIDM3LjM2MzIgNDIuMDk3NyAzNy40NTcwIDQyLjIzODMgMzcuODA4NSA0Mi4yMzgzIFogTSAzMS41MjczIDQ4LjQ0OTIgTCAzNS41MzUxIDQ4LjQ0OTIgQyAzNS44ODY2IDQ4LjQ0OTIgMzYuMDI3MyA0OC4zMDg2IDM2LjAyNzMgNDcuOTEwMiBMIDM2LjAyNzMgNDQuMDE5NSBDIDM2LjAyNzMgNDMuNjQ0NSAzNS44ODY2IDQzLjUwMzkgMzUuNTM1MSA0My41MDM5IEwgMzEuNTI3MyA0My41MDM5IEMgMzEuMTc1NyA0My41MDM5IDMxLjA4MjAgNDMuNjQ0NSAzMS4wODIwIDQ0LjAxOTUgTCAzMS4wODIwIDQ3LjkxMDIgQyAzMS4wODIwIDQ4LjMwODYgMzEuMTc1NyA0OC40NDkyIDMxLjUyNzMgNDguNDQ5MiBaIE0gNDMuOTcyNiA0OC40NDkyIEwgNDcuOTgwNCA0OC40NDkyIEMgNDguMzMyMCA0OC40NDkyIDQ4LjQ3MjcgNDguMzA4NiA0OC40NzI3IDQ3LjkxMDIgTCA0OC40NzI3IDQ0LjAxOTUgQyA0OC40NzI3IDQzLjY0NDUgNDguMzMyMCA0My41MDM5IDQ3Ljk4MDQgNDMuNTAzOSBMIDQzLjk3MjYgNDMuNTAzOSBDIDQzLjYyMTAgNDMuNTAzOSA0My41MDM5IDQzLjY0NDUgNDMuNTAzOSA0NC4wMTk1IEwgNDMuNTAzOSA0Ny45MTAyIEMgNDMuNTAzOSA0OC4zMDg2IDQzLjYyMTAgNDguNDQ5MiA0My45NzI2IDQ4LjQ0OTIgWiIvPjwvc3ZnPg==");
}
.qrscan {
content:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIGZpbGw9ImN1cnJlbnRDb2xvciIgd2lkdGg9IjgwMHB4IiBoZWlnaHQ9IjgwMHB4IiB2aWV3Qm94PSIwIDAgNTYgNTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTSA4LjM4MjcgMjEuNDAyMyBDIDkuNjAxNSAyMS40MDIzIDEwLjI1NzcgMjAuNzIyNyAxMC4yNTc3IDE5LjQ4MDUgTCAxMC4yNTc3IDEzLjk0OTIgQyAxMC4yNTc3IDExLjUxMTggMTEuNTcwMiAxMC4yNjk2IDEzLjkxNDAgMTAuMjY5NiBMIDE5LjU4NTggMTAuMjY5NiBDIDIwLjgwNDYgMTAuMjY5NiAyMS40ODQzIDkuNTg5OCAyMS40ODQzIDguMzcxMSBDIDIxLjQ4NDMgNy4xNzU4IDIwLjgwNDYgNi40OTYxIDE5LjU4NTggNi40OTYxIEwgMTMuODQzNiA2LjQ5NjEgQyA4Ljk2ODcgNi40OTYxIDYuNDg0MyA4LjkxMDIgNi40ODQzIDEzLjczODMgTCA2LjQ4NDMgMTkuNDgwNSBDIDYuNDg0MyAyMC43MjI3IDcuMTY0MCAyMS40MDIzIDguMzgyNyAyMS40MDIzIFogTSA0Ny42MTcxIDIxLjQwMjMgQyA0OC44NTkxIDIxLjQwMjMgNDkuNTE1NyAyMC43MjI3IDQ5LjUxNTcgMTkuNDgwNSBMIDQ5LjUxNTcgMTMuNzM4MyBDIDQ5LjUxNTcgOC45MTAyIDQ3LjA3ODAgNi40OTYxIDQyLjE1NjIgNi40OTYxIEwgMzYuNDM3NCA2LjQ5NjEgQyAzNS4xOTUyIDYuNDk2MSAzNC41MTU1IDcuMTc1OCAzNC41MTU1IDguMzcxMSBDIDM0LjUxNTUgOS41ODk4IDM1LjE5NTIgMTAuMjY5NiAzNi40Mzc0IDEwLjI2OTYgTCA0Mi4xMDkzIDEwLjI2OTYgQyA0NC40MDYyIDEwLjI2OTYgNDUuNzQyMSAxMS41MTE4IDQ1Ljc0MjEgMTMuOTQ5MiBMIDQ1Ljc0MjEgMTkuNDgwNSBDIDQ1Ljc0MjEgMjAuNzIyNyA0Ni40MjE4IDIxLjQwMjMgNDcuNjE3MSAyMS40MDIzIFogTSAyNi45OTIxIDI1Ljk3MjcgTCAyNi45OTIxIDE3Ljc5MzAgQyAyNi45OTIxIDE3LjIzMDUgMjYuNTQ2OCAxNi43NjE3IDI1Ljk2MDggMTYuNzYxNyBMIDE3LjgwNDYgMTYuNzYxNyBDIDE3LjIxODcgMTYuNzYxNyAxNi43NzMzIDE3LjIzMDUgMTYuNzczMyAxNy43OTMwIEwgMTYuNzczMyAyNS45NzI3IEMgMTYuNzczMyAyNi41MzUyIDE3LjIxODcgMjYuOTgwNSAxNy44MDQ2IDI2Ljk4MDUgTCAyNS45NjA4IDI2Ljk4MDUgQyAyNi41NDY4IDI2Ljk4MDUgMjYuOTkyMSAyNi41MzUyIDI2Ljk5MjEgMjUuOTcyNyBaIE0gMzEuMDQ2OCAxOC44MDA4IEwgMzcuMTg3NCAxOC44MDA4IEwgMzcuMTg3NCAyNC45NDE0IEwgMzEuMDQ2OCAyNC45NDE0IFogTSAzNS40MDYyIDIzLjE2MDIgTCAzNS40MDYyIDIwLjYwNTUgTCAzMi44NTE1IDIwLjYwNTUgTCAzMi44NTE1IDIzLjE2MDIgWiBNIDIzLjE3MTggMjMuMTYwMiBMIDIzLjE3MTggMjAuNjA1NSBMIDIwLjU5MzYgMjAuNjA1NSBMIDIwLjU5MzYgMjMuMTYwMiBaIE0gMTguODEyNCAzMS4wNTg2IEwgMjQuOTUzMCAzMS4wNTg2IEwgMjQuOTUzMCAzNy4xOTkyIEwgMTguODEyNCAzNy4xOTkyIFogTSAzOC45MjE4IDMxLjg1NTUgTCAzOC45MjE4IDI5LjMwMDggTCAzNi4zNjcxIDI5LjMwMDggTCAzNi4zNjcxIDMxLjg1NTUgWiBNIDMxLjg2NzEgMzEuODU1NSBMIDMxLjg2NzEgMjkuMzAwOCBMIDI5LjMxMjQgMjkuMzAwOCBMIDI5LjMxMjQgMzEuODU1NSBaIE0gMjMuMTcxOCAzNS4zOTQ1IEwgMjMuMTcxOCAzMi44Mzk4IEwgMjAuNTkzNiAzMi44Mzk4IEwgMjAuNTkzNiAzNS4zOTQ1IFogTSAzNS40MDYyIDM1LjM5NDUgTCAzNS40MDYyIDMyLjgzOTggTCAzMi44MjgwIDMyLjgzOTggTCAzMi44MjgwIDM1LjM5NDUgWiBNIDM2LjQzNzQgNDkuNTAzOSBMIDQyLjE1NjIgNDkuNTAzOSBDIDQ3LjA3ODAgNDkuNTAzOSA0OS41MTU3IDQ3LjA2NjQgNDkuNTE1NyA0Mi4yMzgzIEwgNDkuNTE1NyAzNi41MTk2IEMgNDkuNTE1NyAzNS4yNzc0IDQ4LjgzNjAgMzQuNTk3NyA0Ny42MTcxIDM0LjU5NzcgQyA0Ni4zOTg0IDM0LjU5NzcgNDUuNzQyMSAzNS4yNzc0IDQ1Ljc0MjEgMzYuNTE5NiBMIDQ1Ljc0MjEgNDIuMDUwOCBDIDQ1Ljc0MjEgNDQuNDg4MyA0NC40MDYyIDQ1LjczMDUgNDIuMTA5MyA0NS43MzA1IEwgMzYuNDM3NCA0NS43MzA1IEMgMzUuMTk1MiA0NS43MzA1IDM0LjUxNTUgNDYuNDEwMiAzNC41MTU1IDQ3LjYyODkgQyAzNC41MTU1IDQ4LjgyNDIgMzUuMTk1MiA0OS41MDM5IDM2LjQzNzQgNDkuNTAzOSBaIE0gMTMuODQzNiA0OS41MDM5IEwgMTkuNTg1OCA0OS41MDM5IEMgMjAuODA0NiA0OS41MDM5IDIxLjQ4NDMgNDguODI0MiAyMS40ODQzIDQ3LjYyODkgQyAyMS40ODQzIDQ2LjQxMDIgMjAuODA0NiA0NS43MzA1IDE5LjU4NTggNDUuNzMwNSBMIDEzLjkxNDAgNDUuNzMwNSBDIDExLjU3MDIgNDUuNzMwNSAxMC4yNTc3IDQ0LjQ4ODMgMTAuMjU3NyA0Mi4wNTA4IEwgMTAuMjU3NyAzNi41MTk2IEMgMTAuMjU3NyAzNS4yNzc0IDkuNTc4MCAzNC41OTc3IDguMzgyNyAzNC41OTc3IEMgNy4xNDA1IDM0LjU5NzcgNi40ODQzIDM1LjI3NzQgNi40ODQzIDM2LjUxOTYgTCA2LjQ4NDMgNDIuMjM4MyBDIDYuNDg0MyA0Ny4wODk4IDguOTY4NyA0OS41MDM5IDEzLjg0MzYgNDkuNTAzOSBaIE0gMzEuODY3MSAzOC45MzM2IEwgMzEuODY3MSAzNi4zNzg5IEwgMjkuMzEyNCAzNi4zNzg5IEwgMjkuMzEyNCAzOC45MzM2IFogTSAzOC45MjE4IDM4LjkzMzYgTCAzOC45MjE4IDM2LjM3ODkgTCAzNi4zNjcxIDM2LjM3ODkgTCAzNi4zNjcxIDM4LjkzMzYgWiBNIDM5LjIyNjUgMjUuOTcyNyBMIDM5LjIyNjUgMTcuNzkzMCBDIDM5LjIyNjUgMTcuMjMwNSAzOC43ODExIDE2Ljc2MTcgMzguMTk1MiAxNi43NjE3IEwgMzAuMDM4OSAxNi43NjE3IEMgMjkuNDUzMCAxNi43NjE3IDI5LjAwNzcgMTcuMjMwNSAyOS4wMDc3IDE3Ljc5MzAgTCAyOS4wMDc3IDI1Ljk3MjcgQyAyOS4wMDc3IDI2LjUzNTIgMjkuNDUzMCAyNi45ODA1IDMwLjAzODkgMjYuOTgwNSBMIDM4LjE5NTIgMjYuOTgwNSBDIDM4Ljc4MTEgMjYuOTgwNSAzOS4yMjY1IDI2LjUzNTIgMzkuMjI2NSAyNS45NzI3IFogTSAxOC44MTI0IDE4LjgwMDggTCAyNC45NTMwIDE4LjgwMDggTCAyNC45NTMwIDI0Ljk0MTQgTCAxOC44MTI0IDI0Ljk0MTQgWiBNIDI2Ljk5MjEgMzguMjA3MCBMIDI2Ljk5MjEgMzAuMDI3NCBDIDI2Ljk5MjEgMjkuNDY0OSAyNi41NDY4IDI5LjAxOTYgMjUuOTYwOCAyOS4wMTk2IEwgMTcuODA0NiAyOS4wMTk2IEMgMTcuMjE4NyAyOS4wMTk2IDE2Ljc3MzMgMjkuNDY0OSAxNi43NzMzIDMwLjAyNzQgTCAxNi43NzMzIDM4LjIwNzAgQyAxNi43NzMzIDM4Ljc2OTYgMTcuMjE4NyAzOS4yMzgzIDE3LjgwNDYgMzkuMjM4MyBMIDI1Ljk2MDggMzkuMjM4MyBDIDI2LjU0NjggMzkuMjM4MyAyNi45OTIxIDM4Ljc2OTYgMjYuOTkyMSAzOC4yMDcwIFoiLz48L3N2Zz4=");
}
.undo {
position:relative; top:0.05em;
background-image:url("data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNCAxMS4zNjU3NjUyYy40OTkxNzA1Ni0uNjUzODMyMSAxLjE1MDcxMjAxLTEuNDkxNzQ0MTggMS41NzA4MTczOC0xLjk1MjgzNTQ0IDEuOTYzMjE0NDctMi4xNTQ3NDc1OSA0LjE5MDY2MjktMy40MTI5Mjk3NiA2LjkyOTE4MjYyLTMuNDEyOTI5NzYgNi4zODk2NTE5IDAgOS41IDQuNDEyMjIyNCA5LjUgMTBoLTJjMC00LjYwMjgxNC0yLjM5NDgwOTMtOC03LjUtOC0yLjA5MTE1NTYgMC0zLjgzMjI0OTc3Ljk4MzQ2MzIxLTUuNDUwNzg5OTUgMi43NTk5MDk3LS40MjI4MDc0MS40NjQwNTctMS4yMjg3MzAyMSAxLjUyMjUyOTctMS43ODA3Njc5MyAyLjI0MDA5MDNoNS43MzE1NTc4OHYyaC05di05aDJ6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=");
}
.redo {
position:relative; top:0.05em;
background-image:url("data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMjAgMTEuMzY1NzY1MnYtNS4zNjU3NjUyaDJ2OWgtOXYtMmg1LjczMTU1NzljLS41NTIwMzc3LS43MTc1NjA2LTEuMzU3OTYwNS0xLjc3NjAzMzMtMS43ODA3NjgtMi4yNDAwOTAzLTEuNjE4NTQwMS0xLjc3NjQ0NjQ5LTMuMzU5NjM0My0yLjc1OTkwOTctNS40NTA3ODk5LTIuNzU5OTA5Ny01LjEwNTE5MDczIDAtNy41IDMuMzk3MTg2LTcuNSA4aC0yYzAtNS41ODc3Nzc2IDMuMTEwMzQ4MTQtMTAgOS41LTEwIDIuNzM4NTE5NyAwIDQuOTY1OTY4MiAxLjI1ODE4MjE3IDYuOTI5MTgyNiAzLjQxMjkyOTc2LjQyMDEwNTQuNDYxMDkxMjYgMS4wNzE2NDY4IDEuMjk5MDAzMzQgMS41NzA4MTc0IDEuOTUyODM1NDR6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=");
}
.search {
background-image:url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IS0tIFVwbG9hZGVkIHRvOiBTVkcgUmVwbywgd3d3LnN2Z3JlcG8uY29tLCBHZW5lcmF0b3I6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPg0KPHN2ZyB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCAyMCAyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBmaWxsPSJub25lIj4NCiAgPHBhdGggZmlsbD0iIzAwMDAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNCA5YTUgNSAwIDExMTAgMEE1IDUgMCAwMTQgOXptNS03YTcgNyAwIDEwNC4yIDEyLjYuOTk5Ljk5OSAwIDAwLjA5My4xMDdsMyAzYTEgMSAwIDAwMS40MTQtMS40MTRsLTMtM2EuOTk5Ljk5OSAwIDAwLS4xMDctLjA5M0E3IDcgMCAwMDkgMnoiLz4NCjwvc3ZnPg==");
}
  </style>

  <!--script type="text/javascript" src="lib/stylotron.js"/script-->
  <script>
/*
 * stylotron.js
 *
 *   SOT.text.map:        low level text parser, builds segmented range maps from a series of overlapping regex matches
 *   SOT.PatternSeries:   abstraction of a pattern series, produces SOT.text.maps and layered html
 *
 *   single step markup:  html = SOT.markup( text, patterndefs )
 *
 * stylotron-demo.html provides tutorial and example of use
 *
 * cc0 (public domain) v.010 September 2025, latest version @ github.com/gregsidal
 */

const SOT = {};

/*
 *  html = SOT.markup( text, patterndefs )
 *    marks up matches of of a pattern series, returns html
 *
 *    patterndefs = {def...}
 *      each def is one of these:
 *        'class': regex or string
 *          matches of each regex (or string) are styled with 'class'
 *        'class': {'regex': .., ..opts..}
 *        'class': {'range': {'start': .., 'end': ..}, ..opts..}
 *      opts can include:
 *        htmltag: ..
 *        htmlattrs: {...}
 *
 *  strings can be full regex's like "/.+/g" (a string without slashes in the right places is a literal)
 *  regex's must include 'g' flag or pattern is ignored ('g' is added to regex strings if needed)
 *
 *  matches that overlap/cover others are segmented and marked up in layers, see SOT.map.markup comments
 *  ranges are overlaid (applied last) by default, use opts={overlayranges:false} to apply ranges in order
 *    (the logic for the default is that ranges are usually types of selections, which are typically overlaid)
 *
 *  'htmlattrs' are added to starting tag: htmltag='a', htmlattrs={href:'A',target='B'} produces "<a href='A' target='B'>"
 *    attr strings can include '$_&' replacement wildcard, where $_& == matched text
 *    attr can also be a regex, in which case attr is whatever the regex extracts from matched text
 */
SOT.markup = function( text, defs, opts, callback ) {
  const patterns = new SOT.PatternSeries();
  patterns.add( defs );
  if (callback)
    patterns.setmarkupcallback( callback );
  return patterns.markup( text, undefined, opts );
}

/*
 *  SOT.PatternSeries
 *    registers regex's and ranges with associated CSS classes; produces SOT.text.maps and layered markup
 *
 *    patterns = new SOT.PatternSeries()
 *
 *    patterns.addregex( regex, cls )
 *      adds a regex (or string), matches will be styled with with CSS class 'cls'
 *      (strings can be literals or regex's including slashes and flags, ie "/.+/g")
 *    patterns.addrange( range, cls )
 *      adds a range
 *    patterns.add( defs )
 *      adds one or more defs, refer to SOT.map.markup comments
 *
 *    map = patterns.buildmap( text, map=[], overlayranges=true )
 *      builds a SOT.text.map of 'text'
 *        ('map' can be fed to SOT.map.markup to produce the HTML)
 *      ranges are applied last by default, use overlayranges=false to apply ranges in order
 *    HTML = patterns.markup( text )
 *      marks up defs, see SOT.map.markup
 *
 *    prevcallback = patterns.setmarkupcallback( callback )
 *      see SOT.map.markup for callback spec
 *      callback replaces any other previously set
 */
SOT.PatternSeries = function() {
  var defs = {};
  this.requiredregexflags = 'g';
  this.get = function( cls ) {
    return defs[cls];
  }
  this.addregexstr = function( regexstr, cls, reqflags=this.requiredregexflags, defin, alertiferror ) {
    var regex;
    try {
      //regex = new RegExp( regexstr, flags );
      regex = SOT.text.regexstr2regex( regexstr, reqflags );
    }
    catch( e ) {
      if (alertiferror)
        alert( e );
      return null;
    }
    if (defin)
      defs[cls] = defin;
    else
      defs[cls] = {};
    defs[cls].regexstr = regexstr, defs[cls].regex = regex;
    return regex;
  }
  this.addregex = function( regex, cls, reqflags ) {
    if (regex)
      if (typeof regex == 'string')
        this.addregexstr( regex, cls, reqflags );
      else
        defs[cls] = {'regex':regex};
  }
  this.addrange = function( range, cls ) {
    if (!defs[cls] || defs[cls].range.start != range.start || defs[cls].range.end != range.end) {
      defs[cls] = {'range': range};
      return true;
    }
  }
  this.add = function( defsin ) {
    for( var cls in defsin )
      if (defsin[cls])
        if (typeof defsin[cls] == 'string' || defsin[cls] instanceof RegExp)
          this.addregex( defsin[cls], cls );
        else
          if (defsin[cls].regex && typeof defsin[cls].regex == 'string')
            this.addregexstr( defsin[cls].regex, cls, this.requiredregexflags, defsin[cls] );
          else
            defs[cls] = defsin[cls];
  }
  this.del = function( cls ) {
    if (defs[cls]) {
      delete defs[cls];
      return true;
    }
  }
  this.delregexs = function() {
    var m = {};
    for( var cls in defs )
      if (!defs[cls].regex)
        m[cls] = defs[cls];
    defs = m;
  }
  this.delranges = function() {
    var m = {};
    for( var cls in defs )
      if (!defs[cls].range)
        m[cls] = defs[cls];
    defs = m;
  }
  this.clear = function() {
    defs = {};
  }
  this.buildmatchesmap = function( text, map=[] ) {
    for( var cls in defs  )
      if (defs[cls].regex)
        map = SOT.text.map.addmatches( text, defs[cls].regex, cls, true, map );
    return map;
  }
  this.buildrangesmap = function( text, map=[] ) {
    for( var cls in defs )
      if (defs[cls].range)
        map = SOT.text.map.addrange( text, defs[cls].range, cls, true, map );
    return map;
  }
  this.buildmap = function( text, map=[], overlayranges=true ) {
    if (overlayranges) {
      map = this.buildmatchesmap( text, map );
      map = this.buildrangesmap( text, map );
    }
    else {
      for( var cls in defs )
        if (defs[cls].regex)
          map = SOT.text.map.addmatches( text, defs[cls].regex, cls, true, map );
        else
          if (defs[cls].range)
            map = SOT.text.map.addrange( text, defs[cls].range, cls, true, map );
    }
    return map;
  }
  var markupcallback;
  this.setmarkupcallback = function( callback ) {
    var prev = markupcallback ? markupcallback : function(attrs){return attrs;};
    markupcallback = callback;
    return prev;
  }
  this.markupmap = function( text, map, opts ) {
    return SOT.map.markup( text, map, opts, defs, markupcallback );
  }
  this.markup = function( text, map=[], opts={overlayranges:true} ) {
    return SOT.map.markup( text, this.buildmap(text,map,opts.overlayranges), opts, defs, markupcallback );
  }
}

/*
 *  HTML = SOT.map.markup( text, map, opts, callback )
 *    generates layered html from a SOT.text.map
 *    (a SOT.PatternSeries object can be used to set regex/class associations and create the map)
 *
 *  The set names in the map (see SOT.text.map) are the CSS class names used in the mark up
 *
 *  Segments (intersections of overlapping ranges, see SOT.text.map) are marked up in layers
 *
 *  A segment's CSS class list indicates what part of the original range the segment was synthesized from:
 *    a leftmost segment includes "L" and a rightmost segment includes "R"
 *    a middle segment includes neither "L" nor "R"
 *    an unsegmented range includes both "L" and "R"
 *
 *  Examples:
 *
 *    a range of 'cls1' covers another of 'cls0', will be marked up as follows:
 *
 *      <mark class="cls0 L R">
 *        Some
 *        <mark class="cls1 L R">text</mark>
 *        is here
 *      </mark>
 *
 *    the order the patterns are applied is important, if 'cls1' is background:
 *
 *      <mark class="cls0 L">Some </mark>
 *      <mark class="cls1 L R">
 *        <mark class="cls0">text</mark>
 *      </mark>
 *      <mark class="cls0 R"> is here</mark>
 *
 *  'opts': {'htmltag': ..}
 *    if provided, 'htmltag' will be used instead of "mark" globally
 *      (tags can also be specified per-class in 'defs', see SOT.markup comments)
 *
 *  'callback': attrs = function( params )
 *    optional, will be fired on each tag, params:
 *      'attrs': passed in will be {'class': .., ...}, example: {'class': "cls1 L  "}
 *      'class': the class name
 *      'map': the text map
 *      'mapindex': index in 'map' array
 *      'layerindex': index in 'origs' subarray (see SOT.text.map)
 *      'opts': passed in opts
 *    callback can modify and/or add to 'attrs'
 */
SOT.map = {
  markup: function( fulltext, map, opts, defs, callback ) {
    function _tag( layer, end ) {
      var tag = 'mark';
      if (opts && opts.htmltag)
        tag = opts.htmltag;
      if (defs)
        if (end && defs[layer.setname].htmltagend != undefined)
          tag = defs[layer.setname].htmltagend;
        else
          if (defs[layer.setname].htmltag)
            tag = defs[layer.setname].htmltag;
      return tag;
    }
    function _addattrs( attrs, addattrs, origrange ) {
      for( const a in addattrs )
        if (addattrs[a] instanceof RegExp)
          attrs[a] = SOT.text.extract( fulltext.slice(origrange.start,origrange.end), addattrs[a] );
        else
          if (typeof addattrs[a] == 'string')
            attrs[a] = addattrs[a].replace( "$_&", fulltext.slice(origrange.start,origrange.end) );
      return attrs;
    }
    function _istagdif( seg, compareseg, layerindex ) {
      return (!compareseg || layerindex >= compareseg.origs.length || 
              seg.origs[layerindex].setname != compareseg.origs[layerindex].setname ||
              seg.origs[layerindex].range.setindex != compareseg.origs[layerindex].range.setindex);
    }
    function _difdepth( seg, compareseg ) {
      for( var depth=0; depth<seg.origs.length; depth++ )
        if (_istagdif( seg, compareseg, depth ))
          break;
      return depth;
    }
    /*
     * 
     */
    function _tagstart( seg, layer, mapindex, j, pieceindex, offset, insidetext ) {
      var tag = _tag(layer), t = "";
      /* build class attribute */
      var attrs = {'class': layer.setname};
      if (layer.range.start == seg.start)
        attrs['class'] += " L";
      if (defs && defs[layer.setname].htmlattrs)
        attrs = _addattrs( attrs, defs[layer.setname].htmlattrs, layer.range );
      /* get dynamic attributes if any */
      if (callback)
        attrs = callback( {'attrs':attrs,
                           class:layer.setname,
                           'map':map,
                           'mapindex':mapindex,
                           layerindex:j, 
                           'opts':opts} );
      /* markup html tag with attrs */
      t += "<" + tag;
      for( var a in attrs ) {
        t += " " + a + (attrs[a] ? ('="' + attrs[a]) : '');
        if (a == 'class') {
          t += "  ";
          starts[layer.setname] = {pos: offset+t.length-1, 'pieceindex': pieceindex, 'j': j, 'seg': seg};
        }
        t += attrs[a] ? '"' : '';
      }
      return t + ">";
    }
    function _layersstart( prevseg, seg, mapindex, pieceindex, insidetext ) {
      var j =_difdepth( seg, prevseg );
      for( var tags=""; j<seg.origs.length; j++ )
        tags += _tagstart( seg.range, seg.origs[j], mapindex, j, pieceindex, tags.length, insidetext );
      return {'tags':tags, 'insidetext':insidetext};
    }
    /*
     * 
     */
    function _tagend( layer ) {
      const tag = _tag( layer, true );
      if (!tag)
        return "";
      return "</" + SOT.text.extractto(tag, /^[A-Za-z0-9-_]+/) + ">";
    }
    function _layersend( seg, nextseg ) {
      var j =_difdepth( seg, nextseg );
      for( var t="",k=seg.origs.length-1; k>=j; k-- )
        t += _tagend( seg.origs[k] );
      return {tags:t};
    }
    function _setlayerright( seg ) {
      var piece = "";
      for( const layer of seg.origs ) {
        if (starts[layer.setname] && layer.range.end == seg.range.end) {
          /* (insert 'R' in class list) */
          piece = html[starts[layer.setname].pieceindex];
          piece = piece.slice( 0, starts[layer.setname].pos ) +
                  "R" +
                  piece.slice( starts[layer.setname].pos+1 );
          html[starts[layer.setname].pieceindex] = piece;
          delete starts[layer.setname];
        }
      }
    }
    const html = [];
    function htmladd( piece ) {
      if (piece)
        html.push( piece );
    }
    function htmlstring() {
      var hs = "";
      for( const piece of html )
        hs += piece;
      return hs;
    }
    var text = "", start = {}, end = {}, starts = {};
    var prevseg, seg, nextseg;
    for( var i=0,n=0; i<map.length; prevseg=seg,i++ ) {
      seg = map[i];
      htmladd( SOT.text.raw2HTML(fulltext.slice(n, seg.range.start)) );
      nextseg = i < map.length-1 ? map[i+1] : null;
      start = _layersstart( prevseg, seg, i, text ? html.length+1 : html.length, 
                            SOT.text.raw2HTML(fulltext.slice(seg.range.start,seg.range.end)) );
      if (start.tags) {
        htmladd( text ), text = "";
        htmladd( start.tags );
        htmladd( start.insidetext );
      }
      else
        text += start.insidetext;
      end = _layersend( seg, nextseg );
      if (end.tags) {
        if (text)
          htmladd( text + end.tags ), text = "";
        else
          htmladd( end.tags );
        _setlayerright( seg );
      }
      n = seg.range.end;
    }
    return htmlstring() + SOT.text.raw2HTML( fulltext.slice(n) );
  }
}

/*
 *  Text helpers
 */
SOT.text = {
  str2regex: function( regexstr, flags='' ) {
    regexstr = regexstr.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' );
    return new RegExp( regexstr, flags );
  },
  parseregexstr: function( str, reqflags='' ) {
    const regexparts = {pattern: SOT.text.extract( str, /(?<=^\/).+(?=\/\w*$)/ )};
    if (regexparts.pattern) {
      regexparts.flags = SOT.text.extract( str, /(?<=^\/.+\/)\w*$/ );
      if (!regexparts.flags)
        regexparts.flags = reqflags;
      else
        if (!SOT.text.extract( regexparts.flags, SOT.text.str2regex(reqflags) ))
          regexparts.flags += reqflags;
    }
    return regexparts;
  },
  regexstr2regex: function( str, reqflags='' ) {
    const regexparts = SOT.text.parseregexstr( str, reqflags );
    var regex;
    if (regexparts.pattern)
      regex = new RegExp( regexparts.pattern, regexparts.flags );
    else
      regex = SOT.text.str2regex( str, reqflags );
    return regex;
  },
  raw2HTML: function( text ) {
    var newtext = text.replace( /&/g, "&amp;" );
    newtext = newtext.replace( />/g, "&gt;" );
    return newtext.replace( /</g, "&lt;" );
  },
  startswith: function( s, sub ) {
    return s && sub && s.substring( 0, sub.length ) == sub;
  },
  extract: function( s, substr ) {
    const x = s.match( substr );
    if (x && x[0] !== null)
      return x[0];
    return null;
  },
  extractto: function( s, sub ) {
    s = s.match( sub );
    return s[0];
  },
  /* replace range */
  paste: function( text, range, replacewith ) {
    var newtext = text.slice( 0, range.start );
    var token = text.substring( range.start, range.end );
    //newtext += token.replace( SOT.text.str2regex(token,''), replacewith );
    newtext += token.replace( token, replacewith );
    newtext += text.slice( range.end );
    return newtext;
  }
}

/*
 *  SOT.text.map
 *    builds segmented range maps from series of regex matches
 *
 *    map = SOT.text.map.addmatches( text, regex, setname, segment?, map=[] )
 *      adds set of ranges matching regex to map
 *
 *    map = SOT.text.map.addrange( text, range, setname, segment?, map=[] )
 *      adds a range to map
 *
 *  Maps are ordered arrays, each element has the form {range:{start:., end:.}, origs:[...]}
 *
 *  Maps are flat, 'segment?' determines how ranges that overlap or cover others are treated when being added:
 *    !: range being added will overwrite any it overlaps or covers (usurped ranges are discarded)
 *    else: overlapping or covered ranges are segmented
 *
 *  The 'origs' array specifies what range(s) a segment was synthesized from:
 *    each element of 'origs' has the form: {setname:"..", range:{start:.,end:.}}
 *      example: intersection segment resulting from a range of "set0" overlapping one of "set1": 
 *               origs = [{setname:"set0", range:..}, {name:"set1", range:..}]
 *    for unsegmented ranges, origs = [{setname:<samename>, range:<samerange>}
 *
 *  Replace operations:
 *
 *    text = SOT.text.map.replace( text, map, i, newtext )
 *      replaces range i in text with newtext
 *
 *    text = SOT.text.map.replaceall( text, map, i, replacewiths )
 *      replaces all ranges, replacewiths = {setname:"new text", ...}
 *      segment's setname determines the replacement text to use (replacewiths[segment.origs[0].setname])
 *
 *   Segmented ranges are ignored during replacements (replace ops on segments are nonsensical)
 */
SOT.text.map = {
  range: {
    neworigs: function( setname, range={start:0,end:0,setindex:0} ) {
      if (typeof setname == 'string')
        return [{'setname':setname, 'range':{start:range.start,end:range.end,'setindex':range.setindex}}];
      return set;
    },
    mk: function( start, end, origs ) {
      return {range:{'start':start, 'end':end}, 'origs':origs};
    },
    copy: function( r ) {
      return {range:{start:r.start, end:r.end}, origs:r.origs};
    },
    isposin: function( pos, map, i ) {
      return (i >= 0 && i < map.length && pos >= map[i].range.start && pos <= map[i].range.end);
    },
    next: function( pos, map ) {
      var i = -1, test = 0;
      if (map.length) {
        if (map[0].range.end > pos)
          i = 0;
        else {
          i = map.length - 1;
          if (pos < map[i].range.start) {
            var j = map.length/2;
            for( i=j;
                 Math.round(j);
                 j/=2, map[Math.round(i)].range.end<=pos ? i+=j : i-=j, test++ ) //(bin search)
              ;
            i = Math.round( i );
          }
        }
        //console.log( "BINSEARCH 0: " + test );
        for( ; i < map.length && map[i].range.end <= pos; i++, test++ )
          ;
        //console.log( "BINSEARCH 1: " + test );
      }
      return i;
    },
    before: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (i >= 0 && SOT.text.map.range.isposin( pos, map, i ))
        i++;
      return i >= 0 ? Math.max(0,i-1) : i;
    },
    after: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (SOT.text.map.range.isposin( pos, map, i ))
        i++;
      return i;
    },
    nearest: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      i = Math.min( i, map.length-1 );
      if (i > 0 && !SOT.text.map.range.isposin( pos, map, i )) {
        if (pos < ((map[i].range.start - map[i-1].range.end) / 2) + map[i-1].range.end)
          i--;
      }
      return i;
    },
    atpos: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (!SOT.text.map.range.isposin( pos, map, i ))
        i = -1;
     return i;
    }
  },
  /*
   * segmentation loop illustration (_segment):
   *
   *    is0----ie0  is1--ie1        is2----ie2   target sequence, first ie > ms
   *        ms--------------------------me       input (range to add)
   * *
   *    continues while isN < me
   *
   *    is0----ie0
   *        ms--------------------------me
   *    is0-ms-ie0                               segments = [mins,maxs,mine]
   *           ie0----------------------me       next input = [mine,maxe]
   *
   *                is1--ie1
   *           ms-----------------------me
   *           ms---is1--ie1                     segments = [mins,maxs,mine]
   *                     ie1------------me       next input = [mine,maxe]
   *
   *                                is2----ie2
   *                     ms-------------me
   *                     ms---------is2-me       segments = [mins,maxs,mine]
   *                                    me-ie2   next input = [mine,maxe]
   *
   *                                    ms--me   last (dangling) segment
   */
  _seg2: function( m, i, p ) {
    var r = {start:Math.min(m.range.start, i.range.start), end:Math.max(m.range.start, i.range.start)};
    if (r.start < r.end)
      p.newmap.push( SOT.text.map.range.mk(r.start,r.end,r.start<i.range.start?m.origs:i.origs) );
    r = {start:Math.max(m.range.start, i.range.start), end:Math.min(m.range.end, i.range.end)};
    p.newmap.push( SOT.text.map.range.mk(r.start,r.end,[...i.origs,...m.origs]) );
    r = {start:Math.min(m.range.end, i.range.end), end:Math.max(m.range.end, i.range.end)};
    return SOT.text.map.range.mk( r.start, r.end, r.start<m.range.end?m.origs:i.origs );
  },
  _segment: function( start, end, origs, map=[], p ) {
    var m = SOT.text.map.range.mk( start, end, origs );
    if (p.newmap.length && m.range.start < p.newmap[p.newmap.length-1].range.end) {
      /* (edge case: when ranges are added in sequence (regex matches), newmap may contain an iceberg segment) */
      var i = p.newmap.pop();
      m = SOT.text.map._seg2( m, i, p );
    }
    for( ; p.i<map.length && map[p.i].range.start<m.range.end; p.i++ )
      m = SOT.text.map._seg2( m, map[p.i], p );
    if (m.range.start < m.range.end)
      p.newmap.push( m );
    return p;
  },
  /* insert range at current location; discard ranges it overlaps or covers */
  _overwrite: function( start, end, origs, map=[], p ) {
    p.newmap.push( SOT.text.map.range.mk(start,end,origs) );
    for( ; p.i < map.length && map[p.i].range.end <= end; p.i++ )
      ;
    if (p.i < map.length && map[p.i].range.start < end)
      p.i++;
    return p;
  },
  /* insert a range into map; overwrite or segment overlapping/covered ranges */
  _insertrange: function( start, end, set, map, segment, p={newmap:[],i:0,setindex:0} ) {
    for( ; p.i < map.length && map[p.i].range.end <= start; p.i++ )  // add all before entries
      p.newmap.push( map[p.i] );
    var origs = SOT.text.map.range.neworigs( set, {'start':start,'end':end,'setindex':p.setindex} );
    if (segment)
      p = SOT.text.map._segment( start, end, origs, map, p );
    else
      p = SOT.text.map._overwrite( start, end, origs, map, p );
    return p;
  },
  /* add trailing ranges */
  _addendranges: function( map=[], p ) {
    for( ; p.i<map.length; p.i++ )
      p.newmap.push( map[p.i] );
    return p.newmap;
  },
  /* add ranges from regex match to map */
  addmatches: function( text, regex, setname, segment, map=[], alertiferror ) {
    var p = {newmap:[],i:0,setindex:0};
    var matches;
    try {
      matches = text.matchAll( regex );
    }
    catch( e ) {
      if (alertiferror)
        alert( e );
      return map;
    }
    /* (optimization: matches are added in a single pass) */
    for( const match of matches ) {
      p = SOT.text.map._insertrange( match.index, match.index+match[0].length, setname, map, segment, p );
      p.setindex++;
    }
    return SOT.text.map._addendranges( map, p );
  },
  /* add ranges from regex match to map */
  _X_addmatches: function( text, regex, setname, segment, map=[] ) {
    var p = {newmap:[],i:0,setindex:0};
    /* (optimization: matches are added in a single pass) */
    var match;
    while( match = regex.exec(text) )
      if (match[0].length) {
        p = SOT.text.map._insertrange( match.index, match.index+match[0].length, setname, map, segment, p );
        p.setindex++;
      }
      else {
        regex.lastIndex++;
  //console.log( regex );
      }
    return SOT.text.map._addendranges( map, p );
  },
  /* add a range to map */
  addrange: function( text, range, setname, segment, map=[] ) {
    if (range.start > range.end)
      range = {start:range.end, end:range.start};
    var p = SOT.text.map._insertrange( range.start, range.end, setname, map, segment );
    return SOT.text.map._addendranges( map, p );
  },
  /* replace all ranges, replacewiths={setname:"..", ...} */
  replaceall: function( text, map, replacewiths ) {
    if (!map.length)
      return text;
    var newtext = "", token;
    for( var i=0,n=0; i<map.length; i++ ) {
      newtext += text.slice( n, map[i].range.start );
      token = text.substring( map[i].range.start, map[i].range.end );
      if (map[i].origs.length == 1 &&
          map[i].origs[0].range.start == map[i].range.start && map[i].origs[0].range.end == map[i].range.end)
        //newtext += token.replace( SOT.text.str2regex(token,''), replacewiths[map[i].origs[0].setname] );
        newtext += token.replace( token, replacewiths[map[i].origs[0].setname] );
      else
        newtext += token;
      n = map[i].range.end;
    }
    newtext += text.slice( n );
    return newtext;
  },
  /* replace a range */
  replace: function( text, map, i, newtext ) {
    if (i >= map.length)
      return text;
    var replacewiths = {};
    replacewiths[map[i].origs[0].setname] = newtext;
    return SOT.text.map.replaceall( text, [map[i]], replacewiths );
  }
}
  </script>

  <!--script type="text/javascript" src="lib/texteditor.js"/script-->
  <script>
/*
 * texteditor.js
 *
 *   UI.TextEditor:          controller for editable content
 *   UI.texteditor.UndoRedo: undo/redo attachment for a text editor
 *   UI.texteditor.Search:   basic (notepad-like) search/replace attachment
 *   UI.FontPicker:          font picker
 *   TextFileIO:             open and save files
 *
 *   single step init:       editor = UI.texteditor.createinit( elemid, opts={} )
 *
 * texteditor.html provides example of use
 *
 * cc0 (public domain) v.010 September 2025, latest version @ github.com/gregsidal
 */
const UI = {};

UI.texteditor = UI.texteditor ? UI.texteditor : {
  createinit: function( elemid, opts ) {
    const editor = new UI.texteditor.Components( elemid, opts );
    editor.get('texteditor').initrefresh();
    return editor;
  }
};

/*
 * Create a texteditor with optional undoredo, basic search, and/or fontpicker attachments
 *
 * To initialize with all attachments using default opts:
 *   components = new UI.texteditor.Components( editablecontentelemid, opts={undoredo:{},basicsearch:{},fontpicker:{}} )
 *
 * To get a component:
 *   component = components.get( componentname='texteditor' )
 */
UI.texteditor.Components = function( texteditorid, opts={} ) {
  var components = {};
  /* setup text editor */
  components.texteditor = new UI.TextEditor();
  components.texteditor.init( texteditorid, opts.texteditor );
  /* attach undo/redo component if opted for */
  if (opts.undoredo) {
    components.undoredo = new UI.texteditor.UndoRedo();
    components.undoredo.init( components.texteditor, opts.undoredo );
  }
  /* attach fontpicker if opted for */
  if (opts.fontpicker) {
    function onfontselected( name ) {
      components.texteditor.setfont( name );
    }
    components.fontpicker = new UI.FontPicker();
    components.fontpicker.init( onfontselected, opts.fontpicker );
  }
  /* attach basic search if opted for */
  if (opts.basicsearch) {
    components.basicsearch = new UI.texteditor.Search();
    components.basicsearch.init( components.texteditor, opts.basicsearch );
  }
  this.add = function( componentname, component ) {components[componentname] = component; return component;}
  this.get = function( componentname='texteditor' ) {return components[componentname];}
  this.rem = function( componentname ) {delete components[componentname];}
}


/*
 * Text editor UI control
 *   uses a callback to dynamically mark up text as its edited
 *
 * To initialize:
 *   texteditor = new UI.TextEditor()
 *   texteditor.init( elemorid )
 *   texteditor.setcallback( 'remarkup', remarkupcallback );
 *   texteditor.initrefresh()  // (ingest and markup the initial text in the element)
 *
 * 'elemorid' (div most likely) will be given "contenteditable='plaintext-only'" property.
 *
 * Functionality is designed to minimize remarkups
 *
 * Callbacks:
 *
 *   HTML = remarkup( plaintext, e2 )
 *     callback is fired when refreshing,
 *     should mark up 'plaintext' and return the HTML
 *
 *   refresh? = statechanged( e2 )
 *     callback is fired from any event or API call that changes text or moves caret
 *       (text changes can also move the caret, but the callback is fired only once)
 *     if callback returns true, remarkup will take place
 *       (the default callback returns true when 'e2.textchanged' is true)
 *
 *   beforetextchange( e2 )
 *     triggered just before text changes (fired by 'beforeinput' event and also API calls that change text) 
 *
 *   to set a callback: prevcallback = texteditor.setcallback( 'callback', f )
 *     (callbacks override others previously set; callbacks should save and call 'prevcallback')
 *
 *   the UndoRedo component below provides examples of callback use
 *
 * Callbacks and most API functions work with an 'e2' parameter, which can include:
 *   action: string indicating what's happening
 *   event: browser event if any
 *   textchanged?: true when text has changed
 *   selrange: selected range or caret position
 *   prevselrange: previous selection range
 *
 * All positions, including selection start/end, are absolute in plaintext
 *
 * texteditor.el()
 *   get text editor HTML element
 *
 * texteditor.setfont( fn )
 *   set font
 *
 * texteditor.zoom( incr = 1 )
 *   zoom in or out (-1)
 *
 * texteditor.wrap( w )
 *   set wrap mode
 *
 * texteditor.put( text, e2={action:"insertFromPut"}, selrange={0,0} )
 *   replace entire text (resets caret/selected range to selrange)
 *
 * texteditor.insert( pastetext, e2={action:"insertFromInsert"}, range=selection, select=true )
 *   insert text into specified or selected range, select insertion when select == true
 *
 * texteditor.getselrange( normalize )
 *   get selected range or caret position
 *   selection range has directionality, i.e., end may be before start; 'normalize' forces start <= end
 *
 * texteditor.setselrange( r, e2={action:'selchangeFromReset'} )
 *   set selected range or caret position (when start == end)
 *
 * texteditor.setcaretpos( pos=-1, e2={action:'selchangeFromReset'} )
 *   set caret position, resets to last position when -1
 *
 * texteditor.focusto( e2={action:"focusTo"}, selrange=this.getselrange() )
 *   focus and set caret position/selected range
 *
 * texteditor.refresh( e2={action:'refresh'} )
 *   remarkup, does not fire state change callback
 *
 * texteditor.scrollelemintoview( el, opts )
 *   scroll to a marked up element in innerHTML
 */
UI.texteditor.defaultopts = {
  ids: {
    wraptoggle: 'texteditor-wraptoggle',
    zoominbtn:  'texteditor-zoominbtn',
    zoomoutbtn: 'texteditor-zoomoutbtn'
  }
};
UI.TextEditor = function() {
  /* init */
  this.init = function( texteditorid, opts ) {
    function defaultstatechangecallback( e2 ) {
      return e2.textchanged;
    }
    function defaultremarkupcallback( plaintext, e2 ) {
      return UI.h.text2html( plaintext );
    }
    _i.textarea = UI.h.el( texteditorid );
    this.setproperty( 'contentEditable', "plaintext-only", "true" );
    this.setcallback( 'beforetextchange' );
    this.setcallback( 'statechanged', defaultstatechangecallback );
    this.setcallback( 'remarkup', defaultremarkupcallback );
    _i.textarea.addEventListener( "scroll", _i.onscroll );
    _i.textarea.addEventListener( "focus", _i.onfocus, {passive:false} );
    _i.textarea.addEventListener( "blur", _i.onblur );
    document.addEventListener( "selectionchange", _i.onselect );
    _i.textarea.addEventListener( "beforeinput", _i.onbeforeinput );
    _i.textarea.addEventListener( "input", _i.oninput );
    _i.textarea.addEventListener( "click", _i.onclick );
    this.changed( false );
    this.initctls( opts );
  }
  this.initctls = function( opts=UI.texteditor.defaultopts ) {
    _i.ids = opts.ids ? opts.ids : UI.texteditor.defaultopts.ids;
    UI.h.defocusize( [_i.ids.wraptoggle, _i.ids.zoominbtn, _i.ids.zoomoutbtn] );
    UI.h.listen( _i.ids.wraptoggle, "click", _i.wrap );
    UI.h.listen( _i.ids.zoominbtn, "click", _i.zoomin );
    UI.h.listen( _i.ids.zoomoutbtn, "click", _i.zoomout );
    var initialwrap = true;
    if (UI.h.el( _i.ids.wraptoggle ))
      initialwrap = UI.h.el(_i.ids.wraptoggle).checked;
    this.wrap( initialwrap );
    _i.resetctls();
  }
  /* set a textarea element property */
  this.setproperty = function( attrname, attrvalue, alertonerror ) {
    UI.h.setproperty( _i.textarea, attrname, attrvalue, alertonerror );
  }
  /* set properties for plain (code) editor vs spell-checking editor */
  this.seteditproperties = function( plain, alertonerror ) {
    UI.h.seteditproperties( _i.textarea, plain, alertonerror );
  }
  /* set a callback */
  this.setcallback = function( cbn, cb ) {
    function __f(){};
    const pcb = _i.callbacks[cbn];
    _i.callbacks[cbn] = cb ? cb : __f;
    return pcb;
  }
  /* get editor HTML element; get plaintext of element */
  this.el = this.tel = function() {return _i.textarea;}
  this.get = function() {return _i.textarea.innerText;}
  this.changed = function( setto ) {
    if (setto != undefined)
      _i.changed = setto;
    return _i.changed;
  }
  /* get whether editor is focused */
  this.isfocused = function() {return _i.focused;}
  /* set font */
  this.setfont = function( fn ) {
    _i.textarea.style['font-family'] = fn;
  }
  /* zoom in or out */
  this.zoom = function( incr = 1 ) {
    _i.zoom( incr );
  }
  /* get or set wrap mode */
  this.wrap = function( w ) {
    if (w == undefined)
      return _i.textarea.style['white-space'] == 'pre-wrap';
    _i.wrap( null, w );
    if (UI.h.el( _i.ids.wraptoggle ))
      UI.h.el( _i.ids.wraptoggle ).checked = w;
    return w;
  }
  /* replace text */
  this.put = function( newtext, e2={action:"insertFromPut"}, selrange={start:0,end:0} ) {
    _i.textwillchg( e2 );
    var text = this.get();
    _i.textarea.innerText = newtext;
    _i.textchg( e2, selrange );
    if (selrange.end == 0)
      _i.textarea.scrollLeft = 0, _i.textarea.scrollTop = 0;
    return selrange;
  }
  /* insert text into range (paste) */
  this.insert = function( pastetext, e2={action:"insertFromInsert"}, range, select=true ) {
    _i.textwillchg( e2 );
    var text = this.get();
    range = range ? range : this.getselrange( true );
    var len = text.length;
    text = text.substring(0,range.start) + pastetext + text.substring(range.end);
    range = {start:range.start, end:range.end + (text.length - len)};
    _i.textarea.innerText = text;
    e2.insertedrange = range;
    _i.textchg( e2, select ? range : {start:range.end, end:range.end} );
    return range;
  }
  /* get sel range or caret pos (caret pos is always selrange.end, end may be before start) */
  this.getselrange = function( normalize ) {return _i.getselrange(normalize);}
  this.getcaretpos = function() {return _i.getcaretpos();}
  /* set caret/selection (may fire 'onstatechange' callback) */
  this.setselrange = function( r, e2={action:'selchangeFromReset'} ) {
    return _i.resetselrange( e2, r );
  }
  /* set caret (may cause 'onstatechange' callback to be fired) */
  this.setcaretpos = function( pos=-1, e2 ) {
    pos = pos < 0 ? this.getcaretpos() : pos;
    return this.setselrange( {start:pos, end:pos}, e2 );
  }
  /* raw remarkup (does not fire state change) */
  this.refresh = function( e2={action:'refresh'} ) {
    _i.remarkup( e2 );
  }
  /* full re-markup (fires state change callback) */
  this.textchanged = function( e2={action:"textChanged"} ) {
    _i.textchg( e2 );
  }
  /* full markup of text in textarea HTML (fires callback) */
  this.initrefresh = function() {
    this.textchanged( {action:"insertFromInit"} );
  }
  /* get scroll position */
  this.getscrollpos = function() {
    return {left:_i.textarea.scrollLeft, top:_i.textarea.scrollTop};
  }
  /* scroll to a scroll position */
  this.scrollto = function( scrollpos={left:0,top:0}, opts ) {
    UI.h.scrolltopos( _i.textarea, scrollpos.left, scrollpos.top, opts );
  }
  /* scroll to an marked up element */
  this.scrollelemintoview = function( el, opts ) {
    UI.h.scrollelemintoview( _i.textarea, el, opts );
  }
  /* scroll to a marked up element cluster */
  this.scrollelemsintoview = function( els, opts ) {
    UI.h.scrollelemsintoview( _i.textarea, els, opts );
  }
  /* focus and set caret/selection */
  this.focusto = function( e2={action:"focusTo"}, selrange=this.getselrange() ) {
    _i.focused = true;
    if (!_i.resetselrange( e2, selrange ))
      _i.hardsetselrange();
    _i.textarea.focus();
  }
  /* internals */
  var _i = {
    resetctls: function() {
    },
    wrap: function( e, w ) {
      const curw = _i.textarea.style['white-space'] == 'pre-wrap';
      if (w == undefined)
        w = !curw;
      if (w != curw)
        _i.textarea.style['white-space'] = w ? 'pre-wrap' : 'pre';
    },
    zoom: function( incr = 1 ) {
      UI.h.zoom( incr, _i.textarea );
    },
    zoomin: function( e ) {
      _i.zoom( 1 );
    },
    zoomout: function( e ) {
      _i.zoom( -1 );
    },
    keepselection: true,
    textarea: null,
    callbacks: {},
    selrange: {start:0, end:0}, prevselrange: {start:0, end:0},
    getselrange: function( normalize ) {
      var r = {start:_i.selrange.start, end:_i.selrange.end};
      if (normalize)
        r = r.end < r.start ? {start:r.end, end:r.start} : r;
      return r;
    },
    getcaretpos: function() {
      return _i.getselrange().end;
    },
    getabsselrange: function() {
      var r = UI.h.getabsselrange( _i.textarea );
      if (!r)
        r = _i.selrange;
      return r;
    },
    snapselrange: function() {
      _i.selrange = _i.getabsselrange( _i.textarea );
      _i.conlog( {f:"snapselrange", start:_i.selrange.start, end:_i.selrange.end}, 1 );
      return _i.selrange;
    },
    hardsetselrange: function() {
      if (_i.focused) {
        UI.h.setabsselrange( _i.selrange, _i.textarea );
        _i.conlog( {f:"hardsetselrange", start:_i.selrange.start, end:_i.selrange.end}, 4 );
      }
    },
    resetselrange: function( e2={action:'selchangeFromReset'}, r ) {
      e2.prevselrange = {start: _i.selrange.start, end: _i.selrange.end};
      if (!r)
        r = _i.snapselrange();
      _i.selrange = {start:r.start, end:r.end};
      e2.selrange = r;
      e2.focused = _i.focused;
      var refreshed = _i.callbacks.statechanged( e2 );
      if (refreshed)
        _i.remarkup( e2 );
      _i.conlog( {f:"resetselrange", 'e2':e2, 'refreshed':refreshed}, 3 );
      return refreshed;
    },
    scroll: {left:0, top:0},
    onscroll: function() {
      _i.conlog( {f:"onscroll"}, 1 );
      _i.scroll = {left:_i.textarea.scrollLeft, top:_i.textarea.scrollTop};
    },
    onfocus: function( e ) {
      var r = UI.h.getabsselrange( _i.textarea );
      _i.conlog( {f:"onfocus", 'start':r?r.start:'undef', 'end':r?r.end:'undef', 'e':e}, 4 );
      /* (the assumption is that if the user has scrolled that's what they wanted to do) */
      _i.textarea.scrollLeft = _i.scroll.left, _i.textarea.scrollTop = _i.scroll.top;
    },
    onblur: function() {
      _i.conlog( {f:"onblur"}, 1 );
      _i.focused = false;
      _i.resetselrange( {action:'blur'} );
    },
    onselect: function( e ) {
      var r = UI.h.getabsselrange( _i.textarea );
      if (r) {
        var restoresel, e2 = {action:'selchangeFromSelect', event:e};
        _i.conlog( {f:"onselect", 'start':r.start, 'end':r.end, 'e':e}, 6 );
        if (!_i.focused && r.start == r.end) {
          e2.action = 'selchangeFromFocus';
          const selr = _i.getselrange( true );
          /* restore prev selection if user is focusing by tapping in that selected range */
          /* restore prev caret/selection if it looks like a focus is idiotically forcing a reset to top */
          if (r.end == 0 || (selr.start < selr.end && r.start >= selr.start && r.end <= selr.end)) {
            r = _i.getselrange();
            _i.conlog( {f:"-- RESTORE SEL", 'start':_i.selrange.start, 'end':_i.selrange.end}, 6 );
            restoresel = true;
          }
        }
        const pr = _i.getselrange();
        if (!_i.focused || r.start != pr.start || r.end != pr.end) {
          _i.focused = true;
          if (!_i.resetselrange( e2, r ))
            if (restoresel)
              _i.hardsetselrange();
        }
      }
    },
    onbeforeinput: function( e ) {
      _i.conlog( {f:"onbeforeinput"}, 1 );
      _i.textwillchg( {action:e.inputType, inputType:e.inputType, event:e} );
    },
    oninput: function( e ) {
      _i.conlog( {f:"oninput"}, 1 );
      _i.textchg( {action:e.inputType, inputType:e.inputType, event:e} );
    },
    onclick: function( e ) {
      //_i.conlog( {f:"onclick", 'e':e}, 6 );
      //if (!_i.focused)
        //_i.clicked = true;
      //_i.hardsetselrange();
    },
    textwillchg: function( e2 ) {
      e2.inputType = e2.inputType ? e2.inputType : e2.action;
      return _i.callbacks.beforetextchange( e2 );
    },
    textchg: function( e2={action:"selchangeFromInput"}, r ) {
      _i.changed = true;
      e2.textchanged = true;
      return _i.resetselrange( e2, r );
    },
    remarkup: function( e2 ) {
      _i.conlog( {f:"remarkup", 'action':e2.action, 'e2':e2}, 4 );
      _i.conlog( {f:"remarkup 1", innerText:_i.textarea.innerText}, 3 );
      if (_i.callbacks.remarkup)
        _i.textarea.innerHTML = _i.callbacks.remarkup( _i.textarea.innerText, e2 );
      _i.hardsetselrange();
      _i.conlog( {f:"remarkup 2", innerText:_i.textarea.innerText, innerHTML:_i.textarea.innerHTML}, 3 );
    },
    conmsg: false,
    conmsggroup: 6,
    conlog: function( msg, group ) {
      if (_i.conmsg && _i.conmsggroup == group) console.log( msg );
    }
  }
}

/*
 *  Undo/redo attachment for TextEditor
 *
 *  To set up:
 *    undoredo = new UI.texteditor.UndoRedo();
 *    undoredo.init( texteditor, opts=UI.texteditor.undoredo.defaultopts );
 *
 *  The controls in 'ids' trigger the undo and redo operations when clicked
 */
UI.texteditor.undoredo = {
  defaultopts: {
    ids: {
      undobtn:  'undoredo-undobtn',
      redobtn:  'undoredo-redobtn'
    },
    lockctls: true
  }
}
UI.texteditor.UndoRedo = function() {
  this.init = function( texteditor, opts=UI.texteditor.undoredo.defaultopts ) {
    _i.texteditor = texteditor;
    _i.ids = opts.ids ? opts.ids : UI.texteditor.undoredo.defaultopts.ids;
    _i.prevbeforechangecallback = _i.texteditor.setcallback( 'beforetextchange', _i.onbeforeinput );
    _i.prevchangecallback = _i.texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    UI.h.defocusize( [_i.ids.undobtn, _i.ids.redobtn] );
    this.lockctls( opts.lockctls );
  }
  this.lockctls = function( lock=true ) {
    if (lock) {
      UI.h.listen( _i.ids.undobtn, "click", _i.undo );
      UI.h.listen( _i.ids.redobtn, "click", _i.redo );
      _i.resetctls();
    }
    else {
      UI.h.ignore( _i.ids.undobtn, "click", _i.undo );
      UI.h.ignore( _i.ids.redobtn, "click", _i.redo );
    }
  }
  this.undo = function() {
    _i.undo();
  }
  this.redo = function() {
    _i.redo();
  }
  this.clear = function() {
    _i.clear();
  }
  this.reset = function() {
    _i.resetctls();
  }
  // internals
  var _i = {
    texteditor: null, ids: {},
    resetctls: function() {
      var states = {canundo: _i.undolog.length,
                    canredo: _i.redolog.length};
      UI.h.enable( _i.ids.undobtn, states.canundo );
      UI.h.enable( _i.ids.redobtn, states.canredo );
    },
    clear: function() {
      _i.undolog = [], _i.redolog = [], _i.mark = false;
      _i.previnputtype = "", _i.wasblank = true;
      _i.resetctls();
    },
    undolog:[], redolog:[],
    log: function( log, text, selrange=_i.texteditor.getselrange(), 
                   wrap=_i.texteditor.wrap(), scrollpos=_i.texteditor.getscrollpos() ) {
      log.push( {'text':text, 'selrange':selrange, 'wrap':wrap, 'scrollpos':scrollpos} );
    },
    unlog: function( log, e2 ) {
      const le = log.pop();
      _i.texteditor.put( le.text, e2, le.selrange );
      _i.texteditor.wrap( le.wrap );
      _i.texteditor.scrollto( le.scrollpos );
    },
    willchange: function( action ) {
      const t = _i.texteditor.get();
      if (t) {
        _i.redolog = [];
        _i.log( _i.undolog, t );
        _i.mark = true;
      }
    },
    haschanged: function() {
      const t = _i.texteditor.get();
      if (_i.mark && t) {  // (remove trailing line feeds)
        var len = t.length;
        for( var i=t.length-1; i>=0; i-- )
          if (t[i] == '\n' || t[i] == ' ')
            len--;
          else
            break;
        if (len < t.length) {
          var t2 = t.slice( 0, len );
          if (t2 == _i.undolog[_i.undolog.length-1])
            _i.undolog.length--;
        }
      }
      _i.mark = false;
      _i.resetctls();
    },
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      if (e2.group && e2.group.more)
        return refresh;
      if (e2.textchanged) {
        if (e2.action != "insertFromUndo" && e2.action != "insertFromRedo")
          _i.haschanged();
        _i.previnputtype = e2.action;
        _i.resetctls();
      }
      return refresh;
    },
    undo: function() {
      if (!_i.undolog.length)
        return alert( "No edit history" );
      _i.log( _i.redolog, _i.texteditor.get() ); 
      _i.unlog( _i.undolog, {action:"insertFromUndo"} );
    },
    redo: function() {
      if (!_i.redolog.length)
        return alert( "No undo history" );
      _i.log( _i.undolog, _i.texteditor.get() );
      _i.unlog( _i.redolog, {action:"insertFromRedo"} );
    },
    previnputtype: "", wasblank: true,
    onbeforeinput: function( e ) {
      const ret = _i.prevbeforechangecallback( e );
      if (e.inputType == "insertFromUndo" || e.inputType == "insertFromRedo")
        return;
      if (e.group && !e.group.start)
        return;
      //console.log( 'beforeinput previnputtype: ' + _i.previnputtype );
      //console.log( 'beforeinput inputtype: ' + e.inputType );
      //if (e.inputType == "insertLineBreak")
        //return;
      //console.log( "oninput, e=", e );
      function startswith( s, sub ) {
        return s && sub && s.substring( 0, sub.length ) == sub;
      }
      if (startswith( e.inputType, "insertFrom" ) || startswith( _i.previnputtype, "insertFrom" )) 
        _i.willchange( e.inputType );
      else {
        var pt = _i.previnputtype;
        var t = e.inputType;
        const ins = "insert";
        if (startswith( t, "delete" ))
          t = ins;
        if (startswith( pt, "delete" ))
          pt = ins;
        if (t.substring( 0, ins.length ) != pt.substring( 0, ins.length ))
          _i.willchange( e.inputType );
      }
      return ret;
    }
  }
}

/*
 *  Basic (notepad-like) search/replace attachment for a TextEditor
 *
 *  To set up:
 *    search = new UI.texteditor.Search();
 *    search.init( texteditor, ids=UI.search.defaultids );
 *
 *  The controls in 'ids' trigger the search/replace functions
 */
UI.texteditor.search = {
  defaultopts: {
    ids: {
      find:           'search-find',        //input
      findbtn:        'search-findbtn',
      nextbtn:        'search-nextbtn',
      replace:        'search-replace',     //input
      replacebtn:     'search-replacebtn',
      replaceallbtn:  'search-replaceallbtn'
    },
    classes: {
      current:        'search-current'
    },
    regexflags:       'g'
  }
};
UI.texteditor.Search = function() {
  this.init = function( texteditor, opts = UI.texteditor.search.defaultopts ) {
    _i.texteditor = texteditor;
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    _i.prevremarkupcallback = texteditor.setcallback( 'remarkup', _i.onremarkup );
    _i.ids = opts.ids ? opts.ids : UI.texteditor.search.defaultopts.ids;
    _i.classes = opts.classes ? opts.classes : UI.texteditor.search.defaultopts.classes;
    _i.regexflags = opts.regexflags ? opts.regexflags : UI.texteditor.search.defaultopts.regexflags;
    //UI.h.defocusize( [_i.ids.findbtn, _i.ids.nextbtn, _i.ids.replacebtn, _i.ids.replaceallbtn] );
    UI.h.listen( _i.ids.findbtn, "click", _i._find );
    UI.h.listen( _i.ids.nextbtn, "click", _i._next );
    UI.h.listen( _i.ids.replacebtn, "click", _i.replace );
    UI.h.listen( _i.ids.replaceallbtn, "click", _i.replaceall );
    UI.h.seteditproperties( _i.ids.find, true );
    UI.h.seteditproperties( _i.ids.replace, true );
    UI.h.listen( _i.ids.find, "input", _i.clear );
    _i.resetctls();
  }
  this.clear = function() {
    _i.clear( null );
  }
  this.find = function( verbose=true ) {
    _i.find( verbose );
  }
  this.next = function( start, verbose ) {
    _i.next( start, verbose );
  }
  this.scrollcurrentintoview = function( opts ) {
    _i.scrollcurrentintoview( opts );
  }
  this.replace = function() {
    return _i.replace();
  }
  // internals
  var _i = {
    texteditor: null,
    action: function( e, t ) {
      return e && e.action && e.action.substring( 0, t.length ) == t;
    },
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      if (e2.action == 'selchangeFromFocus')
        refresh = true;
      else
        if (!e2.focused)
          if (e2.selrange.start != e2.selrange.end || e2.prevselrange.start != e2.prevselrange.end)
            refresh = true;
      _i.resetctls();
      return refresh;
    },
    onremarkup: function( plaintext, e2 ) {
      var html;
      const sr = _i.texteditor.getselrange( true );
      if (sr.start != sr.end && !e2.focused) {
        html = UI.h.text2html( plaintext.substring(0,sr.start) ) + 
               "<mark class='" + _i.classes.current + "'>" + 
               UI.h.text2html( plaintext.substring(sr.start,sr.end) ) +
               "</mark>" + 
               UI.h.text2html( plaintext.substring(sr.end) );
      }
      else
        html = _i.prevremarkupcallback( plaintext, e2 );
      return html;
    },
    resetctls: function() {
      const cantfind = !UI.h.get( _i.ids.find );
      const sr = _i.texteditor.getselrange();
      const end = sr.end >= (_i.texteditor.get().length-1);
      const cantreplace = sr.start == sr.end;
      UI.h.el( _i.ids.findbtn ).disabled = cantfind;
      UI.h.el( _i.ids.nextbtn ).disabled = cantfind || end;
      UI.h.el( _i.ids.replacebtn ).disabled = cantreplace;
      UI.h.el( _i.ids.replaceallbtn ).disabled = cantreplace;
    },
    clear: function( e ) {
      _i.resetctls();
    },
    nextrange: function( start=-1, text=_i.texteditor.get() ) {
      const regexstr = UI.h.get( _i.ids.find );
      start = start >= 0 ? start : _i.texteditor.getselrange( true ).end;
      const matches = text.matchAll( new RegExp(regexstr,_i.regexflags) );
      var r;
      for( const match of matches ) {
        if (match.index >= start) {
          r = {start:match.index, end:match.index+match[0].length};
          break;
        }
      }
      return r;
    },
    next: function( e2={action:'selchangeFromNext'}, start=_i.texteditor.getselrange(true).end, verbose=true ) {
      var r = _i.nextrange( start );
      if (!r)
        r = {start:_i.texteditor.get().length, end:_i.texteditor.get().length};
      _i.texteditor.setselrange( r, e2 );
      _i.scrollcurrentintoview();
      return r;
    },
    _next: function( e ) {
      return _i.next();
    },
    find: function( verbose=true ) {
      const r = _i.next( {action:'selchangeFromFind'}, 0, verbose );
    },
    _find: function( e ) {
      _i.find();
    },
    scrollmarkintoview: function( cls, opts ) {
      const els = _i.texteditor.el().getElementsByClassName( cls );
      if (els && els.length)
        _i.texteditor.scrollelemintoview( els[0], opts );
    },
    scrollcurrentintoview: function( opts ) {
      _i.scrollmarkintoview( _i.classes.current, opts );
    },
    str2regex: function( regexstr, flags='' ) {
      regexstr = regexstr.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' );
      return new RegExp( regexstr, flags );
    },
    pastetext: function( text, range, replacewith ) {
      var newtext = text.slice( 0, range.start );
      var token = text.substring( range.start, range.end );
      //newtext += token.replace( str2regex(token,''), replacewith );
      newtext += token.replace( token, replacewith );
      newtext += text.slice( range.end );
      return newtext;
    },
    _replace: function( group ) {
      var sr = _i.texteditor.getselrange( true );
      if (sr.start == sr.end) {
        //alert( "No selection" );
        if (group)
          group.more = false;
      }
      else {
        var e2 = {action:'insertFromReplace'};
        var text = _i.texteditor.get();
        var len = text.length;
        text = _i.pastetext( text, sr, UI.h.get(_i.ids.replace) );
        sr = {start:sr.start, end:sr.end + (text.length - len)};
        var newpos = sr.end;
        sr = _i.nextrange( newpos, text );
        if (group) {
          group.more = sr;
          e2.group = group;
        }
        _i.texteditor.put( text, e2, {start:newpos, end:newpos} );
        newpos = sr ? newpos : text.length;
        _i.next( e2, newpos );
      }
      return group;
    },
    replace: function() {
      return _i._replace();
    },
    replaceall: function() {
      function repl1() {
        group = _i._replace( group );
        group.start = false;
        if (group.more)
          setTimeout( repl1, 250 );
      }
      var group = {start:true};
      repl1();
    }
  }
}

/*
 *  Font picker
 *
 *  To set up:
 *    fontpicker = new UI.FontPicker();
 *    search.init( onselectcallback, ids=UI.fontpicker.defaultids, 
 *                 classes=UI.fontpicker.defaultclasses, fallbacks=UI.fontpicker.fallbacks );
 *
 *  onselectcallback( fontname )
 *
 *  The controls in 'ids' handle selections, etc.
 */
UI.fontpicker = {
  defaultopts: {
    ids: {
      list:                      'fontpicker-list',      //div
      fontname:                  'fontpicker-fontname',  //input
      addbtn:                    'fontpicker-addbtn',
      msg:                       'fontpicker-msg'
    },
    classes: {
      'item-container':          'fontpicker-item-container',         //div
      'item-container-selected': 'fontpicker-item-container-selected',
      item:                      'fontpicker-item'                    //div
    },
    fallbacks: [
            {fullName:"Monospace", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Arial", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Courier New", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Agency FB", postscriptName:"", family:"", style:"serif"},
            {fullName:"Book Antiqua", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Calibri", postscriptName:"", family:"", style:"sans-erif"}, 
            {fullName:"Cambria", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Comic Sans MS", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Consolas", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Franklin Gothic", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Garamond", postscriptName:"", family:"", style:"serif"},
            {fullName:"Impact", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Lucida Sans", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Lucida Handwriting", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Lucida Calligraphy", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Lucida Console", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Mistral", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Palatino Linotype", postscriptName:"", family:"", style:"serif"},
            {fullName:"Papyrus", postscriptName:"", family:"", style:"sans-serif"}, 
            {fullName:"Segoe UI", postscriptName:"", family:"", style:"sans-serif"},
            {fullName:"Tahoma", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Times New Roman", postscriptName:"", family:"", style:"serif"}, 
            {fullName:"Verdana", postscriptName:"", family:"", style:"sans-serif"}
    ]
  },
  _onselect: function( listid, fontname ) {UI.fontpicker[listid].select( fontname );}
}
UI.FontPicker = function() {
  this.init = function( onselectcallback, opts=UI.fontpicker.defaultopts ) {
    _i.selectcallback = onselectcallback;
    _i.ids = opts.ids ? opts.ids : UI.fontpicker.defaultopts.ids;
    _i.classes = opts.classes ? opts.classes : UI.fontpicker.defaultopts.classes;
    _i.fallbacks = opts.fallbacks ? opts.fallbacks : UI.fontpicker.defaultopts.fallbacks;
    UI.fontpicker[_i.ids.list] = this;
    UI.h.listen( _i.ids.addbtn, "click", _i.add );
    UI.h.seteditproperties( _i.ids.fontname, true );
    UI.h.listen( _i.ids.fontname, "input", _i.fontnameinput );
    _i.fontnameinput();
  }
  this.populatelist = async function() {
    return _i.populatelist();
  },
  this.add = function() {
    return _i.add();
  }
  this.select = function( fontname ) {
    _i.selectcallback( fontname );
    if (_i.selectedid)
      UI.h.class.rem( _i.selectedid, _i.classes['item-container-selected'] );
    _i.selectedid = fontname;
    UI.h.class.add( _i.selectedid, _i.classes['item-container-selected'] );
  }
  // internals
  var _i = {
    selectedid: null,
    fontnameinput: function() {
      UI.h.el(_i.ids.addbtn).disabled = !UI.h.el(_i.ids.fontname).value;
    },
    add: function() {
      //var fn = prompt( "Name of font to add:", "" );
      const fn = UI.h.el(_i.ids.fontname).value;
      if (fn && !({fullName:fn} in _i.fallbacks)) {
        var tmp = [{fullName:fn}];
        for( const fd of _i.fallbacks )
          tmp.push( fd );
        _i.fallbacks = tmp;
        _i.populatelist();
        UI.h.el(_i.ids.list).firstElementChild.scrollIntoView( {behavior: "smooth"} );
      }
    },
    populatelist: async function() {
      var availfonts;
      try {
        availfonts = await window.queryLocalFonts();
        //test availfonts = _i.fallbacks;
        UI.h.el(_i.ids.addbtn).innerHTML = "";
        UI.h.el(_i.ids.msg).innerHTML = "";
      }
      catch( e ) {
        /*if (!_i.listalerted)
          alert( "Web browser does not support font query API, " + 
                 "so some common fonts will be shown.  Fonts not available on device will render with system defaults." );*/
        _i.listalerted = true;
        availfonts = _i.fallbacks;
      }
      var html = "", name, attrs;
      for( var fd of availfonts ) {
        name = fd.fullName ? fd.fullName : (fd.family ? fd.family : fd.style);
        html += UI.h.markuphtml( 'div', { 
             'class':   _i.classes['item-container'] + (_i.selected == name ? " "+_i.classes['item-container-selected'] : ""),
             'id':      name,
             'style':   "font-family:" + name,
             'onclick': "UI.fontpicker._onselect(" + "'" + _i.ids.list + "','" + name + "'" + ")"
            },
            UI.h.markuphtml( 'div', {'class':_i.classes.item}, fd.showName?fd.showName:name) );
      }
      UI.h.el(_i.ids.list).innerHTML = html;
    }
  }
}

/*
 * File open/save/etc.
 */
var TextFileIO = {
  /* make data url */
  __lastobjurl: null,
  todataurl: function( mimetype, content ) {
    if (TextFileIO.__lastobjurl)
      URL.revokeObjectURL( TextFileIO.__lastobjurl );
    var b = new Blob( [content], {type:mimetype} );
    TextFileIO.__lastobjurl = URL.createObjectURL( b );
    return TextFileIO.__lastobjurl;
  },
  /* save content to a file by activating a <href href=".." download=".."> control */
  savedataurl: function( id, fn, mimetype, content ) {
    var e = UI.h.el( id );
    e.download = fn;
    e.href = TextFileIO.todataurl( mimetype, content );
    e.click();
  },
  /* save a text file using a <href href=".." download=".."> control */
  save: function( id, fn, content ) {
    TextFileIO.savedataurl( id, fn, 'text/plain', content );
  },
  /* activate a <input type='file'> control so user can select file(s) */
  selfile: function( idinp ) {
    var e = UI.h.el( idinp );
    e.value = "";
    e.click();
  },
  /* open a text file */
  open: function( callback, file, onlyfiletype="text/*" ) {
    if (!file)
      return;
    var reader = new FileReader();
    reader.onerror = function( e ) {UI.h.el(idout).value = e;}
    reader.onload = function( e ) {
      if (file.type.slice(0,("text").length) == "text" || file.type == "image/svg+xml")
        callback( file.name, e.target.result, file.type );
      else
        alert( "Invalid file type ("+file.type+")" );
    }
    reader.readAsText( file );
  }
}

/*
 *  Popup support
 */
UI.popup = {
  show: function( idbtn, id ) {
    if (idbtn) {
      UI.h.class.rem( idbtn, 'closed' );
      UI.h.class.add( idbtn, 'open' );
    }
    UI.h.class.rem( id, 'closed' );
    UI.h.class.add( id, 'open' );
  },
  hide: function( idbtn, id ) {
    if (idbtn) {
      UI.h.class.rem( idbtn, 'open' );
      UI.h.class.add( idbtn, 'closed' );
    }
    UI.h.class.rem( id, 'open' );
    UI.h.class.add( id, 'closed' );
  },
  toggle: function( idbtn, id, focusonopen, togglecallback ) {
    if (togglecallback)
      if (togglecallback( UI.h.el(id).classList.contains('closed'), idbtn, id ))
        return;
    if (idbtn)
      UI.h.class.toggle( idbtn, 'open', 'closed' );
    UI.h.class.toggle( id, 'open', 'closed' );
    if (focusonopen && id)
      if (UI.h.el(id).classList.contains( 'open' ))
        UI.h.el(id).focus();
  },
  init: function( idgroup, idbtn, idpopup, autoclose=[], sel=[], selcallback, togglecallback ) {
    function btnclick() {
      UI.popup.toggle( idbtn, idpopup, true, togglecallback );
    }
    function clickout( e ) {
      if (idgroup)
        if (!UI.h.isdescendantof( e.target, UI.h.el(idgroup) ))
          UI.popup.hide( idbtn, idpopup );
    }
    var prevsel = '';
    function selclick( e ) {
      prevsel = prevsel ? prevsel : sel[0];
      var close;
      if (selcallback)
        close = selcallback( e.target, idbtn, idpopup );
      UI.popup.select( idbtn, idpopup, e.target.id, prevsel, close );
      prevsel = e.target.id;
    }
    for( var i=0; i<autoclose.length; i++ )
      UI.h.listen( autoclose[i], "click", clickout );
    for( i=0; i<sel.length; i++ )
      UI.h.listen( sel[i], "click", selclick );
    if (idbtn)
      UI.h.listen( idbtn, "click", btnclick );
  },
  prompt: function( idpopup ) {
    UI.popup.show( null, idpopup );
  },
  select: function( idbtn, idpopup, idnewitem, idprevitem, close ) {
    if (idprevitem && UI.h.el(idprevitem).classList.contains( 'open' ))
      UI.popup.hide( null, idprevitem );
    if (idnewitem && UI.h.el(idnewitem).classList.contains( 'closed' ))
      UI.popup.show( null, idnewitem );
    if (close)
      UI.popup.hide( idbtn, idpopup );
  }
}

/*
 *  UI helpers
 */
UI.h = {
  el: function( id ) {
    var e = null;
    if (id)
      if (id instanceof HTMLElement)
        e = id;
      else
        e = document.getElementById( id );
    return e;
  },
  get: function( id ) {
    var e = UI.h.el( id );
    return e ? e.value : "";
  },
  put: function( id, text, append ) {
    var t = "";
    if (append)
      t += UI.h.el( id ).value;
    UI.h.el( id ).value = t + text;
  },
  listen: function( id, eventstr, callback ) {
    const e = UI.h.el( id );
    if (e)
      return e.addEventListener( eventstr, callback );
  },
  ignore: function( id, eventstr, callback ) {
    const e = UI.h.el( id );
    if (e)
      return e.removeEventListener( eventstr, callback );
  },
  /* set element property */
  setproperty: function( id, attrname, attrvalue, alertonerror ) {
    const el = UI.h.el( id );
    try {
      const prevval = el[attrname];
      el[attrname] = attrvalue;
      return prevval;
    }
    catch( e ) {
      if (alertonerror)
        alert( "Browser doesn't support '" + attrname + "' attribute" );
    }
  },
  /* set properties for plain (code) editor vs spell-checking editor */
  seteditproperties: function( id, plain, alertonerror ) {
    UI.h.setproperty( id, 'autocapitalize', plain ? "off" : "on", alertonerror );
    UI.h.setproperty( id, 'autocomplete', plain ? "off" : "on", alertonerror );
    UI.h.setproperty( id, 'autocorrect', plain ? "off" : "on", alertonerror );
    UI.h.setproperty( id, 'spellcheck', plain ? false : true, alertonerror );
  },
  defocusize: function( elems ) {
    for ( const el of elems )
      UI.h.listen( el, "mousedown", function(e){e.preventDefault();} );
  },
  enable: function( id, enable ) {
    const e = UI.h.el( id );
    if (e)
      return e.disabled = !enable;
  },
  zoom: function( incr = 1, id ) {
    var z = UI.h.el( id ).style['font-size'];
    z = z ? z : "100%";
    z = z.slice( 0, z.length-1 ) * 1;
    z += incr * 6; if (z < 40) z = 40;
    UI.h.el( id ).style['font-size'] = z + "%";
  },
  setstyle: function( id, c, v ) {
    UI.h.el( id ).style[c] = v;
  },
  setdisplay: function( id, dis ) {
    UI.h.setstyle( id, 'display', dis );
  },
  /* determine if 'el' is inside 'parel' */
  isdescendantof: function( el, parel ) {
    //el = UI.h.el( el );
    //parel = UI.h.el( parel );
    while (el && el != parel)
      el = el.parentNode;
    return el;
  },
  /* get selection range relative to innerText (plaintext) of 'parel' */
  getabsselrange: function( parel ) {
    var sr;
    const s = window.getSelection();
    if (s.rangeCount && UI.h.isdescendantof(s.anchorNode,parel) && UI.h.isdescendantof(s.focusNode,parel)) {
      sr = {start:0, end:0};
      const r = s.getRangeAt( 0 );
      const pfx = r.cloneRange();
      pfx.selectNodeContents( parel );
      pfx.setEnd( s.anchorNode, s.anchorOffset );
      sr.start = pfx.toString().length;
      pfx.setEnd( s.focusNode, s.focusOffset );
      sr.end = pfx.toString().length;
    }
    return sr;
  },
  /* get position in DOM of pos in innerText (plaintext) of 'parel' */
  getDOMposofabspos: function( pos, parel ) {
    for( const node of parel.childNodes) {
      if (node.nodeType == Node.TEXT_NODE) {
        if (node.length >= pos)
          return {'node':node, offset:pos};
        else
          pos -= node.length;
      }
      else {
        const DOMpos = UI.h.getDOMposofabspos( pos, node );
        if (DOMpos)
          return DOMpos;
        pos -= node.innerText.length;
      }
    }
  },
  /* set selection in innerText (plaintext) of 'parel' */
  setabsselrange: function( sr, parel ) {
    const s = window.getSelection();
    s.removeAllRanges();
    const r = document.createRange();
    var DOMpos1 = DOMpos2 = UI.h.getDOMposofabspos( Math.min(parel.innerText.length,sr.start), parel );
    if (DOMpos1) {
      if (sr.end != sr.start)
        DOMpos2 = UI.h.getDOMposofabspos( Math.min(parel.innerText.length,sr.end), parel );
      if (DOMpos2)
        s.setBaseAndExtent( DOMpos1.node, DOMpos1.offset, DOMpos2.node, DOMpos2.offset );
    }
    return sr;
  },
  unionclientrects: function( els ) {
    var r, ur = {};
    for( var i=0; i<els.length; i++ ) {
      r = els[i].getBoundingClientRect();
      if (ur.left == undefined || r.left < ur.left)
        ur.left = r.left;
      if (ur.top == undefined || r.top < ur.top)
        ur.top = r.top;
      if (ur.right == undefined || r.right > ur.right)
        ur.right = r.right;
      if (ur.bottom == undefined || r.bottom > ur.bottom)
        ur.bottom = r.bottom;
    }
    return ur;
  },
  /* smooth scroll an element to a pixel position */
  scrolltopos: function( el, posx, posy, opts={} ) {
    opts.smooth = opts.smooth == undefined ? true : opts.smooth,
    opts.delay = opts.delay == undefined ? 20 : opts.delay;
    opts.maxsteps = opts.maxsteps == undefined ? 20 : opts.maxsteps;
    opts.minincr = opts.minincr == undefined ? 5 : opts.minincr;
    var delta = {
      x: (posx - el.scrollLeft) / opts.maxsteps,
      y: (posy - el.scrollTop) / opts.maxsteps
    }
    delta.x = delta.x < 0 ? Math.min(delta.x,opts.minincr) : Math.max(delta.x,opts.minincr);
    delta.y = delta.y < 0 ? Math.min(delta.y,opts.minincr) : Math.max(delta.y,opts.minincr);
    var nextpos = {
      x: el.scrollLeft,
      y: el.scrollTop
    }
    function anim() {
      nextpos.x += delta.x,
      nextpos.y += delta.y;
      nextpos.x = delta.x < 0 ? Math.max(nextpos.x,posx) : Math.min(nextpos.x,posx);
      nextpos.y = delta.y < 0 ? Math.max(nextpos.y,posy) : Math.min(nextpos.y,posy);
      nextpos.x = opts.smooth ? nextpos.x : posx;
      nextpos.y = opts.smooth ? nextpos.y : posy;
      el.scrollLeft = nextpos.x;
      el.scrollTop = nextpos.y;
      if (nextpos.x != posx || nextpos.y != posy)
        setTimeout( anim, opts.delay );
      else
        if (opts.scrollingdonecallback)
          opts.scrollingdonecallback();
    }
    anim();
  },
  /* scroll to and center a rect in an element */
  scrolltorect: function( el, r={left:0,right:0,top:0,bottom:0}, opts={} ) {
    function inside( pt, r ) {
      return (pt.x >= r.left && pt.x < r.right && 
              pt.y >= r.top && pt.y < r.bottom);
    }
    function toobigx( r, cr ) {
      var w = r.right - r.left;
      var cw = cr.right - cr.left;
      return (w > cw);
    }
    function toobigy( r, cr ) {
      var h = r.bottom - r.top;
      var ch = cr.bottom - cr.top;
      return (h > ch);
    }
    opts.center = opts.center == undefined ? true : opts.center;
    const ebr = el.getBoundingClientRect();
    var vr = {
      left: el.scrollLeft,
      right: el.scrollLeft + ebr.width,
      top: el.scrollTop,
      bottom: el.scrollTop + ebr.height
    };
    /* (if rect is already visible, no scrolling takes place) */
    if (inside( {x:r.left, y:r.top}, vr ) && inside( {x:r.right, y:r.bottom}, vr )) {
      if (opts.scrollingdonecallback)
        opts.scrollingdonecallback();
    }
    else {
      var pt = {x: r.left + ((r.right - r.left) / 2),
                y: r.top + ((r.bottom - r.top) / 2)};
      if (toobigx( r, ebr ))
        /* scroll to left if rect is too wide to fit in client */
        pt.x = r.left - 10;
      else {
        /* (the bias is to scroll to 0 horizontally (don't center) if rect in leftmost area) */
        if (r.right < ebr.width)
          pt.x = 0;
        else
          if (opts.center)
            /* move x to center if entire width not already visible */
            if (r.left < vr.left || r.right > vr.right)
              pt.x -= ebr.width / 2;
            else
              pt.x = el.scrollLeft;
      }
      if (toobigy( r, ebr ))
        /* scroll to top if rect is too long to fit in client */
        pt.y = r.top - 10;
      else
        if (opts.center)
          /* move y to center if entire length not already visible */
          if (r.top < vr.top || r.bottom > vr.bottom)
            pt.y -= ebr.height / 2;
          else
            pt.y = el.scrollTop;
      UI.h.scrolltopos( el, pt.x, pt.y, opts );
      return true;
    }
  },
  /* scroll container to an element cluster */
  scrollelemsintoview: function( containerel, insideels, opts={} ) {
    const ir = UI.h.unionclientrects( insideels );
    const cr = containerel.getBoundingClientRect();
    const oir = {
      left: ir.left - cr.left + containerel.scrollLeft,
      right: ir.right - cr.left + containerel.scrollLeft,
      top: ir.top - cr.top + containerel.scrollTop,
      bottom: ir.bottom - cr.top + containerel.scrollTop
    };
    function scrollingdone() {
      if (opts.blink) {
        var t = opts.blink.targets;
        if (!t)
          t = insideels;
        for( var i=0; i<t.length; i++ )
          UI.h.class.add( t[i], opts.blink.class );
        function blinkdone() {
          for( var j=0; j<t.length; j++ )
            UI.h.class.rem( t[j], opts.blink.class );
        }
        setTimeout( blinkdone, opts.blink.duration );
      }
      delete opts.scrollingdonecallback;
    }
    opts.scrollingdonecallback = scrollingdone;
    UI.h.scrolltorect( containerel, oir, opts );
  },
  /* scroll container to an element, centered (default) */
  scrollelemintoview: function( containerel, insideel, opts={} ) {
    UI.h.scrollelemsintoview( containerel, [insideel], opts );
  },
  markuphtml: function( tag, attrs, innerhtml ) {
    var html = '<' + tag;
    for( var a in attrs )
      html += " " + a + '="' + attrs[a] + '"';
    return html + '>' + innerhtml + '</' + tag + '>';
  },
  text2html: function( text ) {
    var newtext = text.replace( /&/g, "&amp;" );
    newtext = newtext.replace( />/g, "&gt;" );
    return newtext.replace( /</g, "&lt;" );
  },
  class: {
    add: function( id, c ) {
      var e = UI.h.el( id );
      if (e)
        e.classList.add( c );
    },
    rem: function( id, c ) {
      var e = UI.h.el( id );
      if (e && e.classList.contains( c ))
        e.classList.remove( c );
    },
    toggle: function( id, c1, c2 ) {
      var e = UI.h.el( id );
      if (e)
        if (e.classList.contains( c1 )) {
          e.classList.remove( c1 );
          if (c2) e.classList.add( c2 );
        }
        else {
          if (c2) e.classList.remove( c2 );
          e.classList.add( c1 );
        }
    },
    replace: function( id, c1, c2 ) {
      var e = UI.h.el( id );
      if (e) {
        if (e.classList.contains( c1 ))
          e.classList.remove( c1 );
        if (c2) e.classList.add( c2 );
      }
    }
  }
}
  </script>

  <!--script type="text/javascript" src="lib/stylotroneditor.js"/script-->
  <script>
/*
 * stylotroneditor.js: foundation for WYSIWYG editor using stylotron.js for dynamic markup
 *
 *   UI.stylotroneditor.Styler:     uses a SOT.PatternSeries object to mark up content in a UI.TextEditor as it changes
 *
 *   UI.stylotroneditor.Selections: souped up selection and multi-selections support
 *   UI.stylotroneditor.Search:     regex search and replace; marks up matched, current, and replaced ranges
 *
 *   UI.StylotronEditor:            a UI.TextEditor with Styler and other opt-in attachments
 *
 *   single step init:              editor = UI.stylotroneditor.createinit( texteditorid, opts, patterndefs )
 *
 * Requires stylotron.js and texteditor.js
 *
 * See texteditor.html and stylotronIDE.html for examples of use
 *
 * cc0 (public domain) v.010 September 2025, latest version @ github.com/gregsidal
 */

/*
 * Single-step setup
 */
UI.stylotroneditor = {
  createinit: function( texteditorid, opts, patterndefs={} ) {
    const editor = new UI.StylotronEditor( texteditorid, opts );
    editor.styler.patterns().add( patterndefs );
    editor.texteditor.initrefresh();
    return editor;
  }
}

/*
 * Texteditor with styler; also optional undo/redo, fontpicker, and search attachments
 */
UI.StylotronEditor = function( texteditorid, opts={} ) {
  /* setup text editor with undo/redo and fontpicker if indicated */
  this.components = new UI.texteditor.Components( texteditorid, opts );
  this.texteditor = this.components.get( 'texteditor' );
  /* attach patterns component */
  this.styler = this.components.add( 'styler', new UI.stylotroneditor.Styler() );
  this.styler.init( this.texteditor );
  /* attach optional selections component */
  if (opts.selections) {
    this.selections = this.components.add( 'selections', new UI.stylotroneditor.Selections() );
    this.selections.init( this.texteditor, this.styler, opts.selections.profiles );
  }
  /* attach optional search component */
  if (opts.search) {
    this.search = this.components.add( 'search', new UI.stylotroneditor.Search() );
    this.search.init( this.texteditor, this.styler, opts.search );
  }
}

/*
 * Styler attachment for a TextEditor
 *   marks up content in a text editor with CSS classes using stylotron.js
 *
 * To set up:
 *   styler = new UI.stylotroneditor.Styler();
 *   styler.init( texteditor );
 *
 * An internal SOT.PatternSeries object determines what ranges of text are marked up
 *   to get: patterns = styler.patterns()
 *   regexs and ranges can be added to 'patterns' as described in SOT.PatternSeries comments
 */
UI.stylotroneditor.Styler = function() {
  this.init = function( texteditor ) {
    _i.texteditor = texteditor;
    _i.patterns = new SOT.PatternSeries();
    _i.prevbeforetextchangecallback = texteditor.setcallback( 'beforetextchange', _i.oneditorbeforetextchange );
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    _i.prevremarkupcallback = texteditor.setcallback( 'remarkup', _i.oneditorremarkup );
  }
  this.patterns = function() {return _i.patterns};
  /* get text map (map of all regex matches) */
  this.textmap = function( recreate ) {
    if (recreate || !_i.currenttextmap)
      _i.currenttextmap = _i.patterns.buildmatchesmap( _i.texteditor.get() );
    return _i.currenttextmap;
  }
  this.reset = function() {
    this.textmap( true );
    return _i.texteditor.refresh();
  }
  // internals
  var _i = {
    texteditor: null, profiles: {},
    oneditorbeforetextchange: function( e2 ) {
      const ret = _i.prevbeforetextchangecallback( e2 );
      _i.currenttextmap = null; //_i.patterns.buildmatchesmap( _i.textarea.get() );
      return ret;
    },
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      refresh = e2.textchanged || refresh;
      return refresh;
    },
    oneditorremarkup: function( text, e2 ) {
      //var HTML = _i.prevremarkupcallback( e2 );
      if (!_i.currenttextmap)
        _i.currenttextmap = _i.patterns.buildmatchesmap( text );
      var fullmap = _i.patterns.buildrangesmap( text, _i.currenttextmap );
      return _i.patterns.markupmap( text, fullmap );
    }
  }
}

/*
 *  Multiple selections attachment for a TextEditor
 *
 *  To set up:
 *    selections = new UI.stylotroneditor.Selections();
 *    selections.init( texteditor, texteditorstyler, profiles = {default} );
 *
 *  To select/deselect a range:
 *    selections.selectrange = function( profilename, range, refresh )
 *    selections.clrrange = function( profilename, refresh )
 *
 *  To insert text and select it with a profile:
 *    selections.inserttext( text, e2={action:"insertFromCustomInsert"}, range, profilename )
 *
 *  Profiles:
 *    cls: range is marked up with this class when selected
 *    trackselection: when set, selected range will mirror browser's (native) selection
 *    removewhen:
 *      focused:        selection removed when editor focused
 *      blurred:        - when editor blurred
 *      caretmoved:     - when caret is moved
 *      textchanged:    - when text changes
 *
 *  Default profile marks up browser's selection with class 'texteditor-selected' when not focused:
 *    'selection-notfocused': {cls:'texteditor-selected', trackselection:true, removewhen:{focused:true}}
 */
UI.stylotroneditor.Selections = function() {
  this.init = function( texteditor, texteditorstyler, profiles=
           {'selection-notfocused': {cls:'texteditor-selected', trackselection:true, removewhen:{focused:true}}} ) {
    _i.texteditor = texteditor;
    _i.editorstyler = texteditorstyler;
    _i.profiles = profiles;
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
  }
  this.profiles = function() {return _i.profiles};
  this.selectrange = function( profilename, range, refresh ) {
    const needsrefresh = _i.sel( profilename, range );
    if (refresh && needsrefresh)
      _i.texteditor.refresh();
    return needsrefresh;
  }
  this.clrrange = function( profilename, refresh ) {
    const needsrefresh = _i.clr( profilename );
    if (refresh && needsrefresh)
      _i.texteditor.refresh();
    return needsrefresh;
  }
  /* insert text into range (default selected range) and mark it with a profile */
  this.inserttext = function( text, e2={action:"insertFromCustomInsert"}, range, profilename ) {
    e2.insertedprofilename = profilename;
    return _i.texteditor.insert( text, e2, range, false );
  }
  // internals
  var _i = {
    texteditor: null, profiles: {},
    oneditorstatechange: function( e2 ) {
      var refresh = _i.prevchangecallback( e2 );
      if (_i.testall( e2 ))
        refresh = true;
      return refresh;
    },
    sel: function( profilename, r ) {
      if (!r || r.start == r.end)
        return _i.clr( profilename );
      _i.profiles[profilename].range = r;
      var m = _i.editorstyler.patterns().get( _i.profiles[profilename].cls );
      if (!m || m.range.start != r.start || m.range.end != r.end) {
        _i.editorstyler.patterns().addrange( r, _i.profiles[profilename].cls );
        return true;
      }
    },
    clr: function( profilename ) {
      _i.profiles[profilename].range = null;
      var m = _i.editorstyler.patterns().get( _i.profiles[profilename].cls );
      if (m) {
        _i.editorstyler.patterns().del( _i.profiles[profilename].cls );
        return true;
      }
    },
    test: function( profilename, e2 ) {
      var remove = false;
      const profile = _i.profiles[profilename];
      const removewhen = profile.removewhen ? profile.removewhen : {};
      if (removewhen.focused && e2.focused)
        remove = true;
      if (removewhen.blurred && !e2.focused)
        remove = true;
      if (removewhen.textchanged)
        if (!e2.insertedprofilename || e2.insertedprofilename != profilename)
          if (e2.textchanged)
            remove = true;
      if (removewhen.caretmoved)
        if (SOT.text.startswith( e2.action, 'selchange' ))
          remove = true;
      var refresh;
      if (remove) {
        if (_i.clr( profilename ))
          refresh = true;
      }
      else {
        if (profile.trackselection)
          profile.range = e2.selrange;
        else
          if (e2.insertedprofilename && e2.insertedprofilename == profilename && e2.insertedrange)
            profile.range = e2.insertedrange;
        if (_i.sel( profilename, profile.range ))
          refresh = true;
      }
      return refresh;
    },
    testall: function( e2 ) {
      var refresh = false;
      for( const profilename in _i.profiles )
        if (_i.test( profilename, e2 ))
          refresh = true;
      return refresh;
    }
  }
}

/*
 *  Search/replace attachment for a TextEditor
 *
 *  To set up:
 *    search = new UI.stylotroneditor.Search();
 *    search.init( texteditor, texteditorstyler, ids=UI.search.defaultids, classes=UI.search.defaultclasses );
 *
 *  The controls in 'ids' trigger the search/replace functions 
 *
 *  CSS class classes.match is applied to text matching search results
 *  classes.current is applied to current match
 *  classes.replaced is applied to replacement text
 *
 *  Current match is determined by position of the caret
 *    (navigation repositions the caret which in turn repositions the current match)
 */
UI.stylotroneditor.search = {
  defaultopts: {
    ids: {
      find:           'search-find',        //input
      findbtn:        'search-findbtn',
      nextbtn:        'search-nextbtn',
      scrolltobtn:    'search-scrolltobtn',
      prevbtn:        'search-prevbtn',
      clearbtn:       'search-clearbtn',
      replace:        'search-replace',     //input
      replacebtn:     'search-replacebtn',
      replaceallbtn:  'search-replaceallbtn'
    },
    classes: {
      match:          'search-match',
      current:        'search-current',
      currentflash:   'search-currentflash',
      currentblink:   'search-currentblink',
      replaced:       'search-replaced'
    },
    miscopts: {
      currentblinkduration: 1100,
      replaceanimationdelay: 350
    },
    lockctls: true
  }
};
UI.stylotroneditor.Search = function() {
  this.init = function( texteditor, texteditorstyler, opts = UI.stylotroneditor.search.defaultopts ) {
    _i.texteditor = texteditor;
    _i.editorstyler = texteditorstyler;
    _i.prevbeforetextchangecallback = texteditor.setcallback( 'beforetextchange', _i.oneditorbeforetextchange );
    _i.prevchangecallback = texteditor.setcallback( 'statechanged', _i.oneditorstatechange );
    _i.ids = opts.ids ? opts.ids : UI.stylotroneditor.search.defaultopts.ids;
    _i.classes = opts.classes ? opts.classes : UI.stylotroneditor.search.defaultopts.classes;
    _i.miscopts = opts.miscopts ? opts.miscopts : UI.stylotroneditor.search.defaultopts.miscopts;
    _i.searchsets[0].classes = {match: _i.classes.match};
    this.lockctls( opts.lockctls == undefined ? UI.stylotroneditor.search.defaultopts.lockctls : opts.lockctls );
  }
  this.lockctls = function( lock=true ) {
    _i.ctlslocked = lock;
    if (lock) {
      UI.h.listen( _i.ids.findbtn, "click", _i.find );
      UI.h.listen( _i.ids.nextbtn, "click", _i.next );
      UI.h.listen( _i.ids.scrolltobtn, "click", _i.viewcurrent );
      UI.h.listen( _i.ids.prevbtn, "click", _i.prev );
      UI.h.listen( _i.ids.clearbtn, "click", _i.clear );
      UI.h.listen( _i.ids.replacebtn, "click", _i.replace );
      UI.h.listen( _i.ids.replaceallbtn, "click", _i.replaceall );
      UI.h.seteditproperties( _i.ids.find, true );
      UI.h.seteditproperties( _i.ids.replace, true );
      UI.h.listen( _i.ids.find, "input", _i.clear );
      _i.resetctls();
    }
    else {
      UI.h.ignore( _i.ids.findbtn, "click", _i.find );
      UI.h.ignore( _i.ids.nextbtn, "click", _i.next );
      UI.h.ignore( _i.ids.scrolltobtn, "click", _i.viewcurrent );
      UI.h.ignore( _i.ids.prevbtn, "click", _i.prev );
      UI.h.ignore( _i.ids.clearbtn, "click", _i.clear );
      UI.h.ignore( _i.ids.replacebtn, "click", _i.replace );
      UI.h.ignore( _i.ids.replaceallbtn, "click", _i.replaceall );
      UI.h.ignore( _i.ids.find, "input", _i.clear );
    }
  }
  this.clear = function( keepmatches, refresh ) {
    _i.clear( null, keepmatches, refresh );
  }
  this.activate = function( active ) {
    _i.activate( active );
  }
  this.find = function( verbose=true ) {
    _i.find( verbose );
  }
  this.next = function( dir=1, verbose=true ) {
    _i.next( dir, verbose );
  }
  this.scrollcurrentintoview = function( opts ) {
    _i.scrollcurrentintoview( opts );
  }
  this.scrollreplacedintoview = function( opts ) {
    _i.scrollreplacedintoview( opts );
  }
  this.replace = function() {
    return _i.replace();
  }
  this.replaceall = function() {
    return _i.replaceall();
  }
  this.quickreplaceall_DONOTUSE = function() {
    if (!_i.searchset().found)
      alert( "No matches" );
    else {
      var map = _i.textmap();
      if (!map.length)
        alert( "No matches" );
      else {
        var text = _i.texteditor.get();
        var replacewiths = {};
        replacewiths[_i.classes.match] = UI.h.get( _i.ids.replace );
        text = SOT.text.map.replaceall( text, map, replacewiths );
        _i.texteditor.put( text, {action:'insertFromReplaceAll'} );
      }
    }
  }
  // internals
  var _i = {
    texteditor: null, active:0, searchsets: [{found:"", regex:null, mapindex:-1}],
    searchset: function() {return _i.active >= 0 ? _i.searchsets[_i.active] : null;},
    action: function( e, t ) {
      return e && e.action && e.action.substring( 0, t.length ) == t;
    },
    oneditorbeforetextchange: function( e2 ) {
      const ret = _i.prevbeforetextchangecallback( e2 );
      _i.searchset().currenttextmap = null;
      return ret;
    },
    /* reposition the current match when caret moves/text changes */
    oneditorstatechange: function( e2 ) {
      function reposcurrent() {
        var redraw = false;
        var map = _i.textmap();
        const pro = _i.searchset();
        var i = SOT.text.map.range.nearest( e2.selrange.start, map );
        if (i != pro.mapindex || e2.textchanged || _i.action(e2,'insertFromReplace')) {
          if (!_i.action( e2, 'insertFromReplace' ))
            if (_i.editorstyler.patterns().get( _i.classes.replaced ))
              _i.editorstyler.patterns().del( _i.classes.replaced ), redraw = true;
          pro.mapindex = i;
          if (pro.mapindex >= 0)
            _i.editorstyler.patterns().addrange( map[pro.mapindex].range, _i.classes.current ), redraw = true;
          else
            if (_i.editorstyler.patterns().get( _i.classes.current ))
              _i.editorstyler.patterns().del( _i.classes.current ), redraw = true;
        }
        return redraw;
      }
      var refresh = _i.prevchangecallback( e2 );
      if (_i.searchset().awake)
        if (e2.textchanged) {
          _i.resetctls();
          reposcurrent();
          refresh = true;
        }
        else
          if (_i.action( e2, 'selchange' ) && e2.selrange.start == e2.selrange.end && 
              (e2.selrange.start != e2.prevselrange.start || 
               e2.selrange.end != e2.prevselrange.end ||
               _i.action( e2, 'selchangeFromFind') ||
               _i.action( e2, 'selchangeFromActivate'))) {
            if (reposcurrent())
              refresh = true;
          }
      return refresh;
    },
    /* build a text map of current search set */
    newmap: function( text ) {
      const patterns = new SOT.PatternSeries();
      if (_i.searchset().regex)
        patterns.addregex( _i.searchset().regex, _i.searchset().classes.match );
      return patterns.buildmatchesmap( text ? text : _i.texteditor.get() );
    },
    /* get map of regex matches in search set */
    textmap: function( regen ) {
      var map;
      if (_i.searchsets.length) {
        if (regen || !_i.searchset().currenttextmap)
          _i.searchset().currenttextmap = _i.newmap();
        if (regen)
          _i.editorstyler.textmap( regen );
        map = _i.searchset().currenttextmap;
      }
      else
        map = _i.editorstyler.textmap( regen );
      return map;
    },
    resetctls: function() {
      const canfind = UI.h.get( _i.ids.find );
      const matches = _i.textmap().length;
      const canmove = canfind && _i.textmap().length != 1;
      if (_i.ctlslocked) {
        UI.h.enable( _i.ids.findbtn, canfind );
        UI.h.enable( _i.ids.nextbtn, canmove );
        UI.h.enable( _i.ids.scrolltobtn, matches );
        UI.h.enable( _i.ids.prevbtn, canmove );
        UI.h.enable( _i.ids.clearbtn, matches );
        UI.h.enable( _i.ids.replacebtn, matches );
        UI.h.enable( _i.ids.replaceallbtn, _i.textmap().length > 1 );
      }
    },
    clear: function( e, keepmatches, refresh=true ) {
      const pro = _i.searchset();
      if (!pro)
        return;
      pro.awake = 0;
      pro.mapindex = -1;
      if (!keepmatches) {
        _i.editorstyler.patterns().del( pro.classes.match );
        pro.found = "", pro.regex = null;
      }
      _i.editorstyler.patterns().del( _i.classes.current );
      _i.editorstyler.patterns().del( _i.classes.replaced );
      _i.textmap( true );
      if (refresh)
        _i.texteditor.refresh();
      _i.resetctls();
    },
    activate: function( searchsetindex=0 ) {
      _i.active = searchsetindex;
      _i.searchset().awake = 1;
      _i.texteditor.setcaretpos( -1, {action:'selchangeFromActivate'} );
      //_i.scrollcurrentintoview();
      _i.resetctls();
    },
    find: function( verbose=true, dir=1 ) {
      try {
        _i.searchset().found = UI.h.get( _i.ids.find );
        _i.searchset().regex = SOT.text.regexstr2regex( _i.searchset().found, 'g' );
        _i.searchset().awake = 1;
        _i.searchset().mapindex = -1;
        _i.editorstyler.patterns().del( _i.classes.current );
        _i.editorstyler.patterns().del( _i.classes.replaced );
        _i.editorstyler.patterns().addregex( _i.searchset().regex, _i.searchset().classes.match );
        _i.textmap( true );
        _i.resetctls();
        _i.movecurrent( dir, verbose, {action:'selchangeFromFind'} );
      }
      catch( e ) {
        _i.clear();
        if (verbose)
          alert( e ); //"Invalid regular expression" );
      }
    },
    scrollmarkintoview: function( cls, opts ) {
      const els = _i.texteditor.el().getElementsByClassName( cls );
      if (els && els.length) {
        /*if (opts.blink)
          opts.blink.targets = els;*/
        _i.texteditor.scrollelemsintoview( els, opts );
      }
    },
    scrollcurrentintoview: function( opts ) {
      _i.scrollmarkintoview( _i.classes.current, 
              {blink: {class:_i.classes.currentflash, duration:_i.miscopts.currentblinkduration}} );
    },
    viewcurrent: function( e ) {
      _i.scrollmarkintoview( _i.classes.current, 
              {blink: {class:_i.classes.currentblink, duration:_i.miscopts.currentblinkduration}} );
    },
    scrollreplacedintoview: function( opts ) {
      _i.scrollmarkintoview( _i.classes.replaced, opts );
    },
    movecurrent: function( dir=1, verbose=true, e2={action:'selchangeFromNav'} ) {
      if (!_i.searchset().found)
        return _i.find( true, dir );
      _i.editorstyler.patterns().del( _i.classes.current );
      _i.editorstyler.patterns().del( _i.classes.replaced );
      var pos = -1, map = _i.textmap();
      /* find start position of next/prev */
      if (map.length) {
        var i = _i.searchset().mapindex + dir;
        i = i < 0 ? map.length-1 : (i >= map.length ? 0 : i);
        pos = map[i].range.start;
      }
      else {
        if (verbose)
          alert( "No matches" );
      }
      /* reposition the caret (will cause current match to update) */
      _i.texteditor.setcaretpos( pos, e2 );
      /* at this point, current match is updated so make sure it's in view */
      _i.scrollcurrentintoview();
    },
    next: function( e ) {
      _i.movecurrent( 1 );
      if (e)
        e.preventDefault();
    },
    prev: function( e ) {
      _i.movecurrent( -1 );
      if (e)
        e.preventDefault();
    },
    _replace: function( group ) {
      if (group)
        group.more = false;
      if (!_i.searchset().found || _i.searchset().mapindex < 0)
        alert( "No matches" );
      else {
        var map = _i.textmap();
        if (!map.length)
          alert( "No matches" );
        else {
          var text = _i.texteditor.get();
          var len = text.length;
          var i = _i.searchset().mapindex;
          var r = map[i].range;
          var e2 = {action:'insertFromReplace'};
          if (group) {
            group.more = i < map.length - 1;
            e2.group = group;
          }
          text = SOT.text.map.replace( text, map, _i.searchset().mapindex, UI.h.get(_i.ids.replace) );
          /* calculate replaced text range */
          r = {start:r.start, end:r.end + (text.length - len)};
          /* ready caret to be repositioned to the next match if any */
          /*   (replacement can change the match count, so that is taken into account) */
          var newpos = r.end;
          var newmap = _i.newmap( text );
          if (newmap.length) {
            i += newmap.length - map.length;
            i = i >= newmap.length-1 ? 0 : i+1;
            newpos = newmap[i].range.start;
          }
          _i.searchset().mapindex = -1;
          _i.editorstyler.patterns().addrange( r, _i.classes.replaced );
          /* put the new text (will reposition the caret, causing current match to update) */
          _i.texteditor.put( text, e2, {start:newpos, end:newpos} );
          /* at this point, replacement is styled, make sure it's in view */
          _i.scrollreplacedintoview( {smooth:!group} );
        }
      }
      return group;
    },
    replace: function() {
      return _i._replace();
    },
    replaceall: function() {
      function repl1() {
        group = _i._replace( group );
        group.start = false;
        if (group && group.more)
          setTimeout( repl1, _i.miscopts.replaceanimationdelay );
      }
      var group = {start:true};
      repl1();
    }
  }
}
  </script>

  <script>

var Main = {
  selectionprofiles: {
    'selection-notfocused':    {cls:'texteditor-selected', trackselection:true, removewhen:{focused:true}},
    'selection-open':          {cls:'texteditor-selected-open', removewhen:{caretmoved:true, textchanged:true}}
  },
  fontpickerclasses: {
    'item-container':          'clickable font',
    'item-container-selected': 'open',
    item:                      'fontname'
  },
  c: function( componentname ) {return Main._editor.components.get( componentname );},
  onload: function() {
    Main._editor = new UI.stylotroneditor.createinit( 'notepad', 
            {undoredo: {}, 
             fontpicker: {classes: Main.fontpickerclasses},
             selections: {profiles: Main.selectionprofiles}, 
             search: {}} );
    UI.h.listen( UI.h.el('texteditor-wraptoggle'), 'click', Main._wrap );
    Main.c('texteditor').changed( false );
  },
  _wrap: function( e ) {
    var refresh = true;
    const w = Main.c('texteditor').wrap();
    /*
    if (w) {
      refresh = Main.c('styler').patterns().del( 'line' );
      Main.c('texteditor').el().style['padding-left'] = '0.6em';
    }
    else {
      Main.c('styler').patterns().addregex( /.+/g, 'line' );
      Main.c('texteditor').el().style['padding-left'] = '1.6em';
    }
    */
    if (refresh) {
      //Main.c('styler').reset();
      Main.c('texteditor').seteditproperties( !w );
    }
  },
  __zoom: function( incr ) {
    Main.c('texteditor').zoom( incr );
  },
  togglefontpicker: async function() {
    if (!Main.fontpickerpopulated) {
      Main.c('fontpicker').populatelist();
      Main.fontpickerpopulated = true;
    }
    UI.popup.hide( '', 'splash' );
    UI.popup.toggle( 'fontpicker-togglebtn', 'fontpicker-popup' );
  },
  togglesearch: function() {
    UI.popup.hide( '', 'splash' );
    Main.searchactive = !Main.searchactive;
    UI.popup.toggle( 'search-togglebtn', 'search-menu' );
    UI.h.class.toggle( 'toolbar', 'open', 'closed' );
    UI.h.class.toggle( 'ground', 'open', 'closed' );
    if (Main.searchactive)
      Main.c('search').activate( 0 );
    else
      Main.c('search').clear( true );
  },
  save2file: function() {
    try {
      var fn = UI.h.el( 'filename' ).value;
      var t = Main.c('texteditor').get();
      TextFileIO.save( 'save', fn, t );
      Main.c('texteditor').changed( false );
    }
    catch( e ) {
      alert( "Unable to save file, response was: " + e );
    }
  },
  inserttext: function( text, fn, insert ) {
    if (insert)
      //Main.c('selections').inserttext( text, {action:"insertFromOpenInsert"}, undefined, 'selection-open' );
      Main.c('texteditor').insert( text, {action:"insertFromOpenInsert"} ); //(apply browser's selection)
    else {
      Main.c('search').clear( false, false );
      Main.c('texteditor').put( text, {action:"insertFromOpenPut"} );
      Main.c('texteditor').changed( false );
      UI.h.el( 'filename' ).value = fn;
    }
  },
  selfile: function( trigger ) {
    if (Main.c('texteditor').changed())
      if (!confirm( "Changes made will be lost" ))
        return;
    TextFileIO.selfile( trigger );
  },
  openfile: function( f, insert ) {
    function callback( fn, text ) {
      Main.inserttext( text, fn, insert );
    }
    TextFileIO.open( callback, f );
  },
  onbeforeunload: function( e ) {
    if (Main.c('texteditor').changed()) {
      e.preventDefault();
      e.returnValue = "";
    }
  }
}

document.addEventListener( 'DOMContentLoaded', Main.onload );
window.addEventListener( 'beforeunload', Main.onbeforeunload );
  </script>
</head>

<body>

  <div id="ground" class="ground">
    <div class="backing">
      <div class="editorpositioner">
        <div class="editorcontainer" id="linecontrol">
          <!--div class="editor"-->
<div class="markup" id="notepad">Plaintext editor (notepad)
cc0 (public domain)

Spell-check and auto-capitalize will turn off when unwrapped
</div>
          <!--/div-->
        </div>
      </div>
    </div>
  </div>

  <div id="toolbar" class="toolbar">

    <div class="menu open">
      <div class="menusection left">
        <span class="menusubsection">
          <span class="content small">
            <span class="btnbank">
              <button class="ctl icon" onclick="Main.selfile('open')"><span class="icon openfile"></span></button>
              <button class="ctl icon" onclick="TextFileIO.selfile('openinsert')"><span class="icon openfileinsert"></span></button>
              <input style="display:none;" type="file" accept="text/*" id="open" onchange="Main.openfile(this.files[0]);">
              <input style="display:none;" type="file" accept="text/*" id="openinsert" onchange="Main.openfile(this.files[0],true);">
            </span>
          </span>
        </span>
        <span class="menusubsection right">
          <span class="content small">
            <span class="btnbank">
              <input type="text" class="inpctl" id="filename" value="document.txt"/><button class="ctl icon slim" id='savebtn' onclick="Main.save2file();"><span class="icon savefile abut"></span></button>
              <a href="" download="*.txt" style="display:none;" id="save"></a>
            </span>
          </span>
        </span>
      </div>
      <div class="menusection right">
        <span class="menusubsection full">
          <span class="content small">
            <span class="btnbank">
              <button class="ctl text baseline larger" id="fontpicker-togglebtn" onclick="Main.togglefontpicker()"><i>f</i></button>
              <button class="ctl text baseline large" id="texteditor-zoominbtn">A</button>
              <button class="ctl text baseline tinyer" id="texteditor-zoomoutbtn">A</button>
            </span>
            <label class="clickable">
              <input type="checkbox" id="texteditor-wraptoggle" checked/>
              <span class="tag">wrap</span>
            </label>
          </span>
          <span class="content small right">
            <span class="btnbank">
              <button class="ctl" id="undoredo-undobtn"><span class="icon small undo"></span></button>
              <button class="ctl" id="undoredo-redobtn"><span class="icon small redo"></span></button>
              <button class="ctl closed" id="search-togglebtn" onclick="Main.togglesearch()"><span class="icon small search"></span></button>
            </span>
          </span>
        </span>
      </div>
    </div>

    <div id="search-menu" class="menu lower">
      <div class="menusection right">
        <span class="menusubsection">
          <span class="content">
<input type="text" class="inpctl short" id="search-find" value="" placeholder="String or /RegEx/"/>
<button class="dark" id='search-nextbtn'>&gt;</button>
<button class="dark" id='search-scrolltobtn'>&#x2022;</button>
<button class="dark" id='search-prevbtn'>&lt;</button>
<button class="dark" id='search-clearbtn'>C</button>
          </span>
        </span><span class="menusubsection">
          <span class="content">
<input type="text" class="inpctl short" id="search-replace" value=""/>
<button class="dark" id='search-replacebtn'>Replace</button>
<button class="dark" id='search-replaceallbtn'>All</button>
          </span>
        </span>
      </div>
    </div>

  </div>

  <div id="fontpicker-popup" class="popup closed">
    <div>
      <h3><i>f</i></h3>
      <input type="text" class="short" id="fontpicker-fontname" value=""/>
      <span class="big"><button class="ctl text" id="fontpicker-addbtn">+</button></span>
    </div>
    <div>
      <div class="p">
        <div id="fontpicker-list" class="list">
        </div>
      </div>
      <div id="fontpicker-msg" class="p">
        <i class="tinyer">Unavailable fonts render with system defaults</i>
      </div>
    </div>
  </div>

</body>
</html>

