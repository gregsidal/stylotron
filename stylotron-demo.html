<!DOCTYPE html>
<!--
  Demo for stylotron.js
  cc0 (public domain) v.010 November 2025
  project @ github.com/gregsidal
-->

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stylotron.js Demo</title>
  <meta content="Demo for stylotron.js: pattern based dynamic markup of plaintext" name="description">
  <meta content="" name="author">

  <style>
body {
  margin:0; padding:0; white-space:pre-wrap;
  font-family:sans-serif; font-size:0.98em; background-color:#b8b8b8;
}

/*!!!STYLOTRON IDE CSS START!!!*//*
 * CSS for Stylotron Demo
 * cc0 (public domain) v.010 September 2025
 * Stylotron project @ github.com/gregsidal
 *
 * Style blocks prefixed by .UNFOLDED apply only to editable markup
 * Style blocks prefixed by .FOLDED apply only to output html files
 * All other CSS is shared
 *
 * Note that using display:block to produce line feeds is not necessary
 * Line feeds in the plaintext are always line feeds in the markup
 * display:block is not WYSIWYG editable
 *
 * :before and :after are outside editable flow
 */

body {background-color:#bababa;}

/* defaults */
*, *::before, *::after {box-sizing:border-box; text-size-adjust:none; outline:none;}
div, textarea {display:inline-block; margin:0; border:0; border-radius:0; padding:0;}
span, button, input, select, label {display:inline-block; border-radius:0; vertical-align:middle;}
label, input[type="checkbox"], button {cursor:pointer;}
*::spelling-error {text-decoration-line:none;}
.FOLDED div {display:block;}

/* markup defaults */
mark {border-radius:0; color:inherit; background-color:transparent;}
mark.L {border-top-left-radius:0.25em; border-bottom-left-radius:0.25em;}
mark.R {border-top-right-radius:0.25em; border-bottom-right-radius:0.25em;}

/* panel framing */
body.FOLDED, .FOLDED .panelcontainer, .FOLDED .plaincontainer {
  position:fixed; left:0; top:0; right:0; bottom:0;
}
.FOLDED .panelcontainer, .FOLDED .plaincontainer {
  position:absolute; top:20px; overflow:auto; overflow-x:clip;
  width:53em; max-width:100%; margin:0 auto; background-color:white;
}
.FOLDED .plaincontainer {
  top:0; width:100%;
}
.FOLDED .panel {background-color:#f4f4f4;}
.FOLDED .separator {display:none;}
@media print {
  body.FOLDED, .FOLDED .toolbar, .FOLDED .panelcontainer, .FOLDED .plaincontainer {
    all:revert;
  }
}

/* toolbar */
.toolbar {
  font-size:12px; opacity:0.8; background-color:#646464; color:white;
}
.FOLDED .toolbar {
  position:fixed; left:0; top:0; right:0; bottom:0;
}
.FOLDED .toolbar, .FOLDED .toolbar .block, .FOLDED .toolbar .line {
  height:20px; width:100%; text-align:right;
}
label, input[type="checkbox"] {cursor:pointer;}
label {margin:0; padding:0.25em;}
.document > .block label, .plaincontainer label {vertical-align:initial;}
.document > .block label {border-radius:0.25em; padding:0.1em 0.3em;
  background-color:rgba(200,190,190,0.5);}
.plaincontainer label {padding:0; vertical-align:initial;}
.plaincontainer label:after {content:' x'; color:red;}
.document > .block label:hover, label:hover {background-color:rgba(210,120,120,0.5);}
.toolbar label:hover {background-color:rgba(255,190,190,0.99); color:black;}
input[type="checkbox"] {cursor:pointer; margin:0; margin-right:0.2em; width:0.85em; height:0.85em;}
@media print {
  .FOLDED .toolbar {display:none;}
}

/* document */
.documentcontainer, .document, .plaindocument {
  margin:0; border-radius:0; word-break:break-word;
}
.documentcontainer {padding:0; background-color:white; /*#d9d9d3;*/}
.document, .plaindocument {
  padding:1em; background-color:white;
}
.document {
  font-size:0.94em;
}
@media all and (min-width:749px) and (orientation:landscape) {
  .document {font-size:1.02em;}
}
.FOLDED .documentcontainer {
  white-space:pre-wrap;
}


/* (== spliced and pasted from stylotron-samplestyles.css ==) */

/*
 * CSS Shared by Stylotron Demos and Project Documents
 * cc0 (public domain) v.010 September 2025
 * Stylotron project @ github.com/gregsidal
 *
 * Style blocks prefixed by .UNFOLDED apply only to editable markup
 * Style blocks prefixed by .FOLDED apply only to output html files
 * All other CSS is shared
 *
 * The WYSIWYG editor currently doesn't run in an iframe, so some 
 * styles such as 'position:fixed' used without 'FOLDED' may cover up 
 * the IDE's toolbar or make the IDE unusable in other ways when 
 * toggled to markup view
 *
 * Note that using display:block to produce line feeds is not necessary
 * Line feeds in the plaintext are always line feeds in the markup
 * display:block is not WYSIWYG editable
 *
 * :before and :after are outside editable flow
 */

/* paragraphs, section headers */
.paragraph {font-family:serif;}
.paragraph::spelling-error, .paragraph *::spelling-error {text-decoration-line:spelling-error;}
.paragraph.windows {font-family:'agency fb',serif; font-size:1.1em;}
.footnote {font-family:sans-serif; font-size:0.89em;}
.block>.heading, .block>.paragraph>.heading, .heading .footnote {font-family:sans-serif; font-weight:bold; font-size:1.0em;}

/* code blocks with line numbers */
.codeblockcontainer {
  position:relative; background-color:white;
}
.codeblock {
  font-family:monospace; background-color:white;
}
.codeblock.multiline {
  margin-left:1.7em;
}
.FOLDED .codeblock {
  white-space:pre; overflow-x:auto; padding-bottom:0.2em;
}
/*.FOLDED .codeblock.multiline {
  border-left:1px dashed #a8a8a8; padding-left:0.8em;
}*/
.codeblock.multiline .line.L {counter-increment:line;}
.codeblock.multiline .line.L:before {
  content:counter(line);
  position:absolute; left:0; margin-top:0.35em; width:2.55em; text-align:center;
  font-family:sans-serif; font-size:45%; font-style:italic; color:#777;
}

/* highlights */
.codeblock .line, .codeblock .block {color:#111;}
.comment.html {font-family:'courier new'; font-size:0.87em; color:blue;}
.comment.js {font-family:monospace; font-style:italic; color:#061;}
a {font-family:sans-serif; font-size:95%;}
.paragraph .quoted::spelling-error {text-decoration-line:none;}
.quoted.double, .italic {font-style:italic;}
.codeblock .quoted.double {font-family:'courier new'; font-size:0.87em; color:#000;}
.quoted.single {font-family:monospace; font-size:100%; font-weight:bold; color:#559;}
.tag.html {color:#a55;}
.tag.inline {font-family:monospace; color:#aaa;}
.tag.inline.footref {vertical-align:top; padding-left:0.1em;}
.FOLDED .tag.inline {display:none;}
.codeblock .quoted.single {font-weight:normal; color:#333;}
.codeblock .tag, .codeblock .keyword, .bold {font-weight:bold;}
.codeblock .quoted {color:#000;}
.codeblock .tag, a {color:#559;}
.codeblock .tag.html {color:#a55;}
.codeblock .keyword {color:#a55;}
a:visited {color:#684878;}
.regex, .number {font-family:'courier new'; font-size:0.87em; font-weight:bold; font-style:normal;}
.regex {color:#888;}
.number {color:#81a;}
.numberprefix, .footnotetag, .footnote .number:first-child {font-family:monospace; font-size:0.82em; font-style:normal; vertical-align:middle; color:#999;}
.heading .number, .heading .footnote .number {font-family:sans-serif; font-size:1.4em; font-style:italic; color:#e77; vertical-align:inherit;}
.footnoteref {font-family:sans-serif; font-size:0.8em; color:#e77 !important; vertical-align:top;}
.FOLDED .footnoteref {padding-left:0.3em;}
.regex .regexslashed {color:#d00;}
.regex .regexpattern {/*background-color:#f8f4ec;*/ color:#333;}

/* remove undesirable nested highlights */
.comment *, 
.codeblock .footnote,
.codeblock .footnote .number, .codeblock .footnote .number:first-child,
.codeblock .comment *, 
.comment .regex *, 
.codeblock .comment .regex *, 
.codeblock .comment .quoted,
.quoted *, 
.codeblock .quoted *, 
.tag.inline *,
.tag.inline.footref *,
.tag *, 
.codeblock .tag *, 
.codeblock .tag .quoted,
.regex .regexpattern *, 
.regex .comment, 
.regex .quoted, 
.codeblock .regex .quoted, 
.tag .number {
  font-family:inherit; font-size:inherit; font-style:inherit; font-weight:inherit; color:inherit; vertical-align:inherit;
}
.codeblock .quoted, .codeblock .tag .quoted {font-style:italic;}
.codeblock .regex .quoted {font-style:inherit;}

/* logo */
.heading .logoleft, .heading .logoright {font-weight:normal;}
.heading .logoright, .paragraph .logoright {
  position:relative; border:0.5px solid black;
  font-family:'courier new'; letter-spacing:0.04em;
  background-color:rgba(80,80,220,0.25); color:black;
}
.heading .logoleft, .paragraph .logoleft {
  font-family:'agency fb',sans-serif; font-style:italic;
  background-color:rgba(220,160,20,0.35); color:royalblue;
}
.heading .logoright {bottom:6px; font-size:16px;}
.heading .logoleft {font-size:38px;}
.paragraph .logoright {bottom:4px; font-size:10px;}
.paragraph .logoleft {font-size:20px;}
.heading .logoright.L, .paragraph .logoright.L {margin-left:0.13em; padding-left:0.13em; border-right:0;}
.heading .logoright.R, .paragraph .logoright.R {padding-right:0.13em; border-left:0;}
.heading .logoleft .logoright, .paragraph .logoleft .logoright {
  font-style:normal; background-color:rgba(205,200,205,0.72);
}

/* tooltip */
.FOLDED .link.L {
  position:relative; cursor:pointer;
}
.FOLDED .link.lib.L:after {
  position:absolute; left:90%; top:105%; /*margin-left:-50%; right:auto; bottom:auto;*/ z-index:1;
  visibility:hidden; opacity:0; transition: visibility 0.5s ease-in, opacity 0.5s ease-in;
  border-radius:0.3em; padding:0.2em;
  content:attr(tooltip);
  white-space:pre; text-align:center;
  font-family:sans-serif; font-size:60%; background-color:black; color:white;
}
.FOLDED .link.lib.L:hover:after {
  visibility:visible; opacity:1.0;
}

/* input and button */
.inputcontainer, .button {
  font-family:sans-serif; font-size:0.90em;
}
.input, .button {
  padding:0.2em;
}
.inputcontainer * {
  font-family:inherit; font-size:inherit; font-style:inherit; font-weight:inherit; color:inherit; vertical-align:inherit;
}
.input {
  margin-left:0.5em; border:0.5px solid #d8d8d8;
}
.button {
  border:0; border-radius:0.3em; background-color:black; color:white;
}
.button:hover {
  background-color:#a77;
}

/* image */
.image {
  position:relative; display:inline-block !important;
  border-radius:0.3em; padding:0.2em;
  font-family:sans-serif; font-size:60%; background-color:black; color:white;
}
.image.sample:before, .FOLDED .img {
  position:relative; display:block;
}
.image.sample:before { 
content:url("data:image/png;base64,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");
}

/* (== end pasted from ==) */


/* demos */
.selectable {font-size:160%;}
.selectable .match {
  background-color:rgba(220,140,140,0.65);
}
.selection {background-color:rgba(185,210,210,0.65);}
.selection:hover {
  cursor:pointer; background-color:rgba(120,255,120,0.65);
}
.document > .block.singleline > .line > .cat {
  font-size: 160%; color:rgba(110,200,110,0.99);
}
.document > .block.multiline > .line > .cat {
  font-size: 160%; background-color:rgba(110,210,110,0.65);
}

/*!!!STYLOTRON IDE CSS END!!!*/
  </style>

  <!--script type="text/javascript" src="lib/stylotron.js"/script-->
  <script>
/*
 * stylotron.js
 *
 *   SOT.text.map:        low level text parser, builds segmented range maps from a series of overlapping regex matches
 *   SOT.PatternSeries:   abstraction of a pattern series, produces SOT.text.maps and layered html
 *
 *   single step markup:  html = SOT.markup( text, patterndefs )
 *
 * stylotron-demo.html provides tutorial and example of use
 *
 * cc0 (public domain) v.010 September 2025, latest version @ github.com/gregsidal
 */

const SOT = {};

/*
 *  html = SOT.markup( text, patterndefs )
 *    marks up matches of of a pattern series, returns html
 *
 *    patterndefs = {def...}
 *      each def is one of these:
 *        'class': regex or string
 *          matches of each regex (or string) are styled with 'class'
 *        'class': {'regex': .., ..opts..}
 *        'class': {'range': {'start': .., 'end': ..}, ..opts..}
 *      opts can include:
 *        htmltag: ..
 *        htmlattrs: {...}
 *
 *  strings can be full regex's like "/.+/g" (a string without slashes in the right places is a literal)
 *  regex's must include 'g' flag or pattern is ignored ('g' is added to regex strings if needed)
 *
 *  matches that overlap/cover others are segmented and marked up in layers, see SOT.map.markup comments
 *  ranges are overlaid (applied last) by default, use opts={overlayranges:false} to apply ranges in order
 *    (the logic for the default is that ranges are usually types of selections, which are typically overlaid)
 *
 *  'htmlattrs' are added to starting tag: htmltag='a', htmlattrs={href:'A',target='B'} produces "<a href='A' target='B'>"
 *    attr strings can include '$_&' replacement wildcard, where $_& == matched text
 *    attr can also be a regex, in which case attr is whatever the regex extracts from matched text
 */
SOT.markup = function( text, defs, opts, callback ) {
  const patterns = new SOT.PatternSeries();
  patterns.add( defs );
  if (callback)
    patterns.setmarkupcallback( callback );
  return patterns.markup( text, undefined, opts );
}

/*
 *  SOT.PatternSeries
 *    registers regex's and ranges with associated CSS classes; produces SOT.text.maps and layered markup
 *
 *    patterns = new SOT.PatternSeries()
 *
 *    patterns.addregex( regex, cls )
 *      adds a regex (or string), matches will be styled with with CSS class 'cls'
 *      (strings can be literals or regex's including slashes and flags, ie "/.+/g")
 *    patterns.addrange( range, cls )
 *      adds a range
 *    patterns.add( defs )
 *      adds one or more defs, refer to SOT.map.markup comments
 *
 *    map = patterns.buildmap( text, map=[], overlayranges=true )
 *      builds a SOT.text.map of 'text'
 *        ('map' can be fed to SOT.map.markup to produce the HTML)
 *      ranges are applied last by default, use overlayranges=false to apply ranges in order
 *    HTML = patterns.markup( text )
 *      marks up defs, see SOT.map.markup
 *
 *    prevcallback = patterns.setmarkupcallback( callback )
 *      see SOT.map.markup for callback spec
 *      callback replaces any other previously set
 */
SOT.PatternSeries = function() {
  var defs = {};
  this.requiredregexflags = 'g';
  this.get = function( cls ) {
    return defs[cls];
  }
  this.addregexstr = function( regexstr, cls, reqflags=this.requiredregexflags, defin, alertiferror ) {
    var regex;
    try {
      //regex = new RegExp( regexstr, flags );
      regex = SOT.text.regexstr2regex( regexstr, reqflags );
    }
    catch( e ) {
      if (alertiferror)
        alert( e );
      return null;
    }
    if (defin)
      defs[cls] = defin;
    else
      defs[cls] = {};
    defs[cls].regexstr = regexstr, defs[cls].regex = regex;
    return regex;
  }
  this.addregex = function( regex, cls, reqflags ) {
    if (regex)
      if (typeof regex == 'string')
        this.addregexstr( regex, cls, reqflags );
      else
        defs[cls] = {'regex':regex};
  }
  this.addrange = function( range, cls ) {
    if (!defs[cls] || defs[cls].range.start != range.start || defs[cls].range.end != range.end) {
      defs[cls] = {'range': range};
      return true;
    }
  }
  this.add = function( defsin ) {
    for( var cls in defsin )
      if (defsin[cls])
        if (typeof defsin[cls] == 'string' || defsin[cls] instanceof RegExp)
          this.addregex( defsin[cls], cls );
        else
          if (defsin[cls].regex && typeof defsin[cls].regex == 'string')
            this.addregexstr( defsin[cls].regex, cls, this.requiredregexflags, defsin[cls] );
          else
            defs[cls] = defsin[cls];
  }
  this.del = function( cls ) {
    if (defs[cls]) {
      delete defs[cls];
      return true;
    }
  }
  this.delregexs = function() {
    var m = {};
    for( var cls in defs )
      if (!defs[cls].regex)
        m[cls] = defs[cls];
    defs = m;
  }
  this.delranges = function() {
    var m = {};
    for( var cls in defs )
      if (!defs[cls].range)
        m[cls] = defs[cls];
    defs = m;
  }
  this.clear = function() {
    defs = {};
  }
  this.buildmatchesmap = function( text, map=[] ) {
    for( var cls in defs  )
      if (defs[cls].regex)
        map = SOT.text.map.addmatches( text, defs[cls].regex, cls, true, map );
    return map;
  }
  this.buildrangesmap = function( text, map=[] ) {
    for( var cls in defs )
      if (defs[cls].range)
        map = SOT.text.map.addrange( text, defs[cls].range, cls, true, map );
    return map;
  }
  this.buildmap = function( text, map=[], overlayranges=true ) {
    if (overlayranges) {
      map = this.buildmatchesmap( text, map );
      map = this.buildrangesmap( text, map );
    }
    else {
      for( var cls in defs )
        if (defs[cls].regex)
          map = SOT.text.map.addmatches( text, defs[cls].regex, cls, true, map );
        else
          if (defs[cls].range)
            map = SOT.text.map.addrange( text, defs[cls].range, cls, true, map );
    }
    return map;
  }
  var markupcallback;
  this.setmarkupcallback = function( callback ) {
    var prev = markupcallback ? markupcallback : function(attrs){return attrs;};
    markupcallback = callback;
    return prev;
  }
  this.markupmap = function( text, map, opts ) {
    return SOT.map.markup( text, map, opts, defs, markupcallback );
  }
  this.markup = function( text, map=[], opts={overlayranges:true} ) {
    return SOT.map.markup( text, this.buildmap(text,map,opts.overlayranges), opts, defs, markupcallback );
  }
}

/*
 *  HTML = SOT.map.markup( text, map, opts, callback )
 *    generates layered html from a SOT.text.map
 *    (a SOT.PatternSeries object can be used to set regex/class associations and create the map)
 *
 *  The set names in the map (see SOT.text.map) are the CSS class names used in the mark up
 *
 *  Segments (intersections of overlapping ranges, see SOT.text.map) are marked up in layers
 *
 *  A segment's CSS class list indicates what part of the original range the segment was synthesized from:
 *    a leftmost segment includes "L" and a rightmost segment includes "R"
 *    a middle segment includes neither "L" nor "R"
 *    an unsegmented range includes both "L" and "R"
 *
 *  Examples:
 *
 *    a range of 'cls1' covers another of 'cls0', will be marked up as follows:
 *
 *      <mark class="cls0 L R">
 *        Some
 *        <mark class="cls1 L R">text</mark>
 *        is here
 *      </mark>
 *
 *    the order the patterns are applied is important, if 'cls1' is background:
 *
 *      <mark class="cls0 L">Some </mark>
 *      <mark class="cls1 L R">
 *        <mark class="cls0">text</mark>
 *      </mark>
 *      <mark class="cls0 R"> is here</mark>
 *
 *  'opts': {'htmltag': ..}
 *    if provided, 'htmltag' will be used instead of "mark" globally
 *      (tags can also be specified per-class in 'defs', see SOT.markup comments)
 *
 *  'callback': attrs = function( params )
 *    optional, will be fired on each tag, params:
 *      'attrs': passed in will be {'class': .., ...}, example: {'class': "cls1 L  "}
 *      'class': the class name
 *      'map': the text map
 *      'mapindex': index in 'map' array
 *      'layerindex': index in 'origs' subarray (see SOT.text.map)
 *      'opts': passed in opts
 *    callback can modify and/or add to 'attrs'
 */
SOT.map = {
  markup: function( fulltext, map, opts, defs, callback ) {
    function _tag( layer, end ) {
      var tag = 'mark';
      if (opts && opts.htmltag)
        tag = opts.htmltag;
      if (defs)
        if (end && defs[layer.setname].htmltagend != undefined)
          tag = defs[layer.setname].htmltagend;
        else
          if (defs[layer.setname].htmltag)
            tag = defs[layer.setname].htmltag;
      return tag;
    }
    function _addattrs( attrs, addattrs, origrange ) {
      for( const a in addattrs )
        if (addattrs[a] instanceof RegExp)
          attrs[a] = SOT.text.extract( fulltext.slice(origrange.start,origrange.end), addattrs[a] );
        else
          if (typeof addattrs[a] == 'string')
            attrs[a] = addattrs[a].replace( "$_&", fulltext.slice(origrange.start,origrange.end) );
      return attrs;
    }
    function _istagdif( seg, compareseg, layerindex ) {
      return (!compareseg || layerindex >= compareseg.origs.length || 
              seg.origs[layerindex].setname != compareseg.origs[layerindex].setname ||
              seg.origs[layerindex].range.setindex != compareseg.origs[layerindex].range.setindex);
    }
    function _difdepth( seg, compareseg ) {
      for( var depth=0; depth<seg.origs.length; depth++ )
        if (_istagdif( seg, compareseg, depth ))
          break;
      return depth;
    }
    /*
     * 
     */
    function _tagstart( seg, layer, mapindex, j, pieceindex, offset, insidetext ) {
      var tag = _tag(layer), t = "";
      /* build class attribute */
      var attrs = {'class': layer.setname};
      if (layer.range.start == seg.start)
        attrs['class'] += " L";
      if (defs && defs[layer.setname].htmlattrs)
        attrs = _addattrs( attrs, defs[layer.setname].htmlattrs, layer.range );
      /* get dynamic attributes if any */
      if (callback)
        attrs = callback( {'attrs':attrs,
                           class:layer.setname,
                           'map':map,
                           'mapindex':mapindex,
                           layerindex:j, 
                           'opts':opts} );
      /* markup html tag with attrs */
      t += "<" + tag;
      for( var a in attrs ) {
        t += " " + a + (attrs[a] ? ('="' + attrs[a]) : '');
        if (a == 'class') {
          t += "  ";
          starts[layer.setname] = {pos: offset+t.length-1, 'pieceindex': pieceindex, 'j': j, 'seg': seg};
        }
        t += attrs[a] ? '"' : '';
      }
      return t + ">";
    }
    function _layersstart( prevseg, seg, mapindex, pieceindex, insidetext ) {
      var j =_difdepth( seg, prevseg );
      for( var tags=""; j<seg.origs.length; j++ )
        tags += _tagstart( seg.range, seg.origs[j], mapindex, j, pieceindex, tags.length, insidetext );
      return {'tags':tags, 'insidetext':insidetext};
    }
    /*
     * 
     */
    function _tagend( layer ) {
      const tag = _tag( layer, true );
      if (!tag)
        return "";
      return "</" + SOT.text.extractto(tag, /^[A-Za-z0-9-_]+/) + ">";
    }
    function _layersend( seg, nextseg ) {
      var j =_difdepth( seg, nextseg );
      for( var t="",k=seg.origs.length-1; k>=j; k-- )
        t += _tagend( seg.origs[k] );
      return {tags:t};
    }
    function _setlayerright( seg ) {
      var piece = "";
      for( const layer of seg.origs ) {
        if (starts[layer.setname] && layer.range.end == seg.range.end) {
          /* (insert 'R' in class list) */
          piece = html[starts[layer.setname].pieceindex];
          piece = piece.slice( 0, starts[layer.setname].pos ) +
                  "R" +
                  piece.slice( starts[layer.setname].pos+1 );
          html[starts[layer.setname].pieceindex] = piece;
          delete starts[layer.setname];
        }
      }
    }
    const html = [];
    function htmladd( piece ) {
      if (piece)
        html.push( piece );
    }
    function htmlstring() {
      var hs = "";
      for( const piece of html )
        hs += piece;
      return hs;
    }
    var text = "", start = {}, end = {}, starts = {};
    var prevseg, seg, nextseg;
    for( var i=0,n=0; i<map.length; prevseg=seg,i++ ) {
      seg = map[i];
      htmladd( SOT.text.raw2HTML(fulltext.slice(n, seg.range.start)) );
      nextseg = i < map.length-1 ? map[i+1] : null;
      start = _layersstart( prevseg, seg, i, text ? html.length+1 : html.length, 
                            SOT.text.raw2HTML(fulltext.slice(seg.range.start,seg.range.end)) );
      if (start.tags) {
        htmladd( text ), text = "";
        htmladd( start.tags );
        htmladd( start.insidetext );
      }
      else
        text += start.insidetext;
      end = _layersend( seg, nextseg );
      if (end.tags) {
        if (text)
          htmladd( text + end.tags ), text = "";
        else
          htmladd( end.tags );
        _setlayerright( seg );
      }
      n = seg.range.end;
    }
    return htmlstring() + SOT.text.raw2HTML( fulltext.slice(n) );
  }
}

/*
 *  Text helpers
 */
SOT.text = {
  str2regex: function( regexstr, flags='' ) {
    regexstr = regexstr.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' );
    return new RegExp( regexstr, flags );
  },
  parseregexstr: function( str, reqflags='' ) {
    const regexparts = {pattern: SOT.text.extract( str, /(?<=^\/).+(?=\/\w*$)/ )};
    if (regexparts.pattern) {
      regexparts.flags = SOT.text.extract( str, /(?<=^\/.+\/)\w*$/ );
      if (!regexparts.flags)
        regexparts.flags = reqflags;
      else
        if (!SOT.text.extract( regexparts.flags, SOT.text.str2regex(reqflags) ))
          regexparts.flags += reqflags;
    }
    return regexparts;
  },
  regexstr2regex: function( str, reqflags='' ) {
    const regexparts = SOT.text.parseregexstr( str, reqflags );
    var regex;
    if (regexparts.pattern)
      regex = new RegExp( regexparts.pattern, regexparts.flags );
    else
      regex = SOT.text.str2regex( str, reqflags );
    return regex;
  },
  raw2HTML: function( text ) {
    var newtext = text.replace( /&/g, "&amp;" );
    newtext = newtext.replace( />/g, "&gt;" );
    return newtext.replace( /</g, "&lt;" );
  },
  startswith: function( s, sub ) {
    return s && sub && s.substring( 0, sub.length ) == sub;
  },
  extract: function( s, substr ) {
    const x = s.match( substr );
    if (x && x[0] !== null)
      return x[0];
    return null;
  },
  extractto: function( s, sub ) {
    s = s.match( sub );
    return s[0];
  },
  /* replace range */
  paste: function( text, range, replacewith ) {
    var newtext = text.slice( 0, range.start );
    var token = text.substring( range.start, range.end );
    //newtext += token.replace( SOT.text.str2regex(token,''), replacewith );
    newtext += token.replace( token, replacewith );
    newtext += text.slice( range.end );
    return newtext;
  }
}

/*
 *  SOT.text.map
 *    builds segmented range maps from series of regex matches
 *
 *    map = SOT.text.map.addmatches( text, regex, setname, segment?, map=[] )
 *      adds set of ranges matching regex to map
 *
 *    map = SOT.text.map.addrange( text, range, setname, segment?, map=[] )
 *      adds a range to map
 *
 *  Maps are ordered arrays, each element has the form {range:{start:., end:.}, origs:[...]}
 *
 *  Maps are flat, 'segment?' determines how ranges that overlap or cover others are treated when being added:
 *    !: range being added will overwrite any it overlaps or covers (usurped ranges are discarded)
 *    else: overlapping or covered ranges are segmented
 *
 *  The 'origs' array specifies what range(s) a segment was synthesized from:
 *    each element of 'origs' has the form: {setname:"..", range:{start:.,end:.}}
 *      example: intersection segment resulting from a range of "set0" overlapping one of "set1": 
 *               origs = [{setname:"set0", range:..}, {name:"set1", range:..}]
 *    for unsegmented ranges, origs = [{setname:<samename>, range:<samerange>}
 *
 *  Replace operations:
 *
 *    text = SOT.text.map.replace( text, map, i, newtext )
 *      replaces range i in text with newtext
 *
 *    text = SOT.text.map.replaceall( text, map, i, replacewiths )
 *      replaces all ranges, replacewiths = {setname:"new text", ...}
 *      segment's setname determines the replacement text to use (replacewiths[segment.origs[0].setname])
 *
 *   Segmented ranges are ignored during replacements (replace ops on segments are nonsensical)
 */
SOT.text.map = {
  range: {
    neworigs: function( setname, range={start:0,end:0,setindex:0} ) {
      if (typeof setname == 'string')
        return [{'setname':setname, 'range':{start:range.start,end:range.end,'setindex':range.setindex}}];
      return set;
    },
    mk: function( start, end, origs ) {
      return {range:{'start':start, 'end':end}, 'origs':origs};
    },
    copy: function( r ) {
      return {range:{start:r.start, end:r.end}, origs:r.origs};
    },
    isposin: function( pos, map, i ) {
      return (i >= 0 && i < map.length && pos >= map[i].range.start && pos <= map[i].range.end);
    },
    next: function( pos, map ) {
      var i = -1, test = 0;
      if (map.length) {
        if (map[0].range.end > pos)
          i = 0;
        else {
          i = map.length - 1;
          if (pos < map[i].range.start) {
            var j = map.length/2;
            for( i=j;
                 Math.round(j);
                 j/=2, map[Math.round(i)].range.end<=pos ? i+=j : i-=j, test++ ) //(bin search)
              ;
            i = Math.round( i );
          }
        }
        //console.log( "BINSEARCH 0: " + test );
        for( ; i < map.length && map[i].range.end <= pos; i++, test++ )
          ;
        //console.log( "BINSEARCH 1: " + test );
      }
      return i;
    },
    before: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (i >= 0 && SOT.text.map.range.isposin( pos, map, i ))
        i++;
      return i >= 0 ? Math.max(0,i-1) : i;
    },
    after: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (SOT.text.map.range.isposin( pos, map, i ))
        i++;
      return i;
    },
    nearest: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      i = Math.min( i, map.length-1 );
      if (i > 0 && !SOT.text.map.range.isposin( pos, map, i )) {
        if (pos < ((map[i].range.start - map[i-1].range.end) / 2) + map[i-1].range.end)
          i--;
      }
      return i;
    },
    atpos: function( pos, map ) {
      var i = SOT.text.map.range.next( pos, map );
      if (!SOT.text.map.range.isposin( pos, map, i ))
        i = -1;
     return i;
    }
  },
  /*
   * segmentation loop illustration (_segment):
   *
   *    is0----ie0  is1--ie1        is2----ie2   target sequence, first ie > ms
   *        ms--------------------------me       input (range to add)
   * *
   *    continues while isN < me
   *
   *    is0----ie0
   *        ms--------------------------me
   *    is0-ms-ie0                               segments = [mins,maxs,mine]
   *           ie0----------------------me       next input = [mine,maxe]
   *
   *                is1--ie1
   *           ms-----------------------me
   *           ms---is1--ie1                     segments = [mins,maxs,mine]
   *                     ie1------------me       next input = [mine,maxe]
   *
   *                                is2----ie2
   *                     ms-------------me
   *                     ms---------is2-me       segments = [mins,maxs,mine]
   *                                    me-ie2   next input = [mine,maxe]
   *
   *                                    ms--me   last (dangling) segment
   */
  _seg2: function( m, i, p ) {
    var r = {start:Math.min(m.range.start, i.range.start), end:Math.max(m.range.start, i.range.start)};
    if (r.start < r.end)
      p.newmap.push( SOT.text.map.range.mk(r.start,r.end,r.start<i.range.start?m.origs:i.origs) );
    r = {start:Math.max(m.range.start, i.range.start), end:Math.min(m.range.end, i.range.end)};
    p.newmap.push( SOT.text.map.range.mk(r.start,r.end,[...i.origs,...m.origs]) );
    r = {start:Math.min(m.range.end, i.range.end), end:Math.max(m.range.end, i.range.end)};
    return SOT.text.map.range.mk( r.start, r.end, r.start<m.range.end?m.origs:i.origs );
  },
  _segment: function( start, end, origs, map=[], p ) {
    var m = SOT.text.map.range.mk( start, end, origs );
    if (p.newmap.length && m.range.start < p.newmap[p.newmap.length-1].range.end) {
      /* (edge case: when ranges are added in sequence (regex matches), newmap may contain an iceberg segment) */
      var i = p.newmap.pop();
      m = SOT.text.map._seg2( m, i, p );
    }
    for( ; p.i<map.length && map[p.i].range.start<m.range.end; p.i++ )
      m = SOT.text.map._seg2( m, map[p.i], p );
    if (m.range.start < m.range.end)
      p.newmap.push( m );
    return p;
  },
  /* insert range at current location; discard ranges it overlaps or covers */
  _overwrite: function( start, end, origs, map=[], p ) {
    p.newmap.push( SOT.text.map.range.mk(start,end,origs) );
    for( ; p.i < map.length && map[p.i].range.end <= end; p.i++ )
      ;
    if (p.i < map.length && map[p.i].range.start < end)
      p.i++;
    return p;
  },
  /* insert a range into map; overwrite or segment overlapping/covered ranges */
  _insertrange: function( start, end, set, map, segment, p={newmap:[],i:0,setindex:0} ) {
    for( ; p.i < map.length && map[p.i].range.end <= start; p.i++ )  // add all before entries
      p.newmap.push( map[p.i] );
    var origs = SOT.text.map.range.neworigs( set, {'start':start,'end':end,'setindex':p.setindex} );
    if (segment)
      p = SOT.text.map._segment( start, end, origs, map, p );
    else
      p = SOT.text.map._overwrite( start, end, origs, map, p );
    return p;
  },
  /* add trailing ranges */
  _addendranges: function( map=[], p ) {
    for( ; p.i<map.length; p.i++ )
      p.newmap.push( map[p.i] );
    return p.newmap;
  },
  /* add ranges from regex match to map */
  addmatches: function( text, regex, setname, segment, map=[], alertiferror ) {
    var p = {newmap:[],i:0,setindex:0};
    var matches;
    try {
      matches = text.matchAll( regex );
    }
    catch( e ) {
      if (alertiferror)
        alert( e );
      return map;
    }
    /* (optimization: matches are added in a single pass) */
    for( const match of matches ) {
      p = SOT.text.map._insertrange( match.index, match.index+match[0].length, setname, map, segment, p );
      p.setindex++;
    }
    return SOT.text.map._addendranges( map, p );
  },
  /* add ranges from regex match to map */
  _X_addmatches: function( text, regex, setname, segment, map=[] ) {
    var p = {newmap:[],i:0,setindex:0};
    /* (optimization: matches are added in a single pass) */
    var match;
    while( match = regex.exec(text) )
      if (match[0].length) {
        p = SOT.text.map._insertrange( match.index, match.index+match[0].length, setname, map, segment, p );
        p.setindex++;
      }
      else {
        regex.lastIndex++;
  //console.log( regex );
      }
    return SOT.text.map._addendranges( map, p );
  },
  /* add a range to map */
  addrange: function( text, range, setname, segment, map=[] ) {
    if (range.start > range.end)
      range = {start:range.end, end:range.start};
    var p = SOT.text.map._insertrange( range.start, range.end, setname, map, segment );
    return SOT.text.map._addendranges( map, p );
  },
  /* replace all ranges, replacewiths={setname:"..", ...} */
  replaceall: function( text, map, replacewiths ) {
    if (!map.length)
      return text;
    var newtext = "", token;
    for( var i=0,n=0; i<map.length; i++ ) {
      newtext += text.slice( n, map[i].range.start );
      token = text.substring( map[i].range.start, map[i].range.end );
      if (map[i].origs.length == 1 &&
          map[i].origs[0].range.start == map[i].range.start && map[i].origs[0].range.end == map[i].range.end)
        //newtext += token.replace( SOT.text.str2regex(token,''), replacewiths[map[i].origs[0].setname] );
        newtext += token.replace( token, replacewiths[map[i].origs[0].setname] );
      else
        newtext += token;
      n = map[i].range.end;
    }
    newtext += text.slice( n );
    return newtext;
  },
  /* replace a range */
  replace: function( text, map, i, newtext ) {
    if (i >= map.length)
      return text;
    var replacewiths = {};
    replacewiths[map[i].origs[0].setname] = newtext;
    return SOT.text.map.replaceall( text, [map[i]], replacewiths );
  }
}
  </script>

  <script>
const UserDocument = {FOLDED: true};
/*!!!STYLOTRON IDE JS START!!!*//*
 * Patterns for Stylotron Demo
 * cc0 (public domain) v.010 September 2025
 * Stylotron project @ github.com/gregsidal
 */
UserDocument.patternseries = {
  /* framing elements */
  panelcontainer:          {regex: /(?:.*(?:\n|$))*/g, htmltag: 'div', htmlattrs: {id:'panelcontainer'}},
  document:                {regex: /(?:.*(?:\n|$))*/g, htmltag: 'div'},
  toolbar:                 {regex: /^.+/g, htmltag: 'div'},
  separator:               /(?<=^.+\n)\n+/g,


  /* (== spliced and pasted from slylotron-samplepatterns.js ==) */

/*
 * Patterns Shared by Stylotron Demos and Project Documents
 * cc0 (public domain) v.010 September 2025
 * Stylotron project @ github.com/gregsidal
 *
 * Pattern series must be in 'UserDocument' namespace to be visible to IDE
 * Functions and other javascript can also be added to UserDocument
 * Patterns without g flag in regex are ignored
 *
 * Patterns that will mark up as images, form controls, etc. must be high enough in the pattern order to 
 * prevent them from being segmented
 *
 * Regexs can be tested and optimized using search in Plaintext view
 *   shape of match's endcaps will reveal whether line feeds at match's beginning or end are captured by regex
 *   the browser may timeout when iterating through the matches of some poorly designed regex's
 */

  /*
   * inner containers
   */
  'block multiline':       /.+(?:\n(?!\n).+)+/g,
  'block singleline':      /(?<=\n\n+|^\n*).+(?=\n\n+|\n*$)/g,
  codeblockcontainer:      {regex: /(?:.*(?:[\{<=]|\/\*).*(\n(?!\n).+)+)|(?:(?<=\n\n+) +.+(?=$|\n\n+))/g, htmltag: 'div'},
  'codeblock multiline':   {regex: /.*(?:[\{<=]|\/\*).*(\n(?!\n).+)+/g, htmltag: 'div'},
  'codeblock snippet':     {regex: /(?<=\n\n+) +.+(?=$|\n\n+)/g, htmltag: 'div'},
  paragraph:               /(?<=\n\n+|^\n*)([A-Z].+[.?!:][ ]*)+.*(?=(?:\n\n+|\n*$))/g,
  heading:                 /(?<=^\n*|\n\n+)(?:[0-9. -]+)*(?:(?:(?:[A-Z0-9@#$][a-z0-9-'",!?]*)|o[rnf]{0,1}|t[o]{0,1}|th[e]{0,1}|a|an|as|and|by|vs|i[sn]*|f|fo|for) *)+(?=\n\n+)/g,
  footnote:                {regex: /(?<=\n)\d +.+(?=$|\n)/g, 
                            htmlattrs: {id: /\d/g}},
  line:                    /.+/g,
  /*
   * patterns that allow buttons (_#...#_) and inputs (_$...$_) to be inserted inline
   * while editing (the default CSS causes the tags to disappear when .FOLDED)
   */
  button:                  {regex: /(?<=_#).+?(?=#_)/g, htmltag: 'button',
                            htmlattrs: {id: "$_&", onclick: 'UserDocument.buttononclick(this)'}},
  inputcontainer:          {regex: /_\$.+?\$_/g, htmltag: 'label',
                            htmlattrs: {id: /(?<=_\$).+(?=\$_)/g}},
  input:                   {regex: /(?<=_\$.+)\$_/g, htmltag: 'input', htmltagend: '',
                            htmlattrs: {type: 'text', onchange: 'UserDocument.inputonchange(this)'}},
  /*
   * a sample image, uses CSS :before
   */
  'image sample':          {regex: "sample image", htmltag: 'div'},
  /*
   * links to page (caveat: won't capture file names containing spaces)
   */
  'link page':             {regex: /[-\w]+\.html/g, htmltag: 'a', 
                            htmlattrs: {href: "$_&", target: "_blank"}},
  /*
   * links to lib sources
   */
  'link lib main':         {regex: /lib\/(?:\w|\-)+\.(?:js|css)/g, htmltag: 'a', 
                            htmlattrs: {href: "$_&", target: "_blank", tooltip: "view source"}},
  'link lib':              {regex: /[Ss]tylotron-\w*\.(?:js|css)/g, htmltag: 'a', 
                            htmlattrs: {href: "$_&", target: "_blank", tooltip: "view source"}},
  /*
   * patterns that allow italics (_`...`_), bold (_"..."_) and footnote refs (^num) to be
   * added inline while editing (the default CSS causes the tags to disappear when .FOLDED)
   */
  'tag inline':            /_`|`_|_"|"_|_#|#_|_\$|\$_|_@|@_/g,
  'tag inline footref':    /\^(?=\d)/g,
  italic:                  /(?<=_`).*?(?=`_)/g,
  bold:                    /(?<=_").*?(?="_)/g,
  /*
   * comment atoms
   */
  'comment html':          /(?<=^|\W)\<\!--(?:.|\n)+?--\>/g,
  'comment js':            /(?<=^|\W)\/\*(?:.|\n)+?\*\/|\/\/.*/g,
  /* 
   * regexs
   */
  regex:                   /(?<=\W)\/.+\/[gmis]+(?=[ .,;\n\]\}\)])/g,
  regexslashed:            /(?<=\W)\/.+\/(?=[gmis]+[ .,;\n\]\}\)])/g,
  regexpattern:            /(?<=\W\/).+(?=\/[gmis]+[ .,;\n\]\}\)])/g,
  /*
   * code tags
   */
  'tag js':                /(?<=^|[\{\[\(\s,])[\w-]+(?=:)/g,
  'tag json':              /(?<=^|\W)'[\w- ]+'(?=:)/g,
  'tag html':              /(?<=<\/{0,1})\w+(?=[\s\[>])/g,
  /*
   * quoted
   */
  'quoted single':         /(?<=^|\W)'.*?'(?=\W)/g,
  'quoted double':         /(?<=^|\W)".*?"(?=\W)/g,
  /*
   * number-like atoms
   */
  'number dec':            /(?<=^|[^\w.#])[+|-]{0,1}(?:\d+[.]\d+|\d+)(?=$|[^\w.]|\.[ \n]+|px\W|em\W|rem\W)/g,
  'number hex':            /(?<=#)[A-Fa-f0-9]+(?=$|\W)/g,
  'number htmlentity':     /&(?:[a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/g,
  numberprefix:            /[@#$](?=[A-Fa-f0-9]+(?:$|\W))/g,
  footnoteref:             {regex: /(?<=\^)\d/g, htmltag: 'a', htmlattrs: {href: "#$_&"}},
  /*
   * logo
   */
  logoleft:                "STYLO",
  logoright:               "OTRON",
  
  /* (== end pasted from ==) */


  /* containers demo */
  cat:                     "CAT",

  /* segmentation demo */
  'selectable first':      "Lorem ipsum Dolor sit amet", //, consectetur adipiscing elit, sed do
  'selectable second':     "Lorem ipsum Dolor amet sit",

  'selection first':       "rem ipsum Dolor sit am",
  match:                   /(?<=(^|[ \n]))[A-Z][a-z0-9-_]*(?=($|[ \n]))/g,
  'selection second':      "rem ipsum Dolor amet s",


  /* toolbar toggle */
  'toggle view':           {regex: /^ *plaintext/g, htmltag: 'label', htmlattrs: {id:'view', onclick: "UserDocument.toggleview(false)"}},
}

UserDocument.plaintextpatternseries = {
  plaincontainer:          {regex: /(.*(\n|$))*/g, htmltag: 'div'},
  panel:                   {regex: /(.*(\n|$))*/g, htmltag: 'div'},
  plaindocument:           {regex: /(.*(\n|$))*/g, htmltag: 'div'},
  toggleback:              {regex: /^ *plaintext/g, htmltag: 'label', htmlattrs: {id:'view', onclick: "UserDocument.toggleview()"}}
}

/*
 * sample input event handler
 */
UserDocument.inputonchange = function( inputelem ) {
  if (UserDocument.FOLDED) {
    const id = inputelem.parentNode.id;
    alert( `Contents of '` + id + `' is "` + inputelem.value + `"` );
  }
}
/*
 * sample button event handler
 */
UserDocument.buttononclick = function( buttonelem ) {
  if (UserDocument.FOLDED) {
    const id = buttonelem.id;
    alert( `Button '` + id + `' clicked` );
  }
}

/* onclick "handler": toggle plaintext view off and on */
UserDocument.toggleview = function( markup=true ) {
  if (UserDocument.FOLDED) {
    const elem = document.getElementById( 'stylotroncontainer' );
    if (markup)
      elem.innerHTML = SOT.markup( UserDocument.text, UserDocument.patternseries );
    else
      elem.innerHTML = SOT.markup( UserDocument.text, UserDocument.plaintextpatternseries );
  }
}
/* toggle a pattern */
UserDocument.togglepattern = function( patternname, patterndef ) {
  if (UserDocument.FOLDED) {
    const pc = document.getElementById( 'panelcontainer' );
    const scrollpos = {left:pc.scrollLeft, top:pc.scrollTop};
    if (UserDocument.patternseries[patternname])
      delete UserDocument.patternseries[patternname];
    else
      UserDocument.patternseries[patternname] = patterndef;
    UserDocument.toggleview( true );
    /* (all elements are new now, so 'pc' must be retrieved from the id again) */
    const pcnew = document.getElementById( 'panelcontainer' );
    pcnew.scroll( scrollpos.left, scrollpos.top );
  }
}
/* (onload isn't called by the IDE's WYSIWYG editor) */
UserDocument.onload = function() {
  UserDocument.text = document.getElementById('stylotroncontainer').innerText;
  UserDocument.toggleview();
}

/*!!!STYLOTRON IDE JS END!!!*/
document.addEventListener( 'DOMContentLoaded', UserDocument.onload );
  </script>

</head>

<body class="FOLDED" id="stylotroncontainer"><!--!!!STYLOTRON IDE INNERTEXT START!!!-->plaintext

STYLOTRON  DEMO


Stylotron (lib/stylotron.js) is a compact (~500 code lines) javascript library that uses patterns in plaintext documents to dynamically mark them up with structured html.

Markup is generated by applying a succession of patterns to a plaintext.  The matches of the most recently applied pattern are always marked up in the foreground.

Where matches are fully contained within others previously applied, typical nested markup is produced.  Matches that overlap or span others are segmented and the intersections are nested (since previously applied matches may have themselves been segmented, each set of matches is, technically speaking, nested inside and/or segmented around other segments).

The call that generates html from plaintext and patterns is:

 htmltext = SOT.markup( plaintext, patternseries );


Nesting

This series of patterns captures multi-line blocks, single-line blocks, and all occurrences of "CAT":

patternseries = {
  'block multiline':    /.+(?:\n(?!\n).+)+/g,
  'block singleline':   /(?&lt;=\n\n+|^\n*).+(?=\n\n+|\n*$)/g,
  cat:                  "CAT",
}

Because occurrences of "CAT" are captured last, they are marked up inside the two types of blocks.  The blocks never overlap and occurrences of "CAT" are always fully contained within them, so typical nested markup is generated.

The pattern names double as the class names that appear in the markup.  For example, a multi-line block marks up as:

 &lt;div class="block multiline"&gt;...&lt;/div&gt;

The nesting makes it possible to differentiate between CAT's in single-line blocks and a CAT's in multi-line blocks when styling the document:

A CAT in a single-line block

A CAT in a 
multi-line block


Segmentation

In the passage below, a selection, highlighted in blue, is captured first.  Capitalized words, highlighted in red, are captured next.

Lorem ipsum Dolor sit amet

Since the capword "Dolor" is fully contained in the selected range, it is nested inside it normally.  The capword "Lorem" overlaps the selection, so it is fragmented and the intersecting segment "rem" is nested inside the selection.

In the second passage, the order of the captures is reversed.  In this case, the selected range spans the capword "Dolor" and overlaps "Lorem".  To insure the selection is marked up in the foreground, it is split into four segments and the intersections "rem" and "Dolor" are marked up inside the respective capwords.

Lorem ipsum Dolor amet sit

The individual segments that make up the selection can be highlighted by tapping on or hovering over them.

A pattern's matches and their segments share the same CSS class, so the generated markup can be styled as if it is normal nested html in most cases.

Start and end segments include 'L' and/or 'R' indicators in their class lists, which makes it possible to target these in the CSS (class lists of unsegmented ranges include both indicators).  In the above examples, endcaps are styled with rounded corners on their terminal sides.


Patterns Used in this Demo

This demo, including toolbar and document framing, is entirely marked up from plaintext by Stylotron.

Patterns capturing framing elements are applied first, inner containers like blocks are applied next, and atomic forms like numbers are applied last.

The first three patterns generate document framing:

patternseries = {
  panelcontainer:          /(?:.*(?:\n|$))*/g,
  document:                /(?:.*(?:\n|$))*/g,
  toolbar:                 /^.+/g,

The 'panelcontainer' and 'document' patterns capture the entire text.  The panel container is used for positioning.  Room is left at the top for the toolbar, and on wide screens the container is centered horizontally.  The container is also scrollable.

The 'document' is marked up inside the panel container and holds the inner containers.

The 'toolbar' pattern captures the first line of the plaintext which is formatted as a toolbar and affixed to the top of the page.

The inner containers and atomic patterns are taken from stylotron-samplepatterns.js and styled with CSS from stylotron-samplestyles.css.  An overview of these is provided in the IDE's (stylotronIDE.html) introductory document.


Specialized Patterns

The pattern that produces the toolbar toggle is:

 'toggle view': {regex: /^ *plaintext/g, htmltag: 'label', htmlattrs: {id:'view', onclick: "UserDocument.toggleview(false)"}}

Patterns can also mark up images, inputs, and buttons:

sample image

_$input$_

_#button#_


<!--!!!STYLOTRON IDE INNERTEXT END!!!--></body></html><!--!!!STYLOTRON IDE PLAINTEXT START!!!plaintext

STYLOTRON  DEMO


Stylotron (lib/stylotron.js) is a compact (~500 code lines) javascript library that uses patterns in plaintext documents to dynamically mark them up with structured html.

Markup is generated by applying a succession of patterns to a plaintext.  The matches of the most recently applied pattern are always marked up in the foreground.

Where matches are fully contained within others previously applied, typical nested markup is produced.  Matches that overlap or span others are segmented and the intersections are nested (since previously applied matches may have themselves been segmented, each set of matches is, technically speaking, nested inside and/or segmented around other segments).

The call that generates html from plaintext and patterns is:

 htmltext = SOT.markup( plaintext, patternseries );


Nesting

This series of patterns captures multi-line blocks, single-line blocks, and all occurrences of "CAT":

patternseries = {
  'block multiline':    /.+(?:\n(?!\n).+)+/g,
  'block singleline':   /(?<=\n\n+|^\n*).+(?=\n\n+|\n*$)/g,
  cat:                  "CAT",
}

Because occurrences of "CAT" are captured last, they are marked up inside the two types of blocks.  The blocks never overlap and occurrences of "CAT" are always fully contained within them, so typical nested markup is generated.

The pattern names double as the class names that appear in the markup.  For example, a multi-line block marks up as:

 <div class="block multiline">...</div>

The nesting makes it possible to differentiate between CAT's in single-line blocks and a CAT's in multi-line blocks when styling the document:

A CAT in a single-line block

A CAT in a 
multi-line block


Segmentation

In the passage below, a selection, highlighted in blue, is captured first.  Capitalized words, highlighted in red, are captured next.

Lorem ipsum Dolor sit amet

Since the capword "Dolor" is fully contained in the selected range, it is nested inside it normally.  The capword "Lorem" overlaps the selection, so it is fragmented and the intersecting segment "rem" is nested inside the selection.

In the second passage, the order of the captures is reversed.  In this case, the selected range spans the capword "Dolor" and overlaps "Lorem".  To insure the selection is marked up in the foreground, it is split into four segments and the intersections "rem" and "Dolor" are marked up inside the respective capwords.

Lorem ipsum Dolor amet sit

The individual segments that make up the selection can be highlighted by tapping on or hovering over them.

A pattern's matches and their segments share the same CSS class, so the generated markup can be styled as if it is normal nested html in most cases.

Start and end segments include 'L' and/or 'R' indicators in their class lists, which makes it possible to target these in the CSS (class lists of unsegmented ranges include both indicators).  In the above examples, endcaps are styled with rounded corners on their terminal sides.


Patterns Used in this Demo

This demo, including toolbar and document framing, is entirely marked up from plaintext by Stylotron.

Patterns capturing framing elements are applied first, inner containers like blocks are applied next, and atomic forms like numbers are applied last.

The first three patterns generate document framing:

patternseries = {
  panelcontainer:          /(?:.*(?:\n|$))*/g,
  document:                /(?:.*(?:\n|$))*/g,
  toolbar:                 /^.+/g,

The 'panelcontainer' and 'document' patterns capture the entire text.  The panel container is used for positioning.  Room is left at the top for the toolbar, and on wide screens the container is centered horizontally.  The container is also scrollable.

The 'document' is marked up inside the panel container and holds the inner containers.

The 'toolbar' pattern captures the first line of the plaintext which is formatted as a toolbar and affixed to the top of the page.

The inner containers and atomic patterns are taken from stylotron-samplepatterns.js and styled with CSS from stylotron-samplestyles.css.  An overview of these is provided in the IDE's (stylotronIDE.html) introductory document.


Specialized Patterns

The pattern that produces the toolbar toggle is:

 'toggle view': {regex: /^ *plaintext/g, htmltag: 'label', htmlattrs: {id:'view', onclick: "UserDocument.toggleview(false)"}}

Patterns can also mark up images, inputs, and buttons:

sample image

_$input$_

_#button#_


!!!STYLOTRON IDE PLAINTEXT END!!!-->